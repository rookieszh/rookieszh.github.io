<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>What is Code Refactoring and How To Refactor</title>
      <link href="/2020/03/01/What-is-Code-Refactoring-and-How-To-Refactor/"/>
      <url>/2020/03/01/What-is-Code-Refactoring-and-How-To-Refactor/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是重构"><a href="#什么是重构" class="headerlink" title="什么是重构"></a>什么是重构</h2><h3 id="误区与定义"><a href="#误区与定义" class="headerlink" title="误区与定义"></a>误区与定义</h3><p>误区：把任何形式的代码清理当做重构。<br>定义：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低修改成本。</p><h3 id="软件工程质量"><a href="#软件工程质量" class="headerlink" title="软件工程质量"></a>软件工程质量</h3><p>外部质量</p><ul><li>Functionality(功能性)</li><li>Usability(可用性)</li><li>Reliability(可靠性)</li><li>Performance(性能)</li><li>Supportability/Safety(维护性、安全性)</li></ul><p>内部质量</p><ul><li>代码质量(不可见)</li></ul><h2 id="为何需要重构"><a href="#为何需要重构" class="headerlink" title="为何需要重构"></a>为何需要重构</h2><h3 id="技术债务"><a href="#技术债务" class="headerlink" title="技术债务"></a>技术债务</h3><blockquote><p>开发团队在设计或架构选型时从短期效应的角度选择了一个易于实现的方案，但从长远来看，这种方案会带来消极的影响，亦即开发团队所欠的债务。 ——Ward Cunningham</p></blockquote><h3 id="破窗效应"><a href="#破窗效应" class="headerlink" title="破窗效应"></a>破窗效应</h3><h3 id="重构的收益"><a href="#重构的收益" class="headerlink" title="重构的收益"></a>重构的收益</h3><p>重构改进软件的设计——保持架构活力<br>重构使软件更容易理解——易理解&gt;易维护&gt;高效率<br>重构帮助找到BUG——结构清晰更容易发现问题<br>重构提高编程速度——更快迭代</p><h3 id="重构的挑战"><a href="#重构的挑战" class="headerlink" title="重构的挑战"></a>重构的挑战</h3><ol><li>工期延误：Baby step、长期收益</li><li>破坏功能：单元测试很重要、使用Eclipse的自动化重构工具</li><li>性能下降<br>深奥的代码并不能给编译器提供更好的优化线索<br>影响系统效率的关键通常只在10%的代码上<br>调优一段整洁的代码，比调优一段“被优化过”的代码容易的多</li></ol><h2 id="Java-中如何减少-if-else-嵌套"><a href="#Java-中如何减少-if-else-嵌套" class="headerlink" title="Java 中如何减少 if-else 嵌套"></a>Java 中如何减少 if-else 嵌套</h2><p>场景：</p><ol><li>异常逻辑处理：只能一个分支是正常流程</li><li>不同状态处理：所有分支都是正常流程</li></ol><h3 id="接口分层"><a href="#接口分层" class="headerlink" title="接口分层"></a>接口分层</h3><p>把接口分为外部和内部接口，所有空值判断放在外部接口完成；而内部接口传入的变量由外部接口保证不为空，从而减少空值判断。</p><h3 id="利用多态"><a href="#利用多态" class="headerlink" title="利用多态"></a>利用多态</h3><p>利用多态，把业务判断消除，各子类分别关注自己的实现，并实现子类的创建方法，避免用户了解过多的类。<br>但使用多态对原来代码修改过大，最好在设计之初就使用多态方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重构前</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_LINK = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_IMAGE = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_TEXT = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_IMAGE_TEXT = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShareItem</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> type;</span><br><span class="line">    String title;</span><br><span class="line">    String content;</span><br><span class="line">    String imagePath;</span><br><span class="line">    String link;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ShareListener</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> STATE_SUCC = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> STATE_FAIL = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onCallback</span><span class="params">(<span class="keyword">int</span> state, String msg)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">share</span><span class="params">(ShareItem item, ShareListener listener)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    shareImpl(item, listener);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shareImpl</span> <span class="params">(ShareItem item, ShareListener listener)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (item.type == TYPE_LINK) &#123;</span><br><span class="line">        <span class="comment">// 分享链接</span></span><br><span class="line">        <span class="keyword">if</span> (!TextUtils.isEmpty(item.link) &amp;&amp; !TextUtils.isEmpty(item.title)) &#123;</span><br><span class="line">            doShareLink(item.link, item.title, item.content, listener);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            listener.onCallback(ShareListener.STATE_FAIL, <span class="string">"分享信息不完整"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.type == TYPE_IMAGE) &#123;</span><br><span class="line">        <span class="comment">// 分享图片</span></span><br><span class="line">        <span class="keyword">if</span> (!TextUtils.isEmpty(item.imagePath)) &#123;</span><br><span class="line">            doShareImage(item.imagePath, listener);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            listener.onCallback(ShareListener.STATE_FAIL, <span class="string">"分享信息不完整"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        listener.onCallback(ShareListener.STATE_FAIL, <span class="string">"不支持的分享类型"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重构后</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ShareItem</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> type;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShareItem</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doShare</span><span class="params">(ShareListener listener)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Link</span> <span class="keyword">extends</span> <span class="title">ShareItem</span> </span>&#123;</span><br><span class="line">    String title;</span><br><span class="line">    String content;</span><br><span class="line">    String link;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Link</span><span class="params">(String link, String title, String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(TYPE_LINK);</span><br><span class="line">        <span class="keyword">this</span>.link = !TextUtils.isEmpty(link) ? link : <span class="string">"default"</span>;</span><br><span class="line">        <span class="keyword">this</span>.title = !TextUtils.isEmpty(title) ? title : <span class="string">"default"</span>;</span><br><span class="line">        <span class="keyword">this</span>.content = !TextUtils.isEmpty(content) ? content : <span class="string">"default"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doShare</span><span class="params">(ShareListener listener)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do share</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Image</span> <span class="keyword">extends</span> <span class="title">ShareItem</span> </span>&#123;</span><br><span class="line">    String imagePath;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Image</span><span class="params">(String imagePath)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(TYPE_IMAGE);</span><br><span class="line">        <span class="keyword">this</span>.imagePath = !TextUtils.isEmpty(imagePath) ? imagePath : <span class="string">"default"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doShare</span><span class="params">(ShareListener listener)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do share</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">share</span><span class="params">(ShareItem item, ShareListener listener)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    shareImpl(item, listener);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shareImpl</span> <span class="params">(ShareItem item, ShareListener listener)</span> </span>&#123;</span><br><span class="line">    item.doShare(listener);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Map分支"><a href="#Map分支" class="headerlink" title="Map分支"></a>Map分支</h3><p>把分支状态信息预先缓存在Map里，直接get获取具体值，消除分支。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;Integer, Class&lt;? extends ShareItem&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map.put(TYPE_LINK, Link<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    map.put(TYPE_IMAGE, Image<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    map.put(TYPE_TEXT, Text<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    map.put(TYPE_IMAGE_TEXT, ImageText<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ShareItem <span class="title">createShareItem</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class&lt;? extends ShareItem&gt; shareItemClass = map.get(type);</span><br><span class="line">        <span class="keyword">return</span> shareItemClass.newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultShareItem(); <span class="comment">// 返回默认实现，不要返回null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合并条件表达式"><a href="#合并条件表达式" class="headerlink" title="合并条件表达式"></a>合并条件表达式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重构前</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">disablityAmount</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(_seniority &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(_monthsDisabled &gt; <span class="number">12</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(_isPartTime)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重构后</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">disablityAmount</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(_seniority &lt; <span class="number">2</span> || _monthsDisabled &gt; <span class="number">12</span> || _isPartTime)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="提前return"><a href="#提前return" class="headerlink" title="提前return"></a>提前return</h3><p>改为平行关系，而非包含关系<br>尽可能地维持正常流程代码在最外层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重构前</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getPayAmount</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> result;</span><br><span class="line">    <span class="keyword">if</span>(_isDead) &#123;</span><br><span class="line">        result = deadAmount();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(_isSeparated)</span><br><span class="line">            result = separatedAmount();</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(_isRetired)</span><br><span class="line">                result = retiredAmount();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                result = normalPayAmount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重构后</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getPayAmount</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(_isDead)</span><br><span class="line">        <span class="keyword">return</span> deadAmount();</span><br><span class="line">    <span class="keyword">if</span>(_isSeparated)</span><br><span class="line">        <span class="keyword">return</span> separatedAmount();</span><br><span class="line">    <span class="keyword">if</span>(_isRetired)</span><br><span class="line">        <span class="keyword">return</span> retiredAmount();</span><br><span class="line">    <span class="keyword">return</span> normalPayAmount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将条件反转使异常情况先退出，让正常流程维持在主干流程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重构前</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getAdjustedCapital</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> result = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">if</span>(_capital &gt; <span class="number">0.0</span> )&#123;</span><br><span class="line">        <span class="keyword">if</span>(_intRate &gt; <span class="number">0</span> &amp;&amp; _duration &gt;<span class="number">0</span>)&#123;</span><br><span class="line">            resutl = (_income / _duration) *ADJ_FACTOR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重构后</span></span><br><span class="line"><span class="comment">// (_income / _duration) *ADJ_FACTOR 是主流程，根据优化原则（尽可能地维持正常流程代码在最外层），放到最外层</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getAdjustedCapital</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(_capital &lt;= <span class="number">0.0</span> )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(_intRate &lt;= <span class="number">0</span> || _duration &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (_income / _duration) *ADJ_FACTOR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="if-else-封装"><a href="#if-else-封装" class="headerlink" title="if-else 封装"></a>if-else 封装</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getPayAmount</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Object obj = getObj();</span><br><span class="line">    <span class="keyword">if</span> (obj.getType == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> getType1Money(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (obj.getType == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> getType2Money(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getType1Money</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">    ObjectA objA = obj.getObjectA();</span><br><span class="line">    <span class="keyword">return</span> objA.getMoney()*obj.getNormalMoneryA();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getType2Money</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">    ObjectB objB = obj.getObjectB();</span><br><span class="line">    <span class="keyword">return</span> objB.getMoney()*obj.getNormalMoneryB()+<span class="number">1000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Refactor Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Use Regex in Python</title>
      <link href="/2020/02/09/Use-Regex-in-Python/"/>
      <url>/2020/02/09/Use-Regex-in-Python/</url>
      
        <content type="html"><![CDATA[<h2 id="原始字符串"><a href="#原始字符串" class="headerlink" title="原始字符串"></a>原始字符串</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原始字符串（raw string）是所有的字符串都是直接按照字面的意思来使用，没有转义特殊或不能打印的字符，通常简称为 r-string。</span></span><br><span class="line"><span class="comment"># 可以用于设定匹配规则时使用</span></span><br><span class="line">print(<span class="string">'\blake'</span>)</span><br><span class="line">print(<span class="string">r'\blake'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lake</span><br><span class="line">    \blake</span><br></pre></td></tr></table></figure><h2 id="正则表达式的使用"><a href="#正则表达式的使用" class="headerlink" title="正则表达式的使用"></a>正则表达式的使用</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">look_for</span><span class="params">(pat, str)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'没有找到'</span> <span class="keyword">if</span> re.search(pat, str) <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> re.findall(pat, str)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 小括号</span></span><br><span class="line">pat = <span class="string">r'beat(s|ed|en|ing)'</span></span><br><span class="line">print( look_for(pat, <span class="string">'beats'</span>) )</span><br><span class="line">print( look_for(pat, <span class="string">'beated'</span>) )</span><br><span class="line">print( look_for(pat, <span class="string">'beaten'</span>) )</span><br><span class="line">print( look_for(pat, <span class="string">'beating'</span>) )</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">'s'</span>]</span><br><span class="line">    [<span class="string">'ed'</span>]</span><br><span class="line">    [<span class="string">'en'</span>]</span><br><span class="line">    [<span class="string">'ing'</span>]</span><br><span class="line"></span><br><span class="line">pat = <span class="string">r'(beat(s|ed|en|ing))'</span></span><br><span class="line">print( look_for(pat, <span class="string">'beats'</span>) )</span><br><span class="line">print( look_for(pat, <span class="string">'beated'</span>) )</span><br><span class="line">print( look_for(pat, <span class="string">'beaten'</span>) )</span><br><span class="line">print( look_for(pat, <span class="string">'beating'</span>) )</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[(<span class="string">'beats'</span>, <span class="string">'s'</span>)]</span><br><span class="line">    [(<span class="string">'beated'</span>, <span class="string">'ed'</span>)]</span><br><span class="line">    [(<span class="string">'beaten'</span>, <span class="string">'en'</span>)]</span><br><span class="line">    [(<span class="string">'beating'</span>, <span class="string">'ing'</span>)]</span><br><span class="line"></span><br><span class="line">pat = <span class="string">r'(beat(?:s|ed|en|ing))'</span></span><br><span class="line">print( look_for(pat, <span class="string">'beats'</span>) )</span><br><span class="line">print( look_for(pat, <span class="string">'beated'</span>) )</span><br><span class="line">print( look_for(pat, <span class="string">'beaten'</span>) )</span><br><span class="line">print( look_for(pat, <span class="string">'beating'</span>) )</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">'beats'</span>]</span><br><span class="line">    [<span class="string">'beated'</span>]</span><br><span class="line">    [<span class="string">'beaten'</span>]</span><br><span class="line">    [<span class="string">'beating'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># \b \B</span></span><br><span class="line">pat = <span class="string">r'\blearn\b'</span></span><br><span class="line">print( look_for(pat, <span class="string">'learn Python'</span>) )</span><br><span class="line">print( look_for(pat, <span class="string">'relearn Python'</span>) )</span><br><span class="line">print( look_for(pat, <span class="string">'learning Python'</span>) )</span><br><span class="line">print( look_for(pat, <span class="string">'relearning Python'</span>) )</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">'learn'</span>]</span><br><span class="line">    没有找到</span><br><span class="line">    没有找到</span><br><span class="line">    没有找到</span><br><span class="line"></span><br><span class="line">pat = <span class="string">r'\Blearn\B'</span></span><br><span class="line">print( look_for(pat, <span class="string">'learn Python'</span>) )</span><br><span class="line">print( look_for(pat, <span class="string">'relearn Python'</span>) )</span><br><span class="line">print( look_for(pat, <span class="string">'learning Python'</span>) )</span><br><span class="line">print( look_for(pat, <span class="string">'relearning Python'</span>) )</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>没有找到</span><br><span class="line">    没有找到</span><br><span class="line">    没有找到</span><br><span class="line">    [<span class="string">'learn'</span>]</span><br></pre></td></tr></table></figure><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># match(pat, str)：检查字符串的开头是否符合某个模式</span></span><br><span class="line"><span class="comment"># 该函数返回的是个对象（包括匹配的子字符串和在句中的位置索引），如果只需要子字符串，需要用 group() 函数。</span></span><br><span class="line"><span class="comment"># 由于值匹配句头，那么句中的 Bryant 无法被匹配到。</span></span><br><span class="line">s = <span class="string">'Kobe Bryant'</span></span><br><span class="line">print( re.match(<span class="string">r'Kobe'</span>, s) )</span><br><span class="line">print( re.match(<span class="string">r'Kobe'</span>, s).group() )</span><br><span class="line">print( re.match(<span class="string">r'Bryant'</span>, s) )</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&lt;re.Match object; span=(<span class="number">0</span>, <span class="number">4</span>), match=<span class="string">'Kobe'</span>&gt;</span><br><span class="line">    Kobe</span><br><span class="line">    <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># search(pat, str)：检查字符串中是否符合某个模式，但只匹配第一个</span></span><br><span class="line">s = <span class="string">'Kobe Bryant'</span></span><br><span class="line">print( re.search(<span class="string">r'Kobe'</span>, s) )</span><br><span class="line">print( re.search(<span class="string">r'Kobe'</span>, s).group() )</span><br><span class="line">print( re.search(<span class="string">r'Bryant'</span>, s) )</span><br><span class="line">print( re.search(<span class="string">r'Bryant'</span>, s).group() )</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&lt;re.Match object; span=(<span class="number">0</span>, <span class="number">4</span>), match=<span class="string">'Kobe'</span>&gt;</span><br><span class="line">    Kobe</span><br><span class="line">    &lt;re.Match object; span=(<span class="number">5</span>, <span class="number">11</span>), match=<span class="string">'Bryant'</span>&gt;</span><br><span class="line">    Bryant</span><br><span class="line"></span><br><span class="line"><span class="comment"># findall(pat, str)：返回所有符合某个模式的字符串，以列表形式输出</span></span><br><span class="line">s = <span class="string">'Kobe Bryant loves Gianna Bryant'</span></span><br><span class="line">print( re.findall(<span class="string">r'Kobe'</span>, s) )</span><br><span class="line">print( re.findall(<span class="string">r'Bryant'</span>, s) )</span><br><span class="line">print( re.findall(<span class="string">r'Gigi'</span>, s) )</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">'Kobe'</span>]</span><br><span class="line">    [<span class="string">'Bryant'</span>, <span class="string">'Bryant'</span>]</span><br><span class="line">    []</span><br><span class="line"></span><br><span class="line"><span class="comment"># finditer(pat, str)：返回所有符合某个模式的字符串，以迭代器形式输出</span></span><br><span class="line"><span class="comment"># 如果需要匹配子串在原句中的位置索引，用 finditer，此外用 findall。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># split(pat, str)：以某个模式为分割点，拆分整个句子为一系列字符串，以列表形式输出</span></span><br><span class="line">s = <span class="string">'Kobe Bryant loves Gianna Bryant'</span></span><br><span class="line">print( re.split(<span class="string">r'\s'</span>, s) )</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">'Kobe'</span>, <span class="string">'Bryant'</span>, <span class="string">'loves'</span>, <span class="string">'Gianna'</span>, <span class="string">'Bryant'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># sub(pat, repl, str)：句子 str 中找到匹配正则表达式模式的所有子字符串，用另一个字符串 repl 进行替换</span></span><br><span class="line">s = <span class="string">'Kobe Bryant loves Gianna Bryant'</span></span><br><span class="line">print( re.sub(<span class="string">r'\s'</span>, <span class="string">'-'</span>, s) )</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Kobe-Bryant-loves-Gianna-Bryant</span><br><span class="line"></span><br><span class="line"><span class="comment"># compile(pat)：将某个模式编译成对象，供之后使用，如match 和 search 使用</span></span><br><span class="line">email = <span class="string">'''Shengyuan Personal: quantsteven@gmail.com</span></span><br><span class="line"><span class="string">Shengyuan Work: shengyuan@octagon-advisors.com</span></span><br><span class="line"><span class="string">Shengyuan School: g0700508@nus.edu.sg</span></span><br><span class="line"><span class="string">Obama: barack.obama@whitehouse.gov'''</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pat = <span class="string">r'[\w.-]+@[\w.-]+'</span></span><br><span class="line">obj = re.compile(pat)</span><br><span class="line">obj</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.compile(<span class="string">r'[\w.-]+@[\w.-]+'</span>, re.UNICODE)</span><br><span class="line"></span><br><span class="line">print( obj.match(email), <span class="string">'\n'</span>)</span><br><span class="line">print( obj.search(email), <span class="string">'\n'</span> )</span><br><span class="line">print( obj.findall(email), <span class="string">'\n'</span> )</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">None</span></span><br><span class="line">    &lt;re.Match object; span=(<span class="number">20</span>, <span class="number">41</span>), match=<span class="string">'quantsteven@gmail.com'</span>&gt; </span><br><span class="line">    [<span class="string">'quantsteven@gmail.com'</span>,</span><br><span class="line">    <span class="string">'shengyuan@octagon-advisors.com'</span>,</span><br><span class="line">    <span class="string">'g0700508@nus.edu.sg'</span>,</span><br><span class="line">    <span class="string">'barack.obama@whitehouse.gov'</span>]</span><br><span class="line"></span><br><span class="line">obj1 = re.compile(<span class="string">r'@'</span>)</span><br><span class="line"><span class="keyword">for</span> addr <span class="keyword">in</span> obj.findall(email):</span><br><span class="line">    print( obj1.split(addr))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">'quantsteven'</span>, <span class="string">'gmail.com'</span>]</span><br><span class="line">    [<span class="string">'shengyuan'</span>, <span class="string">'octagon-advisors.com'</span>]</span><br><span class="line">    [<span class="string">'g0700508'</span>, <span class="string">'nus.edu.sg'</span>]</span><br><span class="line">    [<span class="string">'barack.obama'</span>, <span class="string">'whitehouse.gov'</span>]</span><br></pre></td></tr></table></figure><h2 id="常量模块"><a href="#常量模块" class="headerlink" title="常量模块"></a>常量模块</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 常量可叠加使用，因为常量值都是2的幂次方值，所以是可以叠加使用的，叠加时请使用 | 符号</span></span><br><span class="line"><span class="comment"># 使用举例</span></span><br><span class="line">re.findall(pattern, string, re.模块)</span><br><span class="line"></span><br><span class="line"><span class="comment"># re.IGNORECASE / re.I : 忽略大小写</span></span><br><span class="line"><span class="comment"># re.ASCII / re.A : 只匹配 ASCII 码，让 \w,\W,\b,\B,\d,\D,\s和\S 只匹配ASCII， 不匹配 Unicode 等其他码</span></span><br><span class="line"><span class="comment"># re.DOTALL / re.S : 让 . 能匹配所有，包括换行符\n。默认模式下 . 是不能匹配行符\n的</span></span><br><span class="line"><span class="comment"># re.MULTILINE / re.M : 多行模式，当某字符串中有换行符\n，默认模式下是不支持换行符特性的，比如：行开头 和 行结尾，而多行模式下是支持匹配行开头的。</span></span><br><span class="line"><span class="comment"># re.VERBOSE / re.X : 详细模式，可以在正则表达式中加注解！</span></span><br><span class="line"><span class="comment"># re.UNICODE / re.U : 与 ASCII 模式类似，匹配unicode编码支持的字符，但是 Python 3 默认字符串已经是Unicode，所以有点冗余。</span></span><br><span class="line"><span class="comment"># re.DEBUG : 显示编译时的debug信息</span></span><br></pre></td></tr></table></figure><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># re模块还包含了一个正则表达式的编译错误</span></span><br><span class="line"><span class="comment"># 当我们给出的正则表达式是一个无效的表达式（就是表达式本身有问题）时，就会raise一个异常</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Regex </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Regex</title>
      <link href="/2020/01/13/Regex/"/>
      <url>/2020/01/13/Regex/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Regular expression (regex/regexp)<br>正则表达式是一种从左到右匹配主体字符串的模式<br>正则表达式可以从一个基础字符串中根据一定的匹配模式替换文本中的字符串、验证表单、提取字符串等等<br><a href="https://regex101.com/" target="_blank" rel="noopener">在线正则</a></p></blockquote><h2 id="基本匹配"><a href="#基本匹配" class="headerlink" title="基本匹配"></a>基本匹配</h2><p>正则表达式其实就是在执行搜索时的格式，它由一些字母和数字组合而成。例如：一个正则表达式 the，它表示一个规则：由字母t开始，接着是h，再接着是e。正则表达式是大小写敏感的。</p><h2 id="元字符-meta-character"><a href="#元字符-meta-character" class="headerlink" title="元字符 meta character"></a>元字符 meta character</h2><blockquote><p>正则表达式主要依赖于元字符。 元字符不代表他们本身的字面意思，他们都有特殊的含义。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">——————点运算符</span><br><span class="line">.句号匹配任意单个字符除了换行符。</span><br><span class="line"></span><br><span class="line">——————字符集与否定字符集</span><br><span class="line">[ ]字符种类。匹配方括号内的任意字符。不关心顺序。[.]方括号中的句号就表示句号，不是元字符。</span><br><span class="line">[^ ]否定的字符种类。匹配除了方括号里的任意字符。不关心顺序。</span><br><span class="line"></span><br><span class="line">——————重复次数</span><br><span class="line">*匹配&gt;&#x3D;0个重复的在*号之前的字符。</span><br><span class="line">+匹配&gt;&#x3D;1个重复的+号前的字符。</span><br><span class="line">?标记?之前的字符为可选，即出现 0 或 1 次。</span><br><span class="line"></span><br><span class="line">——————&#123;&#125;，是一个量词</span><br><span class="line">&#123;n,m&#125;匹配num个大括号之间的字符 (n &lt;&#x3D; num &lt;&#x3D; m).</span><br><span class="line">&#123;n,&#125;匹配num个大括号之间的字符 (n &lt;&#x3D; num).</span><br><span class="line">&#123;,m&#125;匹配num个大括号之间的字符 (num &lt;&#x3D; m).</span><br><span class="line">&#123;n&#125;匹配num个大括号之间的字符 (n &#x3D; num).</span><br><span class="line"></span><br><span class="line">——————(...) 特征标群</span><br><span class="line">(xyz)字符集，匹配与 xyz 完全相等的字符串，() 中用或字符 | 表示或。</span><br><span class="line"></span><br><span class="line">—————— | 或运算符</span><br><span class="line">|或运算符，匹配符号前或后的字符。</span><br><span class="line"></span><br><span class="line">——————转码特殊字符</span><br><span class="line">\转义字符,用于匹配一些保留的字符 [ ] ( ) &#123; &#125; . * + ? ^ $ \ |</span><br><span class="line"></span><br><span class="line">——————锚点</span><br><span class="line">^用来检查匹配的字符串是否在所匹配字符串的开头。</span><br><span class="line">$用来匹配字符是否是最后一个，例如(at\.)$ 匹配以 at. 结尾的字符串。</span><br><span class="line"></span><br><span class="line">——————只匹配不获取</span><br><span class="line">?:加在目标之前</span><br></pre></td></tr></table></figure><h2 id="简写字符集"><a href="#简写字符集" class="headerlink" title="简写字符集"></a>简写字符集</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">大写和小写互补，两者加一起是全集</span><br><span class="line"></span><br><span class="line">\b匹配空字符串，但仅适用于单词的“首尾”</span><br><span class="line">\B匹配空字符串，但仅适用于单词的“非首尾”</span><br><span class="line">.除换行符外的所有字符</span><br><span class="line">\w匹配所有字母数字下划线，等同于 [a-zA-Z0-9_]</span><br><span class="line">\W匹配所有非字母数字，即符号，等同于： [^\w]</span><br><span class="line">\d匹配数字： [0-9]</span><br><span class="line">\D匹配非数字： [^\d]</span><br><span class="line">\s匹配所有空格字符，等同于： [\t\n\f\r\p&#123;Z&#125;]</span><br><span class="line">\S匹配所有非空格字符： [^\s]</span><br><span class="line">\f匹配一个换页符</span><br><span class="line">\n匹配一个换行符</span><br><span class="line">\r匹配一个回车符</span><br><span class="line">\t匹配一个制表符</span><br><span class="line">\v匹配一个垂直制表符</span><br><span class="line">\p匹配 CR&#x2F;LF（等同于 \r\n），用来匹配 DOS 行终止符</span><br><span class="line">\A匹配句子的“开头”字符，等价于 ^</span><br><span class="line">\Z匹配句子的“结尾”字符，等价于 $</span><br></pre></td></tr></table></figure><h2 id="零宽度断言（前后预查）"><a href="#零宽度断言（前后预查）" class="headerlink" title="零宽度断言（前后预查）"></a>零宽度断言（前后预查）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">?&#x3D;正先行断言-存在    (T|t)he(?&#x3D;\sfat): 判断 The 或 the 后面是否紧跟着 (空格)fat，匹配对象是 The、the，不是\sfat</span><br><span class="line">?!负先行断言-排除</span><br><span class="line">?&lt;&#x3D;正后发断言-存在    (?&lt;&#x3D;(T|t)he\s)(fat|mat): 匹配 fat 和 mat，且其前跟着 The 或 the</span><br><span class="line">?&lt;!负后发断言-排除</span><br></pre></td></tr></table></figure><h2 id="标志-模式修正符"><a href="#标志-模式修正符" class="headerlink" title="标志/模式修正符"></a>标志/模式修正符</h2><blockquote><p>用来修改表达式的搜索结果。这些标志可以任意的组合使用，它也是整个正则表达式的一部分。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">i忽略大小写。</span><br><span class="line">g全局搜索。</span><br><span class="line">m多行修饰符：锚点元字符 ^ $ 工作范围在每行的起始。</span><br><span class="line"></span><br><span class="line">&#x2F;The&#x2F;gi 全局搜索所有不分大小写的the</span><br><span class="line"></span><br><span class="line">以下匹配上了fat、cat、mat</span><br><span class="line">&#x2F;.at(.)?$&#x2F;gm &#x3D;&gt; The fat</span><br><span class="line">                cat sat</span><br><span class="line">                on the mat.</span><br></pre></td></tr></table></figure><h2 id="贪婪匹配与惰性匹配"><a href="#贪婪匹配与惰性匹配" class="headerlink" title="贪婪匹配与惰性匹配"></a>贪婪匹配与惰性匹配</h2><blockquote><p>正则表达式默认采用贪婪匹配模式，在该模式下意味着会匹配尽可能长的子串。我们可以使用 ? 将贪婪匹配模式转化为惰性匹配模式。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">以下除了最后的 . ，其他全部匹配上</span><br><span class="line">(.*at) &#x3D;&gt; The fat cat sat on the mat.</span><br><span class="line"></span><br><span class="line">以下只匹配了 The fat </span><br><span class="line">(.*?at) &#x3D;&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Regex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker Tools</title>
      <link href="/2019/12/03/Docker-Tools/"/>
      <url>/2019/12/03/Docker-Tools/</url>
      
        <content type="html"><![CDATA[<h4 id="watchtower：自动更新-Docker-容器"><a href="#watchtower：自动更新-Docker-容器" class="headerlink" title="watchtower：自动更新 Docker 容器"></a>watchtower：自动更新 Docker 容器</h4><blockquote><p><a href="https://github.com/v2tec/watchtower" target="_blank" rel="noopener">https://github.com/v2tec/watchtower</a></p></blockquote><p>Watchtower 监视运行容器并监视这些容器最初启动时的镜像有没有变动。当 Watchtower 检测到一个镜像已经有变动时，它会使用新镜像自动重新启动相应的容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Watchtower 本身被打包为 Docker 镜像，因此可以像运行任何其他容器一样运行它。</span><br><span class="line">docker run -d --name watchtower --rm -v &#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;var&#x2F;run&#x2F;docker.sock  v2tec&#x2F;watchtower --interval 30</span><br></pre></td></tr></table></figure><p>使用挂载文件 /var/run/docker.sock 启动 Watchtower 容器。这么做是为了使 Watchtower 可以与 Docker 守护 API 进行交互。我们将 30 秒传递给间隔选项 interval。此选项定义了 Watchtower 的轮询间隔。<br>比如现在启动一个 Watchtower 可以监视的容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -p 4000:80 --name friendlyhello shekhargulati&#x2F;friendlyhello:latest</span><br></pre></td></tr></table></figure><p>现在，Watchtower 将开始温和地监控这个 friendlyhello 容器。当我将新镜像推送到 Docker Hub 时，Watchtower 在接下来的运行中将检测到一个新的可用的镜像。它将优雅地停止那个容器并使用这个新镜像启动容器。它将传递我们之前传递给这条 run 命令的选项。换句话说，该容器将仍然使用 4000:80 发布端口来启动。</p><p>默认情况下，Watchtower 将轮询 Docker Hub 注册表以查找更新的镜像。通过传递环境变量 REPO_USER 和 REPO_PASS 中的注册表凭据，可以将 Watchtower 配置为轮询私有注册表。</p><h4 id="docker-slim：面向容器的神奇减肥药"><a href="#docker-slim：面向容器的神奇减肥药" class="headerlink" title="docker-slim：面向容器的神奇减肥药"></a>docker-slim：面向容器的神奇减肥药</h4><blockquote><p><a href="https://github.com/docker-slim/docker-slim" target="_blank" rel="noopener">https://github.com/docker-slim/docker-slim</a></p></blockquote><p>docker-slim 工具使用静态和动态分析方法来为你臃肿的镜像瘦身。要使用 docker-slim，可以从 Github 下载 Linux 或者 Mac 的二进制安装包。成功下载之后，将它加入到你的系统变量 PATH 中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-slim build --http-probe friendlyhello</span><br></pre></td></tr></table></figure><h4 id="ctop：容器的类顶层接口"><a href="#ctop：容器的类顶层接口" class="headerlink" title="ctop：容器的类顶层接口"></a>ctop：容器的类顶层接口</h4><blockquote><p><a href="https://github.com/bcicen/ctop" target="_blank" rel="noopener">https://github.com/bcicen/ctop</a></p></blockquote><p>ctop 能够提供多个容器的实时指标视图。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># mac 安装</span><br><span class="line">$ brew install ctop</span><br></pre></td></tr></table></figure><p>一旦完成安装，就可以开始使用 ctop 了。现在，你只需要配置 DOCKER_HOST 环境变量。<br>你可以运行 ctop 命令，查看所有容器的状态。<br>若只想查看正在运行的容器，可以使用 ctop -a 命令。</p>]]></content>
      
      
      <categories>
          
          <category> Basic Component </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Message Queue ——RabbitMQ</title>
      <link href="/2019/11/11/Message-Queue-%E2%80%94%E2%80%94RabbitMQ/"/>
      <url>/2019/11/11/Message-Queue-%E2%80%94%E2%80%94RabbitMQ/</url>
      
        <content type="html"><![CDATA[<h2 id="消息中间件"><a href="#消息中间件" class="headerlink" title="消息中间件"></a>消息中间件</h2><p>消息中间件有很多种，如 activemq, rabbitmq 等等。</p><h2 id="RabbitMQ-模式概述"><a href="#RabbitMQ-模式概述" class="headerlink" title="RabbitMQ 模式概述"></a>RabbitMQ 模式概述</h2><blockquote><p> rabbitmq 使用的是一种叫做 AMQP 的协议来通信。 AMQP 是 advanced Message Queuing Protocol 的缩写。简单地说，通过这种协议，可以处理更为复杂的业务需求。</p></blockquote><p>基于 AMQP 这种协议，可以实现如下各种模式。</p><h3 id="消息路由过程"><a href="#消息路由过程" class="headerlink" title="消息路由过程"></a>消息路由过程</h3><p>与 ActiveMQ 拿到消息就直接放在队列等待消费者拿走不同， Rabbit 拿到消息之后，会先交给 交换机 （Exchange）, 然后交换机再根据预先设定的不同绑定( Bindings )策略，来确定要发给哪个队列。<br>如图所示，比起 ActiveMQ 多了 Exchange 和 Bindings。<br>正是由于有了    Exchange 和 Bindings， RabbitMQ 就可以灵活地支撑各种模式。<br><img src="RabbitMQ_3.png" alt=""><br>RabbitMQ提供了四种Exchange模式：fanout,direct,topic,header 。 header模式在实际使用中较少，一般不作考虑。</p><h4 id="Fanout-模式"><a href="#Fanout-模式" class="headerlink" title="Fanout 模式"></a>Fanout 模式</h4><p>fanout 模式就是广播模式。消息来了，会发给所有的队列。<br><img src="RabbitMQ_4.png" alt=""></p><h4 id="Direct-模式"><a href="#Direct-模式" class="headerlink" title="Direct 模式"></a>Direct 模式</h4><p>Direct 模式就是指定队列模式，消息来了，只发给指定的 Queue, 其他Queue 都收不到。<br><img src="RabbitMQ_5.png" alt=""></p><h4 id="Topic-模式"><a href="#Topic-模式" class="headerlink" title="Topic 模式"></a>Topic 模式</h4><p>主题模式，注意这里的主题模式，和 ActivityMQ 里的不一样。 ActivityMQ 里的主题，更像是广播模式。<br>那么这里的主题模式是什么意思呢？ 如图所示消息来源有： 美国新闻，美国天气，欧洲新闻，欧洲天气。<br>如果你想看 <font color="#FFFF66">美国</font>主题： 那么就会收到 <font color="#FFFF66">美国</font>新闻，<font color="#FFFF66">美国</font>天气。<br>如果你想看 <font color="#FFFF66">新闻</font>主题： 那么就会收到 <font color="#FFFF66">美国</font>新闻，<font color="#FFFF66">欧洲</font>新闻。<br>如果你想看 <font color="#FFFF66">天气</font>主题： 那么就会收到 <font color="#FFFF66">美国</font>天气，<font color="#FFFF66">欧洲</font>天气。<br>如果你想看 <font color="#FFFF66">欧洲</font>主题： 那么就会收到 <font color="#FFFF66">欧洲</font>新闻，<font color="#FFFF66">欧洲</font>天气。<br><img src="RabbitMQ_6.png" alt=""></p><h3 id="Fanout模式"><a href="#Fanout模式" class="headerlink" title="Fanout模式"></a>Fanout模式</h3><h4 id="pom-中加入依赖"><a href="#pom-中加入依赖" class="headerlink" title="pom 中加入依赖"></a>pom 中加入依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.6.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hutool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hutool-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="判断服务是否启动类"><a href="#判断服务是否启动类" class="headerlink" title="判断服务是否启动类"></a>判断服务是否启动类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.how2j.testrabbitmq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.JOptionPane;</span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.util.NetUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMQUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        checkServer();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(NetUtil.isUsableLocalPort(<span class="number">15672</span>)) &#123;</span><br><span class="line">            JOptionPane.showMessageDialog(<span class="keyword">null</span>, <span class="string">"RabbitMQ 服务器未启动 "</span>);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line"> System.out.println(<span class="string">"服务器已启动"</span>);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="接收消息Customer"><a href="#接收消息Customer" class="headerlink" title="接收消息Customer"></a>接收消息Customer</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.how2j.testrabbitmq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.AMQP;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Consumer;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.DefaultConsumer;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Envelope;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.util.RandomUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanoutCustomer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME=<span class="string">"fanout_exchange"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//为当前消费者取随机名</span></span><br><span class="line">        String name = <span class="string">"consumer-"</span>+ RandomUtil.randomString(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断服务器是否启动</span></span><br><span class="line">        RabbitMQUtil.checkServer();</span><br><span class="line">        <span class="comment">// 创建连接工厂</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">//设置RabbitMQ地址</span></span><br><span class="line">        factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">        <span class="comment">//创建一个新的连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">//创建一个通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//交换机声明（参数为：交换机名称；交换机类型）</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME,<span class="string">"fanout"</span>);</span><br><span class="line">        <span class="comment">//获取一个临时队列</span></span><br><span class="line">        String queueName = channel.queueDeclare().getQueue();</span><br><span class="line">        <span class="comment">//队列与交换机绑定（参数为：队列名称；交换机名称；routingKey忽略）</span></span><br><span class="line">        channel.queueBind(queueName,EXCHANGE_NAME,<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(name +<span class="string">" 等待接受消息"</span>);</span><br><span class="line">        <span class="comment">//DefaultConsumer类实现了Consumer接口，通过传入一个频道，</span></span><br><span class="line">        <span class="comment">// 告诉服务器我们需要那个频道的消息，如果频道中有消息，就会执行回调函数handleDelivery</span></span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span></span></span><br><span class="line"><span class="function">                    <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                String message = <span class="keyword">new</span> String(body, <span class="string">"UTF-8"</span>);</span><br><span class="line">                System.out.println(name + <span class="string">" 接收到消息 '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//自动回复队列应答 -- RabbitMQ中的消息确认机制</span></span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="发送消息Producer"><a href="#发送消息Producer" class="headerlink" title="发送消息Producer"></a>发送消息Producer</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.how2j.testrabbitmq;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消息生成者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanoutProducer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME=<span class="string">"fanout_exchange"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        RabbitMQUtil.checkServer();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建连接工厂</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">//设置RabbitMQ相关信息</span></span><br><span class="line">        factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">        <span class="comment">//创建一个新的连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">//创建一个通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">"fanout"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            String message = <span class="string">"direct 消息 "</span> +i;</span><br><span class="line">            <span class="comment">//发送消息到队列中</span></span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME, <span class="string">""</span>, <span class="keyword">null</span>, message.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">            System.out.println(<span class="string">"发送消息： "</span> + message);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭通道和连接</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="先运行两次-FanoutCustomer-启动两个消费者，再运行一次-FanoutProducer-启动生产者。效果如下："><a href="#先运行两次-FanoutCustomer-启动两个消费者，再运行一次-FanoutProducer-启动生产者。效果如下：" class="headerlink" title="先运行两次 FanoutCustomer 启动两个消费者，再运行一次 FanoutProducer 启动生产者。效果如下："></a>先运行两次 FanoutCustomer 启动两个消费者，再运行一次 FanoutProducer 启动生产者。效果如下：</h4><p><img src="RabbitMQ_7.png" alt=""></p><h3 id="Direct模式"><a href="#Direct模式" class="headerlink" title="Direct模式"></a>Direct模式</h3><h4 id="除了生产者和消费者不同，其余与Fanout一致。"><a href="#除了生产者和消费者不同，其余与Fanout一致。" class="headerlink" title="除了生产者和消费者不同，其余与Fanout一致。"></a>除了生产者和消费者不同，其余与Fanout一致。</h4><h4 id="接收消息Customer-1"><a href="#接收消息Customer-1" class="headerlink" title="接收消息Customer"></a>接收消息Customer</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.how2j.testrabbitmq;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.AMQP;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Consumer;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.DefaultConsumer;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Envelope;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.util.RandomUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectCustomer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"direct_queue"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//为当前消费者取随机名</span></span><br><span class="line">        String name = <span class="string">"consumer-"</span>+ RandomUtil.randomString(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断服务器是否启动</span></span><br><span class="line">        RabbitMQUtil.checkServer();</span><br><span class="line">        <span class="comment">// 创建连接工厂</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">//设置RabbitMQ地址</span></span><br><span class="line">        factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">        <span class="comment">//创建一个新的连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">//创建一个通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//声明要关注的队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line">        System.out.println(name +<span class="string">" 等待接受消息"</span>);</span><br><span class="line">        <span class="comment">//DefaultConsumer类实现了Consumer接口，通过传入一个频道，</span></span><br><span class="line">        <span class="comment">// 告诉服务器我们需要那个频道的消息，如果频道中有消息，就会执行回调函数handleDelivery</span></span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span></span></span><br><span class="line"><span class="function">                    <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                String message = <span class="keyword">new</span> String(body, <span class="string">"UTF-8"</span>);</span><br><span class="line">                System.out.println(name + <span class="string">" 接收到消息 '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//自动回复队列应答 -- RabbitMQ中的消息确认机制</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="发送消息Producer-1"><a href="#发送消息Producer-1" class="headerlink" title="发送消息Producer"></a>发送消息Producer</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.how2j.testrabbitmq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消息生成者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectProducer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME=<span class="string">"direct_queue"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        RabbitMQUtil.checkServer();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建连接工厂</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">//设置RabbitMQ相关信息</span></span><br><span class="line">        factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">        <span class="comment">//创建一个新的连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">//创建一个通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            String message = <span class="string">"direct 消息 "</span> +i;</span><br><span class="line">            <span class="comment">//发送消息到队列中</span></span><br><span class="line">            channel.basicPublish(<span class="string">""</span>, QUEUE_NAME, <span class="keyword">null</span>, message.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">            System.out.println(<span class="string">"发送消息： "</span> + message);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭通道和连接</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h4><p><img src="RabbitMQ_8.png" alt=""></p><h3 id="Topic模式"><a href="#Topic模式" class="headerlink" title="Topic模式"></a>Topic模式</h3><h4 id="除了生产者和消费者不同，其余与Fanout一致。-1"><a href="#除了生产者和消费者不同，其余与Fanout一致。-1" class="headerlink" title="除了生产者和消费者不同，其余与Fanout一致。"></a>除了生产者和消费者不同，其余与Fanout一致。</h4><h4 id="接收消息Customer-2"><a href="#接收消息Customer-2" class="headerlink" title="接收消息Customer"></a>接收消息Customer</h4><h5 id="USA"><a href="#USA" class="headerlink" title="USA"></a>USA</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.how2j.testrabbitmq;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.AMQP;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Consumer;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.DefaultConsumer;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Envelope;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicCustomerUSA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME=<span class="string">"topics_exchange"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//为当前消费者取名称</span></span><br><span class="line">        String name = <span class="string">"consumer-usa"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断服务器是否启动</span></span><br><span class="line">        RabbitMQUtil.checkServer();</span><br><span class="line">        <span class="comment">// 创建连接工厂</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">//设置RabbitMQ地址</span></span><br><span class="line">        factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">        <span class="comment">//创建一个新的连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">//创建一个通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//交换机声明（参数为：交换机名称；交换机类型）</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME,<span class="string">"topic"</span>);</span><br><span class="line">        <span class="comment">//获取一个临时队列</span></span><br><span class="line">        String queueName = channel.queueDeclare().getQueue();</span><br><span class="line">        <span class="comment">//接受 USA 信息</span></span><br><span class="line"></span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">"usa.*"</span>);</span><br><span class="line">        System.out.println(name +<span class="string">" 等待接受消息"</span>);</span><br><span class="line">        <span class="comment">//DefaultConsumer类实现了Consumer接口，通过传入一个频道，</span></span><br><span class="line">        <span class="comment">// 告诉服务器我们需要那个频道的消息，如果频道中有消息，就会执行回调函数handleDelivery</span></span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span></span></span><br><span class="line"><span class="function">                    <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                String message = <span class="keyword">new</span> String(body, <span class="string">"UTF-8"</span>);</span><br><span class="line">                System.out.println(name + <span class="string">" 接收到消息 '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//自动回复队列应答 -- RabbitMQ中的消息确认机制</span></span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="News"><a href="#News" class="headerlink" title="News"></a>News</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.how2j.testrabbitmq;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.AMQP;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Consumer;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.DefaultConsumer;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Envelope;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicCustomerNews</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME=<span class="string">"topics_exchange"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//为当前消费者取名称</span></span><br><span class="line">        String name = <span class="string">"consumer-news"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断服务器是否启动</span></span><br><span class="line">        RabbitMQUtil.checkServer();</span><br><span class="line">        <span class="comment">// 创建连接工厂</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">//设置RabbitMQ地址</span></span><br><span class="line">        factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">        <span class="comment">//创建一个新的连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">//创建一个通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//交换机声明（参数为：交换机名称；交换机类型）</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME,<span class="string">"topic"</span>);</span><br><span class="line">        <span class="comment">//获取一个临时队列</span></span><br><span class="line">        String queueName = channel.queueDeclare().getQueue();</span><br><span class="line">        <span class="comment">//接受 USA 信息</span></span><br><span class="line"></span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">"*.news"</span>);</span><br><span class="line">        System.out.println(name +<span class="string">" 等待接受消息"</span>);</span><br><span class="line">        <span class="comment">//DefaultConsumer类实现了Consumer接口，通过传入一个频道，</span></span><br><span class="line">        <span class="comment">// 告诉服务器我们需要那个频道的消息，如果频道中有消息，就会执行回调函数handleDelivery</span></span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span></span></span><br><span class="line"><span class="function">                    <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                String message = <span class="keyword">new</span> String(body, <span class="string">"UTF-8"</span>);</span><br><span class="line">                System.out.println(name + <span class="string">" 接收到消息 '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//自动回复队列应答 -- RabbitMQ中的消息确认机制</span></span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="发送消息Producer-2"><a href="#发送消息Producer-2" class="headerlink" title="发送消息Producer"></a>发送消息Producer</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.how2j.testrabbitmq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消息生成者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicProducer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME=<span class="string">"topics_exchange"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        RabbitMQUtil.checkServer();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建连接工厂</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">//设置RabbitMQ相关信息</span></span><br><span class="line">        factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">        <span class="comment">//创建一个新的连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">//创建一个通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">"topic"</span>);</span><br><span class="line"></span><br><span class="line">        String[] routing_keys = <span class="keyword">new</span> String[] &#123; <span class="string">"usa.news"</span>, <span class="string">"usa.weather"</span>,</span><br><span class="line">                <span class="string">"europe.news"</span>, <span class="string">"europe.weather"</span> &#125;;</span><br><span class="line">        String[] messages = <span class="keyword">new</span> String[] &#123; <span class="string">"美国新闻"</span>, <span class="string">"美国天气"</span>,</span><br><span class="line">                <span class="string">"欧洲新闻"</span>, <span class="string">"欧洲天气"</span> &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; routing_keys.length; i++) &#123;</span><br><span class="line">            String routingKey = routing_keys[i];</span><br><span class="line">            String message = messages[i];</span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME, routingKey, <span class="keyword">null</span>, message</span><br><span class="line">                    .getBytes());</span><br><span class="line">            System.out.printf(<span class="string">"发送消息到路由：%s, 内容是: %s%n "</span>, routingKey,message);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭通道和连接</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="效果-1"><a href="#效果-1" class="headerlink" title="效果"></a>效果</h4><p><img src="RabbitMQ_9.png" alt=""></p><p>Demo代码可以 Email 联系我。</p>]]></content>
      
      
      <categories>
          
          <category> Basic Component </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
            <tag> MessageQueue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2PC And 3PC</title>
      <link href="/2019/11/03/2PC-And-3PC/"/>
      <url>/2019/11/03/2PC-And-3PC/</url>
      
        <content type="html"><![CDATA[<h2 id="2PC——二阶段提交"><a href="#2PC——二阶段提交" class="headerlink" title="2PC——二阶段提交"></a>2PC——二阶段提交</h2><blockquote><p>分布式数据要尽可能保证一致性，2PC即二阶段提交就是保证数据一致性的一种手段。</p></blockquote><p>在分布式系统中，每个节点虽然可以知晓自己的操作时成功或者失败，却无法知道其他节点的操作的成功或失败。<br>当一个事务跨越多个节点时，为了保持事务的ACID特性，需要引入一个作为协调者的组件来统一掌控所有参与者的操作结果并最终指示这些节点是否要把操作结果进行真正的提交。<br>因此，二阶段提交的算法思路可以概括为：参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作。</p><p>所谓的两个阶段是指：第一阶段：准备阶段和第二阶段：提交阶段</p><h3 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h3><p>事务协调者给每个参与者发送Prepare消息，每个参与者要么直接返回失败，要么在本地执行事务，但不提交。<br>可以进一步将准备阶段分为以下三个步骤：</p><ul><li>1）协调者节点向所有参与者节点询问是否可以执行提交操作，并开始等待各参与者节点的响应。</li><li>2）参与者节点执行询问发起为止的所有事务操作，并将Undo信息和Redo信息写入日志。</li><li>3）各参与者节点响应协调者节点发起的询问。如果参与者节点的事务操作实际执行成功，则它返回一个”同意”消息；如果参与者节点的事务操作实际执行失败，则它返回一个”中止”消息。</li></ul><p><img src="2PC%E4%B8%8E3PC_1.png" alt=""></p><h3 id="提交阶段"><a href="#提交阶段" class="headerlink" title="提交阶段"></a>提交阶段</h3><p>如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚消息；否则，发送提交消息；参与者根据协调者的指令执行提交或者回滚操作。<br>接下来分两种情况分别讨论提交阶段的过程。</p><ul><li>1）当协调者节点从所有参与者节点获得的相应消息都为”同意”时:</li></ul><p><img src="2PC%E4%B8%8E3PC_2.png" alt=""></p><ol><li>协调者节点向所有参与者节点发出”正式提交”的请求。</li><li>参与者节点正式完成操作，并释放在整个事务期间内占用的资源。</li><li>参与者节点向协调者节点发送”完成”消息</li><li>协调者节点受到所有参与者节点反馈的”完成”消息后，完成事务。</li></ol><ul><li>2）如果任一参与者节点在第一阶段返回的响应消息为”中止”，或者 协调者节点在第一阶段的询问超时之前无法获取所有参与者节点的响应消息时：</li></ul><p><img src="2PC%E4%B8%8E3PC_3.png" alt=""></p><ol><li>协调者节点向所有参与者节点发出”回滚操作”的请求。</li><li>参与者节点利用之前写入的Undo信息执行回滚，并释放在整个事务期间内占用的资源。</li><li>参与者节点向协调者节点发送”回滚完成”消息。</li><li>协调者节点受到所有参与者节点反馈的”回滚完成”消息后，取消事务。</li></ol><h3 id="2PC-的缺点"><a href="#2PC-的缺点" class="headerlink" title="2PC 的缺点"></a>2PC 的缺点</h3><ol><li>同步阻塞问题。执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。（当参与者收到组织者的消息之后，需要登录游戏，在游戏中等待组织者的再次邀请，这个过程比较浪费时间。）</li><li>单点故障。由于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去。尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。（如果是协调者挂掉，可以重新选举一个协调者，但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题）</li><li>数据不一致。在二阶段提交的阶段二中，当协调者向参与者发送commit请求之后，发生了局部网络异常或者在发送commit请求过程中协调者发生了故障，这回导致只有一部分参与者接受到了commit请求。而在这部分参与者接到commit请求之后就会执行commit操作。但是其他部分未接到commit请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据部一致性的现象。</li><li>二阶段无法解决的问题：协调者再发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。</li></ol><p>为了解决以上缺点就有了3PC</p><h2 id="3PC——三阶段提交"><a href="#3PC——三阶段提交" class="headerlink" title="3PC——三阶段提交"></a>3PC——三阶段提交</h2><blockquote><p>所谓3PC，就是把2PC的准备阶段再次一分为二，组成了三阶段。<br>3PC并没彻底解决2PC存在的所有问题</p></blockquote><details><summary> 2PC举例 </summary>组织者：小A，我们准备玩王者荣耀，你要是可以来参加的话，现在你就登录游戏，然后在游戏好友上给我回复个消息。<p>小A登录自己的游戏账号，然后告诉组织者：小A已就位。</p><p>组织者：小B、小C、小D，我们准备玩王者荣耀，你要是可以来参加的话，现在你就登录游戏，然后在游戏好友上给我回复个消息。</p><p>小B、小C、小D分别登录自己的游戏账号，然后告诉组织者：小B、小C、小D已就位。</p><p>组织者发现所有人都就位了，于是在游戏上逐一通知大家，</p><p>组织者：小A，我邀请你了，你进来吧。</p><p>小A接受邀请</p><p>组织者：小B、小C、小D，我邀请你了，你进来吧。</p><p>小小B、小C、小D接收邀请</p></details><details><summary> 3PC举例 </summary>组织者：小A，我们想定在晚上8点，你有时间嘛？有时间你就说YES，没有你就说NO，然后我还会再去问其他人，这段时间你可先去干你自己的事儿，不用一直等着我。<p>小A：好的，我有时间。</p><p>组织者：小B、小C、小D，我们想定在晚上8点王者荣耀五黑……不用一直等我。</p><p>组织者收集完大家的时间情况了，一看大家都有时间，那么就再次通知大家。（协调者接收到所有YES指令）</p><p>组织者：小A，我们确定了晚上8点王者荣耀五黑，你要把段时间空出来，你不能再安排其他的事儿了。然后我会逐个通知其他朋友，通知完之后我会再来和你确认一下，还有啊，如果我没有特意给你打电话，你就8点上号就行了。对了，你确定能来是吧？</p><p>小A顺手设置了晚上8点闹钟，然后跟组织者说，我可以去。</p><p>组织者：小B，我们决定了晚上8点王者荣耀五黑……你就8点上号就行了。</p><p>组织者通知完一圈之后。所有朋友都跟他说：”我已经把8点这个时间段空出来了”。于是，他在8点的时候这一天又挨个打了一遍电话告诉他们：嘿，现在你们可以上号啦。。。。</p><p>小A、小B、小C、小D：我已经登录了，你拉我吧。</p><p>组织者邀请A、B、C等加入游戏。</p></details><p>和2PC相比，3PC多了一个步骤，就是提前询问所以参与者是否都能参与，并且所有人都同意后再次通知大家登录游戏。</p><p>在第一阶段，只是询问所有参与者是否可以执行事务操作，并不在本阶段执行事务操作。当协调者收到所有的参与者都返回YES时，在第二阶段才执行事务操作，然后在第三阶段在执行commit或者rollback。</p><p>这样三阶段提交就有CanCommit（事务询问）、PreCommit（事务执行）、DoCommit（事务提交）三个阶段。</p><h3 id="CanCommit阶段"><a href="#CanCommit阶段" class="headerlink" title="CanCommit阶段"></a>CanCommit阶段</h3><p>3PC的CanCommit阶段其实和2PC的准备阶段很像。协调者向参与者发送commit请求，参与者如果可以提交就返回Yes响应，否则返回No响应。</p><p><img src="2PC%E4%B8%8E3PC_4.png" alt=""><br>1、事务询问：协调者向参与者发送CanCommit请求。询问是否可以执行事务提交操作。然后开始等待参与者的响应。</p><p>2、响应反馈：参与者接到CanCommit请求之后，正常情况下，如果其自身认为可以顺利执行事务，则返回YES响应，并进入预备状态。否则反馈NO</p><h3 id="PreCommit阶段"><a href="#PreCommit阶段" class="headerlink" title="PreCommit阶段"></a>PreCommit阶段</h3><p>协调者根据CanCommit阶段参与者的反应情况来决定是否可以进行事务的PreCommit操作。<br>假如协调者从所有的参与者获得的反馈都是YES响应，那么就会执行事务的预执行：</p><p><img src="2PC%E4%B8%8E3PC_5.png" alt=""><br>1、发送预提交请求：协调者向参与者发送PreCommit请求，并进入Prepared阶段。</p><p>2、事务预提交：参与者接收到PreCommit请求后，会执行事务操作，并将undo和redo信息记录到事务日志中。</p><p>3、响应反馈：如果参与者成功的执行了事务操作，则返回ACK响应，同时开始等待最终指令。</p><p>假如有任何一个参与者向协调者发送了NO响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断。</p><p><img src="2PC%E4%B8%8E3PC_6.png" alt=""><br>1、发送中断请求：协调者向所有参与者发送abort请求。</p><p>2、中断事务：参与者收到来自协调者的abort请求之后（或超时之后，仍未收到协调者的请求），执行事务的中断。</p><h3 id="doCommit阶段"><a href="#doCommit阶段" class="headerlink" title="doCommit阶段"></a>doCommit阶段</h3><p>该阶段进行真正的事务提交，也可以分为以下两种情况。<br>如果协调证收到所有参与者的事务执行后的ACK响应，则发生如下事情：</p><p><img src="2PC%E4%B8%8E3PC_7.png" alt=""><br>1、发送提交请求：协调接收到参与者发送的ACK响应，那么他将从预提交状态进入到提交状态。并向所有参与者发送doCommit请求。</p><p>2、事务提交：参与者接收到doCommit请求之后，执行正式的事务提交。并在完成事务提交之后释放所有事务资源。</p><p>3、响应反馈：事务提交完之后，向协调者发送Ack响应。</p><p>4、完成事务：协调者接收到所有参与者的ack响应之后，完成事务。</p><p>如果协调者没有接收到参与者发送的ACK响应（可能是接受者发送的不是ACK响应，也可能响应超时），那么就会执行中断事务。</p><p><img src="2PC%E4%B8%8E3PC_8.png" alt=""><br>1、发送中断请求：协调者向所有参与者发送abort请求</p><p>2、事务回滚：参与者接收到abort请求之后，利用其在阶段二记录的undo信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源。</p><p>3、反馈结果：参与者完成事务回滚之后，向协调者发送ACK消息</p><p>4、中断事务：协调者接收到参与者反馈的ACK消息之后，执行事务的中断。</p><p>还有一种情况，如果参与者无法及时接收到来自协调者的doCommit或者abort请求时，会在等待超时之后，会继续进行事务的提交。</p><p><img src="2PC%E4%B8%8E3PC_9.png" alt=""></p><h2 id="3PC比2PC好在哪？"><a href="#3PC比2PC好在哪？" class="headerlink" title="3PC比2PC好在哪？"></a>3PC比2PC好在哪？</h2><h3 id="降低同步阻塞"><a href="#降低同步阻塞" class="headerlink" title="降低同步阻塞"></a>降低同步阻塞</h3><p>在3PC中，第一阶段并没有让参与者直接执行事务，而是在第二阶段才会让参与者进行事务的执行。大大降低了阻塞的概率和时长。并且，在3PC中，如果参与者未收到协调者的消息，那么他会在等待一段时间后自动执行事务的commit，而不是一直阻塞。</p><h3 id="提升了数据一致性"><a href="#提升了数据一致性" class="headerlink" title="提升了数据一致性"></a>提升了数据一致性</h3><p>2PC中有一种情况会导致数据不一致，如在2PC的阶段二中，当协调者向参与者发送commit请求之后，发生了网络异常，只有一部分参与者接受到了commit请求。而在这部分参与者接到commit请求之后就会执行commit操作。但是其他部分未接到commit请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据不一致性的现象。</p><p>这种情况在3PC的场景中得到了很好的解决，因为在3PC中，如果参与者没有收到协调者的消息时，他不会一直阻塞，过一段时间之后，他会自动执行事务。这就解决了那种协调者发出commit之后。</p><p>另外，2PC还有个问题无法解决。那就是协调者再发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。</p><p>这种情况在3PC中是有办法解决的，因为在3PC中，选出新的协调者之后，他可以咨询所有参与者的状态，如果有某一个处于commit状态或者prepare-commit状态，那么他就可以通知所有参与者执行commit，否则就通知大家rollback。因为3PC的第三阶段一旦有机器执行了commit，那必然第一阶段大家都是同意commit的，所以可以放心执行commit。</p><h2 id="3PC无法解决的问题"><a href="#3PC无法解决的问题" class="headerlink" title="3PC无法解决的问题"></a>3PC无法解决的问题</h2><p>在doCommit阶段，如果参与者无法及时接收到来自协调者的doCommit或者abort请求时，会在等待超时之后，会继续进行事务的提交。</p><p>所以，由于网络原因，协调者发送的abort响应没有及时被参与者接收到，那么参与者在等待超时之后执行了commit操作。这样就和其他接到abort命令并执行回滚的参与者之间存在数据不一致的情况。</p><p>所以，我们可以认为，无论是二阶段提交还是三阶段提交都无法彻底解决分布式的一致性问题。</p><p>Google Chubby的作者Mike Burrows说过：</p><p>there is only one consensus protocol, and that’s Paxos” – all other approaches are just broken versions of Paxos。</p><p>意即世上只有一种一致性算法，那就是Paxos，所有其他一致性算法都是Paxos算法的不完整版。</p>]]></content>
      
      
      <categories>
          
          <category> Internet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2PC </tag>
            
            <tag> 3PC </tag>
            
            <tag> transaction </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx Error</title>
      <link href="/2019/10/29/Nginx-Error/"/>
      <url>/2019/10/29/Nginx-Error/</url>
      
        <content type="html"><![CDATA[<h2 id="502报错"><a href="#502报错" class="headerlink" title="502报错"></a>502报错</h2><h3 id="FastCGI相关"><a href="#FastCGI相关" class="headerlink" title="FastCGI相关"></a>FastCGI相关</h3><ol><li>FastCGI进程是否已经启动</li><li>FastCGI worker进程数是否不够</li><li>FastCGI执行时间过长</li><li>FastCGI Buffer不够<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nginx和apache一样，有前端缓冲限制，可以调整缓冲参数</span><br><span class="line">fastcgi_buffer_size 32k;</span><br><span class="line">fastcgi_buffers 8 32k;</span><br></pre></td></tr></table></figure><h3 id="Proxy-Buffer不够"><a href="#Proxy-Buffer不够" class="headerlink" title="Proxy Buffer不够"></a>Proxy Buffer不够</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果你用了Proxying，调整</span><br><span class="line">proxy_buffer_size 16k;</span><br><span class="line">proxy_buffers 4 16k;</span><br></pre></td></tr></table></figure><h3 id="php脚本执行时间过长"><a href="#php脚本执行时间过长" class="headerlink" title="php脚本执行时间过长"></a>php脚本执行时间过长</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">将php-fpm.conf的</span><br><span class="line">&lt;value name&#x3D;&quot;request_terminate_timeout&quot;&gt;0s&lt;&#x2F;value&gt;</span><br><span class="line">0s改成一个时间</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Basic Component </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx Optimization</title>
      <link href="/2019/10/20/Nginx-Optimization/"/>
      <url>/2019/10/20/Nginx-Optimization/</url>
      
        <content type="html"><![CDATA[<h4 id="调整-worker-processes"><a href="#调整-worker-processes" class="headerlink" title="调整 worker_processes"></a>调整 worker_processes</h4><p>指Nginx要生成的worker数量，最佳实践是每个CPU运行1个工作进程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 了解系统中的CPU核心数，输入：</span><br><span class="line">$ grep processor &#x2F; proc &#x2F; cpuinfo | wc -l</span><br></pre></td></tr></table></figure><h4 id="最大化worker-connections"><a href="#最大化worker-connections" class="headerlink" title="最大化worker_connections"></a>最大化worker_connections</h4><p>Nginx Web服务器可以同时提供服务的客户端数。与worker_processes结合使用时，获得每秒可以服务的最大客户端数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">单个进程的连接数（文件描述符 fd）</span><br><span class="line">最大客户端数&#x2F;秒&#x3D;工作进程*工作者连接数</span><br><span class="line">为了最大化Nginx的全部潜力，应将工作者连接设置为核心一次可以运行的允许的最大进程数1024。</span><br><span class="line">上面是 Nginx 作为通用服务器时，最大的连接数。</span><br><span class="line">Nginx 作为反向代理服务器时，能够服务的最大连接数要除以2</span><br><span class="line">因为 Nginx 反向代理时，会建立 Client 的连接和后端 Web Server 的连接，占用 2 个连接</span><br></pre></td></tr></table></figure><h4 id="启用Gzip文件压缩"><a href="#启用Gzip文件压缩" class="headerlink" title="启用Gzip文件压缩"></a>启用Gzip文件压缩</h4><p>如果我们租用了一个带宽很低的服务器，网站访问速度会很慢，这时我们可以通过让nginx开启GZIP压缩来提高网站的访问速度。（压缩文件大小，减少了客户端http的传输带宽，因此提高了页面加载速度）</p><ul><li>首先我们对nginx进行限速操作，限制每个连接的访问速度为128K来建立一个比较慢的访问场景；</li><li>修改mall.conf配置文件，进行限速操作：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  mall.macrozheng.com;</span><br><span class="line">    limit_rate 128k; #限制网速为128K</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        root   &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;mall;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error_page   500 502 503 504  &#x2F;50x.html;</span><br><span class="line">    location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">        root   &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>对mall的前端项目mall.macrozheng.com进行访问，我们可以发现网站中有个js文件比较大，需要加载12s<br><img src="Nginx_3.png" alt=""></li><li>nginx返回请求头信息如下：<br><img src="Nginx_4.png" alt=""></li><li>修改/mydata/nginx/conf目录下的nginx.conf配置文件，开启GZIP压缩<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    gzip on; #开启gzip</span><br><span class="line">    gzip_disable &quot;msie6&quot;; #IE6不使用gzip</span><br><span class="line">    gzip_vary on; #设置为on会在Header里增加 &quot;Vary: Accept-Encoding&quot;</span><br><span class="line">    gzip_proxied any; #代理结果数据的压缩</span><br><span class="line">    gzip_comp_level 6; #gzip压缩比（1~9），越小压缩效果越差，但是越大处理越慢，所以一般取中间值</span><br><span class="line">    gzip_buffers 16 8k; #获取多少内存用于缓存压缩结果</span><br><span class="line">    gzip_http_version 1.1; #识别http协议的版本</span><br><span class="line">    gzip_min_length 1k; #设置允许压缩的页面最小字节数，超过1k的文件会被压缩</span><br><span class="line">    gzip_types application&#x2F;javascript text&#x2F;css text&#x2F;plain application&#x2F;json; #对特定的MIME类型生效,js和css文件会被压缩</span><br><span class="line"></span><br><span class="line">    include &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;*.conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>再次对mall的前端项目mall.macrozheng.com进行访问，我们可以发现js文件已经被压缩，加载时间缩短到3.88s，提速3倍左右<br><img src="Nginx_5.png" alt=""></li><li>nginx返回请求头中添加了Content-Encoding: gzip的信息<br><img src="Nginx_6.png" alt=""><h4 id="为静态文件启用缓存"><a href="#为静态文件启用缓存" class="headerlink" title="为静态文件启用缓存"></a>为静态文件启用缓存</h4>为静态文件启用缓存，以减少带宽并提高性能，可以添加下面的命令，限定计算机缓存网页的静态文件：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">location ~* .(jpg|jpeg|png|gif|ico|css|js)$ &#123;</span><br><span class="line">expires 365d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ~* .(jpg|jpeg|png|gif|ico|css|js)$ &#123;</span><br><span class="line">add_header Cache-Control no-cache;</span><br><span class="line">add_header Cache-Control private; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Timeouts"><a href="#Timeouts" class="headerlink" title="Timeouts"></a>Timeouts</h4>keepalive连接减少了打开和关闭连接所需的CPU和网络开销，获得最佳性能需要调整的变量可参考：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">client_body_timeout 12;</span><br><span class="line">client_header_timeout 12;</span><br><span class="line">keepalive_timeout 15;</span><br><span class="line">send_timeout 10;</span><br></pre></td></tr></table></figure><h4 id="禁用access-logs"><a href="#禁用access-logs" class="headerlink" title="禁用access_logs"></a>禁用access_logs</h4><blockquote><p>访问日志记录，它记录每个nginx请求，因此消耗了大量CPU资源，从而降低了nginx性能。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 完全禁用访问日志记录</span><br><span class="line">access_log off;</span><br><span class="line"></span><br><span class="line"># 如果必须具有访问日志记录，则启用访问日志缓冲</span><br><span class="line">access_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Basic Component </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx Syntax</title>
      <link href="/2019/10/09/Nginx-Syntax/"/>
      <url>/2019/10/09/Nginx-Syntax/</url>
      
        <content type="html"><![CDATA[<h2 id="Location语法规则"><a href="#Location语法规则" class="headerlink" title="Location语法规则"></a>Location语法规则</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location [ &#x3D; | ~ | ~* | ^~ ] uri &#123; ... &#125;</span><br><span class="line">location @name &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">&#x3D; 表示精确匹配。只有请求的url路径与后面的字符串完全相等时，才会命中。</span><br><span class="line">~ 表示该规则是使用正则定义的，区分大小写。</span><br><span class="line">~* 表示该规则是使用正则定义的，不区分大小写。</span><br><span class="line">^~ 表示如果该符号后面的字符是最佳匹配，采用该规则，不再进行后续的查找。</span><br></pre></td></tr></table></figure><h2 id="if-判断规则"><a href="#if-判断规则" class="headerlink" title="if 判断规则"></a>if 判断规则</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1、正则表达式匹配：</span><br><span class="line">&#x3D;&#x3D;:等值比较;</span><br><span class="line">~：与指定正则表达式模式匹配时返回“真”，判断匹配与否时区分字符大小写；</span><br><span class="line">~*：与指定正则表达式模式匹配时返回“真”，判断匹配与否时不区分字符大小写；</span><br><span class="line">!~：与指定正则表达式模式不匹配时返回“真”，判断匹配与否时区分字符大小写；</span><br><span class="line">!~*：与指定正则表达式模式不匹配时返回“真”，判断匹配与否时不区分字符大小写；</span><br><span class="line"></span><br><span class="line">2、文件及目录匹配判断：</span><br><span class="line">-f, !-f：判断指定的路径是否为存在且为文件；</span><br><span class="line">-d, !-d：判断指定的路径是否为存在且为目录；</span><br><span class="line">-e, !-e：判断指定的路径是否存在，文件或目录均可；</span><br><span class="line">-x, !-x：判断指定路径的文件是否存在且可执行；</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Basic Component </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>What Can Nginx Do and How to Use Nginx</title>
      <link href="/2019/10/05/What-Can-Nginx-Do-and-How-to-Use-Nginx/"/>
      <url>/2019/10/05/What-Can-Nginx-Do-and-How-to-Use-Nginx/</url>
      
        <content type="html"><![CDATA[<h3 id="正向代理服务器"><a href="#正向代理服务器" class="headerlink" title="正向代理服务器"></a>正向代理服务器</h3><p>被代理角色通过代理访问目标角色完成一些任务的过程称为代理操作过程。</p><blockquote><p>正向代理最大的特点是客户端非常明确要访问的服务器地址；服务器只清楚请求来自哪个代理服务器，而不清楚来自哪个具体的客户端；正向代理模式屏蔽或者隐藏了真实客户端信息。</p></blockquote><h4 id="正向代理的作用"><a href="#正向代理的作用" class="headerlink" title="正向代理的作用"></a>正向代理的作用</h4><p>（1）访问原来无法访问的资源，如Google，或者局域网中的客户端不能直接访问Internet，则需要通过代理服务器来访问<br>（2）可以做缓存，加速访问资源<br>（3）对客户端访问授权，上网进行认证<br>（4）代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息</p><h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># 代理 http</span><br><span class="line">server &#123;</span><br><span class="line">  resolver 192.168.34.3; # 指定DNS服务器IP地址</span><br><span class="line">  listen 2020; # 供请求代理的客户端访问的端口</span><br><span class="line">  location &#x2F; &#123;</span><br><span class="line">    proxy_pass http:&#x2F;&#x2F;$http_host$request_uri; # 设定代理服务器的协议和地址</span><br><span class="line">    proxy_set_header HOST $http_host;</span><br><span class="line">    proxy_buffers 256 4k;</span><br><span class="line">    proxy_max_temp_file_size 0k;</span><br><span class="line">    proxy_connect_timeout 30;</span><br><span class="line">    proxy_send_timeout 60;</span><br><span class="line">    proxy_read_timeout 60;</span><br><span class="line">    proxy_next_upstream error timeout invalid_header http_502;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 代理 https</span><br><span class="line">server &#123;</span><br><span class="line">  resolver 192.168.34.3; # 指定DNS服务器IP地址务器IP地址</span><br><span class="line">  listen 2021; # 供请求代理的客户端访问的端口</span><br><span class="line">  location &#x2F; &#123;</span><br><span class="line">    proxy_pass https:&#x2F;&#x2F;$http_host$request_uri; #设定代理服务器的协议和地址</span><br><span class="line">    proxy_set_header HOST $http_host;</span><br><span class="line">    proxy_buffers 256 4k;</span><br><span class="line">    proxy_max_temp_file_size 0k;</span><br><span class="line">    proxy_connect_timeout 30;</span><br><span class="line">    proxy_send_timeout 60;</span><br><span class="line">    proxy_read_timeout 60;</span><br><span class="line">    proxy_next_upstream error timeout invalid_header http_502;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 访问 http</span><br><span class="line">curl -l --proxy 192.168.43.144:2020 http:&#x2F;&#x2F;www.baidu.com</span><br><span class="line"></span><br><span class="line"># 访问 https</span><br><span class="line">curl -l --proxy 192.168.43.144:2021 http:&#x2F;&#x2F;www.baidu.com</span><br><span class="line"></span><br><span class="line"># 甚至还可以在服务器上请求nginx正向代理 本服务器上被nginx反向代理的服务</span><br><span class="line">curl -l --proxy 192.168.43.144:2020 192.168.43.144:10003&#x2F;console&#x2F;service&#x2F;1&#x2F;1&#x2F;get-sys-param-info</span><br><span class="line">curl -l --proxy 192.168.43.144:2021 192.168.43.144:10010&#x2F;console&#x2F;service&#x2F;1&#x2F;1&#x2F;get-sys-param-info</span><br></pre></td></tr></table></figure><h3 id="反向代理服务器"><a href="#反向代理服务器" class="headerlink" title="反向代理服务器"></a>反向代理服务器</h3><blockquote><p>反向代理就是当请求访问你的代理服务器时，代理服务器会对你的请求进行转发，可以转发到静态的资源路径上去，也可以转发到动态的服务接口上去。<br><a href="http://tengine.taobao.org/" target="_blank" rel="noopener">淘宝基于nginx改进的tengine</a></p></blockquote><h4 id="反向代理的作用"><a href="#反向代理的作用" class="headerlink" title="反向代理的作用"></a>反向代理的作用</h4><p>（1）保证内网的安全，通常将反向代理作为公网访问地址，Web服务器是内网。<br>（2）负载均衡，通过反向代理服务器来优化网站的负载。</p><h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><blockquote><p>将服务器接收到的请求按照规则分发的过程，称为负载均衡。</p></blockquote><h5 id="使用示例-1"><a href="#使用示例-1" class="headerlink" title="使用示例"></a>使用示例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">首先在http下增加一个upstream ，用来指向各个服务器节点</span><br><span class="line">    upstream weixin_8111_8222&#123;</span><br><span class="line">          server127.0.0.1:8111 weight&#x3D;1;</span><br><span class="line">          serverxxxxxxxxx:8222 weight&#x3D;2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">然后修改：</span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            proxy_pass http:&#x2F;&#x2F;weixin_8111_8222;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h5 id="Nginx支持的负载均衡调度算法"><a href="#Nginx支持的负载均衡调度算法" class="headerlink" title="Nginx支持的负载均衡调度算法"></a>Nginx支持的负载均衡调度算法</h5><ol><li>weight轮询(默认)：接收到的请求按照顺序逐一分配到不同的后端服务器，即使在使用过程中，某一台后端服务器宕机，Nginx会自动将该服务器剔除出队列，请求受理情况不会受到任何影响。这种方式下，可以给不同的后端服务器设置一个权重值(weight)，用于调整不同的服务器上请求的分配率；权重数据越大，被分配到请求的几率越大；该权重值，主要是针对实际工作环境中不同的后端服务器硬件配置进行调整的。</li><li>ip_hash：每个请求按照发起客户端的ip的hash结果进行匹配，这样的算法下一个固定ip地址的客户端总会访问到同一个后端服务器，这也在一定程度上解决了集群部署环境下session共享的问题。</li><li>fair：智能调整调度算法，动态的根据后端服务器的请求处理到响应的时间进行均衡分配，响应时间短处理效率高的服务器分配到请求的概率高，响应时间长处理效率低的服务器分配到的请求少；结合了前两者的优点的一种调度算法。但是需要注意的是Nginx默认不支持fair算法，如果要使用这种调度算法，请安装upstream_fair模块。</li><li>url_hash：按照访问的url的hash结果分配请求，每个请求的url会指向后端固定的某个服务器，可以在Nginx作为静态服务器的情况下提高缓存效率。同样要注意Nginx默认不支持这种调度算法，要使用的话需要安装Nginx的hash软件包。</li></ol><h5 id="session-问题"><a href="#session-问题" class="headerlink" title="session 问题"></a>session 问题</h5><p>通过负载均衡课程，我们可以把请求分发到不同的 Tomcat 来缓解服务器的压力，但是这里存在一个问题： 当同一个用户第一次访问tomcat_8111 并且登录成功， 而第二次访问却被分配到了tomcat_8222， 这里并没有记录他的登陆状态，那么就会呈现未登录状态了，严重伤害了用户体验。</p><ol><li>解决办法一: ip_hash<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 通过ip地址标记用户，如果多次请求都是从同一个ip来的，那么就都分配到同一个tomcat</span><br><span class="line">upstream weixin_8111_8222&#123;</span><br><span class="line">        server127.0.0.1:8111 backup;   # backup是指主节点全部宕机了才启用此节点</span><br><span class="line">        serverxxxxxxxxx:8222 weight&#x3D;2;</span><br><span class="line">        ip_hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>解决办法二： redis+tomcat-sessoin-manager<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Tomcat需要链接 redis，所以需要专门的jar包，一共有3个jar包：</span><br><span class="line">jedis-2.5.2.jar，</span><br><span class="line">commons-pool2-2.0.jar，</span><br><span class="line">tomcat-redis-session-manager1.2.jar。</span><br><span class="line">然后修改tomcat&#x2F;conf&#x2F;context.xml ，增加下面这坨东西</span><br><span class="line"></span><br><span class="line">&lt;Valve className&#x3D;&quot;com.orangefunction.tomcat.redissessions.RedisSessionHandlerValve&quot; &#x2F;&gt;</span><br><span class="line">&lt;Manager className&#x3D;&quot;com.orangefunction.tomcat.redissessions.RedisSessionManager&quot;</span><br><span class="line"> host&#x3D;&quot;127.0.0.1&quot;</span><br><span class="line"> port&#x3D;&quot;6379&quot;</span><br><span class="line"> database&#x3D;&quot;0&quot;</span><br><span class="line"> maxInactiveInterval&#x3D;&quot;60&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"># 1. 首先修改下本机的host文件，例如：</span><br><span class="line">192.168.6.132 docs.macrozheng.com</span><br><span class="line">192.168.6.132 mall.macrozheng.com</span><br><span class="line"></span><br><span class="line"># 2. 在&#x2F;mydata&#x2F;nginx&#x2F;conf&#x2F;conf.d文件夹中添加配置文件docs.conf对文档项目进行反向代理：</span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  docs.macrozheng.com; #修改域名</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        root   &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;docs; #代理到docs文件夹中</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error_page   500 502 503 504  &#x2F;50x.html;</span><br><span class="line">    location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">        root   &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 3. 在&#x2F;mydata&#x2F;nginx&#x2F;conf&#x2F;conf.d文件夹中添加配置文件mall.conf对mall的前端项目进行反向代理：</span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  mall.macrozheng.com; #修改域名</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        root   &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;mall; #代理到mall文件夹中</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error_page   500 502 503 504  &#x2F;50x.html;</span><br><span class="line">    location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">        root   &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 重启nginx服务：</span><br><span class="line">docker restart nginx</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 一个server代理多个url</span><br><span class="line"></span><br><span class="line">location &#x2F; &#123;</span><br><span class="line">  root  &#x2F;home&#x2F;wwwroot&#x2F;graduation;</span><br><span class="line">  index index.html;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location &#x2F;mikutap &#123;</span><br><span class="line">  alias  &#x2F;home&#x2F;wwwroot&#x2F;mikutap&#x2F;;</span><br><span class="line">  index index.html;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location &#x2F;rpremoval &#123;</span><br><span class="line">  alias  &#x2F;home&#x2F;wwwroot&#x2F;realtime-person-removal&#x2F;;</span><br><span class="line">  index index.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 1. 首先修改下本机的host文件，例如：</span><br><span class="line">192.168.6.132 api.macrozheng.com</span><br><span class="line"></span><br><span class="line"># 2. 在&#x2F;mydata&#x2F;nginx&#x2F;conf&#x2F;conf.d文件夹中添加配置文件api.conf对将请求代理到远程的mall-admin服务上去：</span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  api.macrozheng.com; #修改域名</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">    proxy_pass   http:&#x2F;&#x2F;120.27.63.9:8080; #修改为代理服务地址</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error_page   500 502 503 504  &#x2F;50x.html;</span><br><span class="line">    location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">        root   &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="地址重写"><a href="#地址重写" class="headerlink" title="地址重写"></a>地址重写</h4>有的时候我们的网站更换了域名，但还有用户在使用老的域名访问，这时可以通过nginx的地址重写来让用户跳转到新的域名进行访问。</li></ol><p>比如说原来用的docs.macrozheng.com这个域名不用了，现在改成<a href="http://www.macrozheng.com了来访问文档项目了；修改docs.conf配置文件，将地址带参数重写到新地址：">www.macrozheng.com了来访问文档项目了；修改docs.conf配置文件，将地址带参数重写到新地址：</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  docs.macrozheng.com;</span><br><span class="line"></span><br><span class="line">    rewrite &quot;^&#x2F;(.*)$&quot; http:&#x2F;&#x2F;www.macrozheng.com&#x2F;$1; #地址重写到新地址</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        root   &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;docs;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error_page   500 502 503 504  &#x2F;50x.html;</span><br><span class="line">    location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">        root   &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="一个IP绑定多个域名"><a href="#一个IP绑定多个域名" class="headerlink" title="一个IP绑定多个域名"></a>一个IP绑定多个域名</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">匹配顺序:</span><br><span class="line">server_name与host匹配优先级如下：</span><br><span class="line">1、完全匹配</span><br><span class="line">2、通配符在前的，如*.test.com</span><br><span class="line">3、在后的，如www.test.*</span><br><span class="line">4、正则匹配，如~^\.www\.test\.com$</span><br><span class="line"></span><br><span class="line">如果都不匹配:</span><br><span class="line">1、优先选择listen配置项后有default或default_server的</span><br><span class="line">2、找到匹配listen端口的第一个server块</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">listen 80;</span><br><span class="line">server_name www;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">listen  80;</span><br><span class="line">server_name www.zkh.com;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="反向代理修改url"><a href="#反向代理修改url" class="headerlink" title="反向代理修改url"></a>反向代理修改url</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">比如对外接口是 192.168.43.144:10050&#x2F;uuatest&#x2F;uivs&#x2F;1&#x2F;1&#x2F;user&#x2F;register</span><br><span class="line">服务实际接口是 192.168.43.144:10050&#x2F;UUA&#x2F;uivs&#x2F;1&#x2F;1&#x2F;user&#x2F;register</span><br><span class="line"></span><br><span class="line">&#x2F;uuatest&#x2F; ：uuatest 不传到后台服务</span><br><span class="line">&#x2F;uuatest  ：uuatest 传到后台服务</span><br><span class="line"></span><br><span class="line">则如下：</span><br><span class="line">server&#123;</span><br><span class="line">  listen 10050;</span><br><span class="line">  server_name 192.168.43.144;</span><br><span class="line">  location &#x2F;uuatest&#x2F; &#123;</span><br><span class="line">    proxy_pass http:&#x2F;&#x2F;uua_service_8081&#x2F;UUA&#x2F;;</span><br><span class="line">    proxy_set_header        X-Real-IP $remote_addr;</span><br><span class="line">    proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">    proxy_set_header        Host $http_host;</span><br><span class="line">    proxy_set_header        urlprefix https;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="IMAP、POP3、SMTP代理服务器"><a href="#IMAP、POP3、SMTP代理服务器" class="headerlink" title="IMAP、POP3、SMTP代理服务器"></a>IMAP、POP3、SMTP代理服务器</h3>]]></content>
      
      
      <categories>
          
          <category> Basic Component </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Introduction of Nginx</title>
      <link href="/2019/10/03/Introduction-of-Nginx/"/>
      <url>/2019/10/03/Introduction-of-Nginx/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Nginx: Engine X</p></blockquote><h2 id="Web-服务器"><a href="#Web-服务器" class="headerlink" title="Web 服务器"></a>Web 服务器</h2><p>Nginx 与 Apache一样，是一种WEB服务器。是基于REST架构风格，以统一资源描述符(Uniform Resources Identifier)URI或者统一资源定位符(Uniform Resources Locator)URL作为沟通依据，通过HTTP协议提供各种网络服务。</p><p>不同于重量级且不支持高并发的Apache，Nginx具有如下特点：</p><ol><li>轻量级<blockquote><p>功能模块少 - Nginx仅保留了HTTP需要的模块，其他都用插件的方式，后天添加代码模块化 - 更适合二次开发，如阿里巴巴Tengine</p></blockquote></li><li>高并发<blockquote><p>使用基于事件驱动架构，使得其可以支持数以百万级别的TCP连接。</p></blockquote></li><li>CPU亲和<blockquote><p>把CPU核心和Nginx工作进程绑定，把每个worker进程固定在一个CPU上执行，减少切换CPU的cache miss，从而提高性能。</p></blockquote></li></ol><h2 id="Nginx-原理"><a href="#Nginx-原理" class="headerlink" title="Nginx 原理"></a>Nginx 原理</h2><h3 id="Nginx进程模型"><a href="#Nginx进程模型" class="headerlink" title="Nginx进程模型"></a>Nginx进程模型</h3><p><img src="Nginx%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B.png" alt=""><br>Nginx 服务器，正常运行过程中：</p><ol><li>多进程：一个 Master 进程、多个 Worker 进程</li><li>Master 进程：管理 Worker 进程</li><li>对外接口：接收外部的操作（信号）</li><li>对内转发：根据外部的操作的不同，通过信号管理 Worker</li><li>监控：监控 worker 进程的运行状态，worker 进程异常终止后，自动重启 worker 进程</li><li>Worker 进程：所有 Worker 进程都是平等的</li><li>实际处理：网络请求，由 Worker 进程处理</li><li>Worker 进程数量：在 nginx.conf 中配置，一般设置为核心数，充分利用 CPU 资源，同时，避免进程数量过多，避免进程竞争 CPU 资源，增加上下文切换的损耗。</li></ol><h3 id="HTTP-连接建立和请求处理过程"><a href="#HTTP-连接建立和请求处理过程" class="headerlink" title="HTTP 连接建立和请求处理过程"></a>HTTP 连接建立和请求处理过程</h3><ol><li>Nginx 启动时，Master 进程，加载配置文件</li><li>Master 进程，初始化监听的 socket</li><li>Master 进程，fork 出多个 Worker 进程</li><li>Worker 进程，竞争新的连接，获胜方通过三次握手，建立 Socket 连接，并处理请求</li></ol><h3 id="高性能、高并发"><a href="#高性能、高并发" class="headerlink" title="高性能、高并发"></a>高性能、高并发</h3><blockquote><p>异步，非阻塞，使用了IO 多路复用 epoll 和大量的底层代码优化。<br>单个连接的请求处理速度没有优势，适合 IO 密集型 场景，事件驱动</p></blockquote><p>如果一个server采用一个进程负责一个request的方式，那么进程数就是并发数。正常情况下，会有很多进程一直在等待中。<br>而nginx采用一个master进程，多个woker进程的模式。<br>master进程主要负责收集、分发请求。每当一个请求过来时，master就拉起一个worker进程负责处理这个请求。<br>同时master进程也负责监控woker的状态，保证高可靠性。<br>woker进程一般设置为跟cpu核心数一致。nginx的woker进程在同一时间可以处理的请求数只受内存限制，可以处理多个请求。</p><p>Nginx 的异步非阻塞工作方式正把当中的等待时间利用起来了。在需要等待的时候，这些进程就空闲出来待命了，因此表现为少数几个进程就解决了大量的并发问题。</p><p>每进来一个request，会有一个worker进程去处理。但不是全程的处理，只处理到可能发生阻塞的地方，比如向上游(后端)服务器转发request，并等待请求返回。那么，这个处理的worker会在发送完请求后，注册一个事件：“如果upstream返回了，告诉我一声，我再接着干”。于是他就休息去了。此时，如果再有request 进来，他就可以很快再按这种方式处理。而一旦上游服务器返回了，就会触发这个事件，worker才会来接手，这个request才会接着往下走。</p><p>所以不同于Apache: 创建多个进程或线程，而每个进程或线程都会为其分配 cpu 和内存(线程要比进程小的多，所以worker支持比perfork高的并发)，并发过大会耗光服务器资源。</p><p>Nginx: 采用单线程来异步非阻塞处理请求(管理员可以配置Nginx主进程的工作进程的数量)(epoll)，不会为每个请求分配cpu和内存资源，节省了大量资源，同时也减少了大量的CPU的上下文切换。所以才使得Nginx支持更高的并发。</p><h3 id="Nginx事件处理模型"><a href="#Nginx事件处理模型" class="headerlink" title="Nginx事件处理模型"></a>Nginx事件处理模型</h3><p><img src="Nginx%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%A8%A1%E5%9E%8B.png" alt=""></p><h3 id="模块化体系结构"><a href="#模块化体系结构" class="headerlink" title="模块化体系结构"></a>模块化体系结构</h3><p><img src="Nginx%E6%A8%A1%E5%9D%97%E5%8C%96%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt=""><br>nginx的模块根据其功能基本上可以分为以下几种类型：</p><h4 id="event-module"><a href="#event-module" class="headerlink" title="event module"></a>event module</h4><p>搭建了独立于操作系统的事件处理机制的框架，及提供了各具体事件的处理。包括ngx_events_module， ngx_event_core_module和ngx_epoll_module等。nginx具体使用何种事件处理模块，这依赖于具体的操作系统和编译选项。</p><h4 id="phase-handler"><a href="#phase-handler" class="headerlink" title="phase handler"></a>phase handler</h4><p>此类型的模块也被直接称为handler模块。主要负责处理客户端请求并产生待响应内容，比如ngx_http_static_module模块，负责客户端的静态页面请求处理并将对应的磁盘文件准备为响应内容输出。</p><h4 id="output-filter"><a href="#output-filter" class="headerlink" title="output filter"></a>output filter</h4><p>也称为filter模块，主要是负责对输出的内容进行处理，可以对输出进行修改。例如，可以实现对输出的所有html页面增加预定义的footbar一类的工作，或者对输出的图片的URL进行替换之类的工作。</p><h4 id="upstream"><a href="#upstream" class="headerlink" title="upstream"></a>upstream</h4><p>upstream模块实现反向代理的功能，将真正的请求转发到后端服务器上，并从后端服务器上读取响应，发回客户端。upstream模块是一种特殊的handler，只不过响应内容不是真正由自己产生的，而是从后端服务器上读取的。</p><h4 id="load-balancer"><a href="#load-balancer" class="headerlink" title="load-balancer"></a>load-balancer</h4><p>负载均衡模块，实现特定的算法，在众多的后端服务器中，选择一个服务器出来作为某个请求的转发服务器。</p><h2 id="Nginx-安装"><a href="#Nginx-安装" class="headerlink" title="Nginx 安装"></a>Nginx 安装</h2><h3 id="yum-安装"><a href="#yum-安装" class="headerlink" title="yum 安装"></a>yum 安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ yum install epel-release</span><br><span class="line">$ yum install nginx</span><br><span class="line"></span><br><span class="line">启停命令</span><br><span class="line">$ systemctl enable nginx</span><br><span class="line">$ systemctl start nginx</span><br><span class="line">$ systemctl restart nginx</span><br><span class="line">$ systemctl reload nginx</span><br><span class="line">浏览器访问IP确认是否开启成功</span><br><span class="line"></span><br><span class="line">配置文件默认位置</span><br><span class="line">&#x2F;etc&#x2F;nginx&#x2F;nginx.conf</span><br></pre></td></tr></table></figure><h3 id="Docker-安装"><a href="#Docker-安装" class="headerlink" title="Docker 安装"></a>Docker 安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull nginx:1.10</span><br><span class="line"></span><br><span class="line">为了从容器中拷贝nginx配置，首先运行一次容器：</span><br><span class="line">docker run -p 80:80 --name nginx \</span><br><span class="line">-v &#x2F;mydata&#x2F;nginx&#x2F;html:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html \</span><br><span class="line">-v &#x2F;mydata&#x2F;nginx&#x2F;logs:&#x2F;var&#x2F;log&#x2F;nginx  \</span><br><span class="line">-d nginx:1.10</span><br><span class="line"></span><br><span class="line">将容器内的配置文件拷贝到指定目录：</span><br><span class="line">docker container cp nginx:&#x2F;etc&#x2F;nginx &#x2F;mydata&#x2F;nginx&#x2F;</span><br><span class="line"></span><br><span class="line">修改文件名称：</span><br><span class="line">mv nginx conf</span><br><span class="line"></span><br><span class="line">终止并删除容器：</span><br><span class="line">docker stop nginx</span><br><span class="line">docker rm nginx</span><br><span class="line"></span><br><span class="line">使用docker命令启动</span><br><span class="line">docker run -p 80:80 --name nginx \</span><br><span class="line">-v &#x2F;mydata&#x2F;nginx&#x2F;html:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html \</span><br><span class="line">-v &#x2F;mydata&#x2F;nginx&#x2F;logs:&#x2F;var&#x2F;log&#x2F;nginx  \</span><br><span class="line">-v &#x2F;mydata&#x2F;nginx&#x2F;conf:&#x2F;etc&#x2F;nginx \</span><br><span class="line">-d nginx:1.10</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Basic Component </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DockerCompose.yml</title>
      <link href="/2019/09/16/DockerCompose-yml/"/>
      <url>/2019/09/16/DockerCompose-yml/</url>
      
        <content type="html"><![CDATA[<h2 id="docker-compose-yml-模板文件属性"><a href="#docker-compose-yml-模板文件属性" class="headerlink" title="docker-compose.yml 模板文件属性"></a>docker-compose.yml 模板文件属性</h2><blockquote><p>默认的模板文件名称为 docker-compose.yml，格式为 YAML 格式。</p></blockquote><h6 id="version"><a href="#version" class="headerlink" title="version"></a>version</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">指定 docker-compose.yml 文件的写法格式</span><br></pre></td></tr></table></figure><h6 id="services"><a href="#services" class="headerlink" title="services"></a>services</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">多个容器集合</span><br></pre></td></tr></table></figure><h6 id="build"><a href="#build" class="headerlink" title="build"></a>build</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">配置构建时，Compose 会利用它自动构建镜像</span><br><span class="line">该值可以是一个路径，也可以是一个对象，用于指定 Dockerfile 参数</span><br><span class="line"></span><br><span class="line">build: .&#x2F;dir</span><br><span class="line">---------------</span><br><span class="line">build:</span><br><span class="line">    context: .&#x2F;dir</span><br><span class="line">    dockerfile: Dockerfile</span><br><span class="line">    args:</span><br><span class="line">        buildno: 1</span><br></pre></td></tr></table></figure><h6 id="command"><a href="#command" class="headerlink" title="command"></a>command</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">覆盖容器启动后默认执行的命令</span><br><span class="line">command: bundle exec thin -p 3000</span><br><span class="line">----------------------------------</span><br><span class="line">command: [bundle,exec,thin,-p,3000]</span><br></pre></td></tr></table></figure><h6 id="dns"><a href="#dns" class="headerlink" title="dns"></a>dns</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">配置 dns 服务器，可以是一个值或列表</span><br><span class="line">dns: 8.8.8.8</span><br><span class="line">------------</span><br><span class="line">dns:</span><br><span class="line">    - 8.8.8.8</span><br><span class="line">    - 9.9.9.9</span><br></pre></td></tr></table></figure><h6 id="dns-search"><a href="#dns-search" class="headerlink" title="dns_search"></a>dns_search</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">配置 DNS 搜索域，可以是一个值或列表</span><br><span class="line">dns_search: example.com</span><br><span class="line">------------------------</span><br><span class="line">dns_search:</span><br><span class="line">    - dc1.example.com</span><br><span class="line">    - dc2.example.com</span><br></pre></td></tr></table></figure><h6 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">环境变量配置，可以用数组或字典两种方式</span><br><span class="line">environment:</span><br><span class="line">    RACK_ENV: development</span><br><span class="line">    SHOW: &#39;ture&#39;</span><br><span class="line">-------------------------</span><br><span class="line">environment:</span><br><span class="line">    - RACK_ENV&#x3D;development</span><br><span class="line">    - SHOW&#x3D;ture</span><br></pre></td></tr></table></figure><h6 id="env-file"><a href="#env-file" class="headerlink" title="env_file"></a>env_file</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">从文件中获取环境变量，可以指定一个文件路径或路径列表，其优先级低于 environment 指定的环境变量</span><br><span class="line">env_file: .env</span><br><span class="line">---------------</span><br><span class="line">env_file:</span><br><span class="line">    - .&#x2F;common.env</span><br></pre></td></tr></table></figure><h6 id="expose"><a href="#expose" class="headerlink" title="expose"></a>expose</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">暴露端口，只将端口暴露给连接的服务，而不暴露给主机</span><br><span class="line">expose:</span><br><span class="line">    - &quot;3000&quot;</span><br><span class="line">    - &quot;8000&quot;</span><br></pre></td></tr></table></figure><h6 id="image"><a href="#image" class="headerlink" title="image"></a>image</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">指定服务所使用的镜像或镜像 ID。如果镜像在本地不存在，Compose 将会尝试拉取这个镜像。</span><br><span class="line">image: java</span><br></pre></td></tr></table></figure><h6 id="network-mode"><a href="#network-mode" class="headerlink" title="network_mode"></a>network_mode</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">设置网络模式</span><br><span class="line">network_mode: &quot;bridge&quot;</span><br><span class="line">network_mode: &quot;host&quot;</span><br><span class="line">network_mode: &quot;none&quot;</span><br><span class="line">network_mode: &quot;service:[service name]&quot;</span><br><span class="line">network_mode: &quot;container:[container name&#x2F;id]&quot;</span><br></pre></td></tr></table></figure><h6 id="ports"><a href="#ports" class="headerlink" title="ports"></a>ports</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">对外暴露的端口定义，和 expose 对应</span><br><span class="line">ports:   # 暴露端口信息  - &quot;宿主机端口:容器暴露端口&quot;</span><br><span class="line">- &quot;8763:8763&quot;</span><br><span class="line">- &quot;8763:8763&quot;</span><br></pre></td></tr></table></figure><h6 id="links"><a href="#links" class="headerlink" title="links"></a>links</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">将指定容器连接到当前连接，可以设置别名，避免ip方式导致的容器重启动态改变的无法连接情况</span><br><span class="line">links:    # 指定服务名称:别名</span><br><span class="line">    - docker-compose-eureka-server:compose-eureka</span><br></pre></td></tr></table></figure><h6 id="volumes"><a href="#volumes" class="headerlink" title="volumes"></a>volumes</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">数据卷所挂载路径设置。可以设置为宿主机路径(HOST:CONTAINER)或者数据卷名称(VOLUME:CONTAINER)，并且可以设置访问模式 （HOST:CONTAINER:ro）。</span><br><span class="line">volumes:</span><br><span class="line">      - &#x2F;app&#x2F;skywalking&#x2F;elasticsearch&#x2F;data:&#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;data:rw</span><br><span class="line">      - conf&#x2F;elasticsearch.yml:&#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;config&#x2F;elasticsearch.yml</span><br></pre></td></tr></table></figure><h6 id="logs"><a href="#logs" class="headerlink" title="logs"></a>logs</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">日志输出信息</span><br><span class="line">--no-color          单色输出，不显示其他颜.</span><br><span class="line">-f, --follow        跟踪日志输出，就是可以实时查看日志</span><br><span class="line">-t, --timestamps    显示时间戳</span><br><span class="line">--tail              从日志的结尾显示，--tail&#x3D;200</span><br></pre></td></tr></table></figure><h6 id="ulimits"><a href="#ulimits" class="headerlink" title="ulimits"></a>ulimits</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">指定容器的 ulimits 限制值。</span><br><span class="line">例如，指定最大进程数为 65535，指定文件句柄数为 20000（软限制，应用可以随时修改，不能超过硬限制） </span><br><span class="line">和 40000（系统硬限制，只能 root 用户提高）。</span><br><span class="line"></span><br><span class="line">ulimits:</span><br><span class="line">   nproc: 65535</span><br><span class="line">   nofile:</span><br><span class="line">     soft: 20000</span><br><span class="line">     hard: 40000</span><br></pre></td></tr></table></figure><h6 id="depends-on"><a href="#depends-on" class="headerlink" title="depends_on"></a>depends_on</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">解决容器的依赖、启动先后的问题。以下例子中会先启动 redis mysql 再启动 web</span><br><span class="line"></span><br><span class="line">version: &#39;3&#39;</span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    depends_on:</span><br><span class="line">      - db</span><br><span class="line">      - redis      </span><br><span class="line">  redis:</span><br><span class="line">    image: redis    </span><br><span class="line">  db:</span><br><span class="line">    image: mysql</span><br></pre></td></tr></table></figure><h6 id="restart"><a href="#restart" class="headerlink" title="restart"></a>restart</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">指定容器退出后的重启策略为始终重启。</span><br><span class="line">该命令对保持服务始终运行十分有效，在生产环境中推荐配置为 always 或者 unless-stopped。</span><br><span class="line"></span><br><span class="line">restart: always</span><br></pre></td></tr></table></figure><h2 id="实战举例"><a href="#实战举例" class="headerlink" title="实战举例"></a>实战举例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">version: &#39;3.3&#39;</span><br><span class="line">services:</span><br><span class="line">  elasticsearch:</span><br><span class="line">    image: docker.elastic.co&#x2F;elasticsearch&#x2F;elasticsearch:6.8.5</span><br><span class="line">    container_name: elasticsearch</span><br><span class="line">    restart: always</span><br><span class="line">    ports:</span><br><span class="line">      - 9200:9200</span><br><span class="line">      - 9300:9300</span><br><span class="line">    environment:</span><br><span class="line">      discovery.type: single-node</span><br><span class="line">    ulimits:</span><br><span class="line">      memlock:</span><br><span class="line">        soft: -1</span><br><span class="line">        hard: -1</span><br><span class="line">  oap:</span><br><span class="line">    image: skywalking&#x2F;oap</span><br><span class="line">    container_name: oap</span><br><span class="line">    depends_on:</span><br><span class="line">      - elasticsearch</span><br><span class="line">    links:</span><br><span class="line">      - elasticsearch</span><br><span class="line">    restart: always</span><br><span class="line">    ports:</span><br><span class="line">      - 11800:11800</span><br><span class="line">      - 12800:12800</span><br><span class="line">    environment:</span><br><span class="line">      SW_STORAGE: elasticsearch</span><br><span class="line">      SW_STORAGE_ES_CLUSTER_NODES: elasticsearch:9200</span><br><span class="line">  ui:</span><br><span class="line">    image: skywalking&#x2F;ui</span><br><span class="line">    container_name: ui</span><br><span class="line">    depends_on:</span><br><span class="line">      - oap</span><br><span class="line">    links:</span><br><span class="line">      - oap</span><br><span class="line">    restart: always</span><br><span class="line">    ports:</span><br><span class="line">      - 8080:8080</span><br><span class="line">    environment:</span><br><span class="line">      SW_OAP_ADDRESS: oap:12800</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Basic Component </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>How To Use Docker Compose</title>
      <link href="/2019/09/15/How-To-Use-Docker-Compose/"/>
      <url>/2019/09/15/How-To-Use-Docker-Compose/</url>
      
        <content type="html"><![CDATA[<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="命令选项"><a href="#命令选项" class="headerlink" title="命令选项"></a>命令选项</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-f, --file FILE 指定使用的 Compose 模板文件，默认为 docker-compose.yml，可以多次指定。</span><br><span class="line">-p, --project-name NAME 指定项目名称，默认将使用所在目录名称作为项目名。</span><br><span class="line">–x-networking 使用 Docker 的可拔插网络后端特性</span><br><span class="line">–x-network-driver DRIVER 指定网络后端的驱动，默认为 bridge</span><br><span class="line">–verbose 输出更多调试信息。</span><br><span class="line">-v, --version 打印版本并退出。</span><br></pre></td></tr></table></figure><h3 id="config"><a href="#config" class="headerlink" title="config"></a>config</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 验证 Compose 文件格式是否正确，若正确则显示配置，若格式错误显示错误原因。如：</span><br><span class="line">docker-compose -f skywalking.yml config</span><br><span class="line"># 此命令不会执行真正的操作，而是显示 docker-compose 程序解析到的配置文件内容</span><br></pre></td></tr></table></figure><h3 id="images"><a href="#images" class="headerlink" title="images"></a>images</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 列出 Compose 文件中包含的镜像。如</span><br><span class="line">docker-compose -f skywalking.yml images</span><br></pre></td></tr></table></figure><h3 id="列出所有运行容器"><a href="#列出所有运行容器" class="headerlink" title="列出所有运行容器"></a>列出所有运行容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose ps</span><br></pre></td></tr></table></figure><h3 id="查看服务日志输出"><a href="#查看服务日志输出" class="headerlink" title="查看服务日志输出"></a>查看服务日志输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose logs</span><br></pre></td></tr></table></figure><h3 id="打印绑定的公共端口"><a href="#打印绑定的公共端口" class="headerlink" title="打印绑定的公共端口"></a>打印绑定的公共端口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">下面命令可以输出 eureka 服务 8761 端口所绑定的公共端口</span><br><span class="line">docker-compose port eureka 8761</span><br></pre></td></tr></table></figure><h3 id="构建或者重新构建服务"><a href="#构建或者重新构建服务" class="headerlink" title="构建或者重新构建服务"></a>构建或者重新构建服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 构建（重新构建）项目中的服务容器。如：</span><br><span class="line">docker-compose -f skywalking.yml build</span><br><span class="line"># 一般搭配自定义镜像，比如编写的Dockfile，功能类似于docker build .</span><br></pre></td></tr></table></figure><h3 id="启动指定服务已存在的容器"><a href="#启动指定服务已存在的容器" class="headerlink" title="启动指定服务已存在的容器"></a>启动指定服务已存在的容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose start eureka</span><br></pre></td></tr></table></figure><h3 id="停止已运行的服务的容器"><a href="#停止已运行的服务的容器" class="headerlink" title="停止已运行的服务的容器"></a>停止已运行的服务的容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose stop eureka</span><br></pre></td></tr></table></figure><h3 id="删除指定服务的容器"><a href="#删除指定服务的容器" class="headerlink" title="删除指定服务的容器"></a>删除指定服务的容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose rm eureka</span><br></pre></td></tr></table></figure><h3 id="构建、启动、停止容器"><a href="#构建、启动、停止容器" class="headerlink" title="构建、启动、停止容器"></a>构建、启动、停止容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up</span><br><span class="line">docker-compose down</span><br><span class="line"></span><br><span class="line">默认情况，如果服务容器已经存在，docker-compose up 将会尝试停止容器，</span><br><span class="line">然后重新创建（保持使用 volumes-from 挂载的卷），以保证新启动的服务匹配 docker-compose.yml 文件的最新内容。</span><br><span class="line">如果用户不希望容器被停止并重新创建，可以使用 docker-compose up --no-recreate。</span><br><span class="line">这样将只会启动处于停止状态的容器，而忽略已经运行的服务。</span><br><span class="line">如果用户只想重新部署某个服务，可以使用 docker-compose up --no-deps -d &lt;SERVICE_NAME&gt; 来重新创建服务并后台停止旧服务，启动新服务，并不会影响到其所依赖的服务。</span><br><span class="line">此命令有如下选项：</span><br><span class="line">1. -d 在后台运行服务容器。</span><br><span class="line">2. --no-color 不使用颜色来区分不同的服务的控制台输出。</span><br><span class="line">3. --no-deps 不启动服务所链接的容器。</span><br><span class="line">4. --force-recreate 强制重新创建容器，不能与 --no-recreate 同时使用。</span><br><span class="line">5. --no-recreate 如果容器已经存在了，则不重新创建，不能与 --force-recreate 同时使用。</span><br><span class="line">6. --no-build 不自动构建缺失的服务镜像。</span><br><span class="line">7. -t, --timeout TIMEOUT 停止容器时候的超时（默认为 10 秒）。</span><br></pre></td></tr></table></figure><h3 id="通过发送-SIGKILL-信号来停止指定服务的容器"><a href="#通过发送-SIGKILL-信号来停止指定服务的容器" class="headerlink" title="通过发送 SIGKILL 信号来停止指定服务的容器"></a>通过发送 SIGKILL 信号来停止指定服务的容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose kill eureka</span><br></pre></td></tr></table></figure><h3 id="下载服务镜像：pull"><a href="#下载服务镜像：pull" class="headerlink" title="下载服务镜像：pull"></a>下载服务镜像：pull</h3><h3 id="设置指定服务运行容器的个数"><a href="#设置指定服务运行容器的个数" class="headerlink" title="设置指定服务运行容器的个数"></a>设置指定服务运行容器的个数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 以 service&#x3D;num 形式指定</span><br><span class="line">docker-compose scale user&#x3D;3 movie&#x3D;3</span><br></pre></td></tr></table></figure><h3 id="在一个服务上执行一个命令"><a href="#在一个服务上执行一个命令" class="headerlink" title="在一个服务上执行一个命令"></a>在一个服务上执行一个命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose run web bash</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Basic Component </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker Compose Introduction</title>
      <link href="/2019/09/15/Docker-Compose-Introduction/"/>
      <url>/2019/09/15/Docker-Compose-Introduction/</url>
      
        <content type="html"><![CDATA[<h2 id="DockerCompose-概念"><a href="#DockerCompose-概念" class="headerlink" title="DockerCompose 概念"></a>DockerCompose 概念</h2><p>Compose有2个重要的概念：</p><ul><li>项目（Project）：由一组关联的应用容器组成的一个完整业务单元，在 docker-compose.yml 文件中定义。</li><li>服务（Service）：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。<h3 id="工程、服务、容器"><a href="#工程、服务、容器" class="headerlink" title="工程、服务、容器"></a>工程、服务、容器</h3><blockquote><p>Docker Compose 将所管理的容器分为三层，分别是工程（project）、服务（service）、容器（container）</p></blockquote></li></ul><p>Docker Compose 运行目录下的所有文件（docker-compose.yml）组成一个工程,一个工程包含多个服务，每个服务中定义了容器运行的镜像、参数、依赖，一个服务可包括多个容器实例</p><h2 id="安装-Docker-Compose"><a href="#安装-Docker-Compose" class="headerlink" title="安装 Docker-Compose"></a>安装 Docker-Compose</h2><h3 id="github-安装"><a href="#github-安装" class="headerlink" title="github 安装"></a>github 安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">自动下载适应版本的 Compose，并为安装脚本添加执行权限</span><br><span class="line">curl -L https:&#x2F;&#x2F;github.com&#x2F;docker&#x2F;compose&#x2F;releases&#x2F;download&#x2F;1.25.0&#x2F;docker-compose-$(uname -s)-$(uname -m) -o &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose</span><br><span class="line">chmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose</span><br></pre></td></tr></table></figure><h3 id="pip-安装"><a href="#pip-安装" class="headerlink" title="pip 安装"></a>pip 安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip install docker-compose</span><br><span class="line"># 查看是否安装成功</span><br><span class="line">docker-compose -v</span><br></pre></td></tr></table></figure><h3 id="安装补全插件"><a href="#安装补全插件" class="headerlink" title="安装补全插件"></a>安装补全插件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;docker&#x2F;compose&#x2F;1.25.0&#x2F;contrib&#x2F;completion&#x2F;bash&#x2F;docker-compose &gt; &#x2F;etc&#x2F;bash_completion.d&#x2F;docker-compose</span><br></pre></td></tr></table></figure><h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 二进制卸载</span><br><span class="line">rm &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose</span><br><span class="line"># pip卸载</span><br><span class="line">pip uninstall docker-compose</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Basic Component </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Manage Docker Container</title>
      <link href="/2019/09/12/Manage-Docker-Container/"/>
      <url>/2019/09/12/Manage-Docker-Container/</url>
      
        <content type="html"><![CDATA[<h2 id="容器资源管理"><a href="#容器资源管理" class="headerlink" title="容器资源管理"></a>容器资源管理</h2><h3 id="资源类型"><a href="#资源类型" class="headerlink" title="资源类型"></a>资源类型</h3><p>当我们启动一个容器的时候，它可以使用一些系统资源，这与我们在物理机上启动程序基本是一致的。比如主要的几类：</p><ul><li>CPU</li><li>内存</li><li>网络</li><li>I/O</li><li>GPU<h3 id="查看容器占用资源"><a href="#查看容器占用资源" class="headerlink" title="查看容器占用资源"></a>查看容器占用资源</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">docker stats 容器id</span><br><span class="line">或者稍微简化的命令 docker top 容器id</span><br><span class="line"># docker top $(docker ps -ql) -o pid,c,cmd  </span><br><span class="line"></span><br><span class="line"># 可加参数</span><br><span class="line">--no-stream  # docker stats 命令默认是一个持续的动态流式输出（每秒一次），给它传递 --no-stream 参数后，它就只输出一次便会退出了。</span><br><span class="line"></span><br><span class="line"># Container ID：容器的 ID，也是一个容器生命周期内不会变更的信息。</span><br><span class="line"># Name：容器的名称，如果没有手动使用 --name 参数指定，则 Docker 会随机生成一个，运行过程中也可以通过命令修改。</span><br><span class="line"># CPU %：容器正在使用的 CPU 资源的百分比，下面会详细说。</span><br><span class="line"># Mem Usage&#x2F;Limit：当前内存的使用及容器可用的最大内存。</span><br><span class="line"># Mem %：容器正在使用的内存资源的百分比。</span><br><span class="line"># Net I&#x2F;O：容器通过其网络接口发送和接受到的数据量。</span><br><span class="line"># Block I&#x2F;O：容器通过块设备读取和写入的数据量。</span><br><span class="line"># Pids：容器创建的进程或线程数。</span><br></pre></td></tr></table></figure><h3 id="管理容器的-CPU-资源"><a href="#管理容器的-CPU-资源" class="headerlink" title="管理容器的 CPU 资源"></a>管理容器的 CPU 资源</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run --help |grep CPU</span><br><span class="line"></span><br><span class="line"># 1. 限制容器占用cpu资源，默认无限制</span><br><span class="line">docker update --cpus &quot;0.5&quot; $(docker ps -ql) # 限制容器只可以使用 0.5 CPU</span><br><span class="line"># 如果是多核，比如八核，则最多可以分配8个cpu，cpu占用率也会显示800%</span><br><span class="line"></span><br><span class="line"># 2. 指定可使用 CPU 核</span><br><span class="line"># 可以使用 --cpuset-cpus 来指定分配可使用的 CPU 核，指定 0 表示使用第一个 CPU 核。</span><br><span class="line">docker update --cpus &quot;1.5&quot; --cpuset-cpus 0  $(docker ps -ql)</span><br></pre></td></tr></table></figure><h3 id="管理容器的-内存-资源"><a href="#管理容器的-内存-资源" class="headerlink" title="管理容器的 内存 资源"></a>管理容器的 内存 资源</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">docker run --help |egrep &#39;memory|oom&#39;</span><br><span class="line"></span><br><span class="line"># OOM——Out Of Memory</span><br><span class="line"># 当内核检测到没有足够的内存来运行系统的某些功能时候，就会触发 OOM 异常，并且会使用 OOM Killer 来杀掉一些进程，腾出空间以保障系统的正常运行。</span><br><span class="line"># 内核中 OOM Killer 的代码，在 torvalds&#x2F;linux&#x2F;mm&#x2F;oom_kill.c 可直接看到</span><br><span class="line"># Docker 在启动的时候默认设置了一个 -500 的 oom_score_adj 以尽可能地避免 Docker 进程本身被 OOM Killer 给杀掉。</span><br><span class="line"># 如果我们想让某个容器，尽可能地不要被 OOM Killer 杀掉，那我们可以给它传递 --oom-score-adj 配置一个比较低的数值。</span><br><span class="line"># 但是注意：不要通过 --oom-kill-disable 禁用掉 OOM Killer，或者给容器设置低于 dockerd 进程的 oom_score_adj 值，这可能会导致某些情况下系统的不稳定。</span><br><span class="line"></span><br><span class="line"># 限制内存</span><br><span class="line">docker run --rm -it --memory 10m alpine # --memory 10m 限制其可使用的内存为 10 m</span><br><span class="line"># 查看限制大小</span><br><span class="line"># docker stats查询</span><br><span class="line">docker stats --no-stream $(docker ps -ql)</span><br><span class="line"># 在容器内执行</span><br><span class="line">cat &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;memory&#x2F;memory.limit_in_bytes </span><br><span class="line">&gt;&gt;&gt; 10485760</span><br><span class="line"># 在宿主机上执行</span><br><span class="line">cat &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;memory&#x2F;system.slice&#x2F;docker-$(docker inspect --format &#39;&#123;&#123; .Id&#125;&#125;&#39; $(docker ps -ql)).scope&#x2F;memory.limit_in_bytes</span><br><span class="line">&gt;&gt;&gt; 10485760</span><br><span class="line"></span><br><span class="line"># 更新容器可使用的内存</span><br><span class="line">docker update --memory 20m $(docker ps -ql)</span><br></pre></td></tr></table></figure><h4 id="内存限制参数的特定行为"><a href="#内存限制参数的特定行为" class="headerlink" title="内存限制参数的特定行为"></a>内存限制参数的特定行为</h4><blockquote><p>这里的特定参数行为，主要是指我们前面使用的 –memory 和未介绍过的 –memory-swap 这两个参数。</p></blockquote></li></ul><ol><li>–memory 用于限制内存使用量，而 –memory-swap 则表示内存和 Swap 的总和。</li></ol><p>–memory-swap 始终应该大于等于 –memory （毕竟 Swap 最小也只能是 0 ）。<br>2. 如果只指定了 –memory 则最终 –memory-swap 将会设置为 –memory 的两倍。也就是说，在只传递 –memory 的情况下，容器只能使用与 –memory 相同大小的 Swap。<br>如果创建容器的时候 –memory 10，那么直接对容器update扩大至 20m 的时候能成功，而扩大到 100m 的时候会出错，在上述场景中只指定了 –memory 为 10m，所以 –memory-swap 就默认被设置成了 20m。<br>3. 如果 –memory-swap 和 –memory 设置了相同值，则表示不使用 Swap。<br>4. 如果 –memory-swap 设置为 -1 则表示不对容器使用的 Swap 进行限制。<br>5. 如果设置了 –memory-swap 参数，则必须设置 –memory 参数。</p>]]></content>
      
      
      <categories>
          
          <category> Basic Component </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DockerFile</title>
      <link href="/2019/08/12/DockerFile/"/>
      <url>/2019/08/12/DockerFile/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Dockerfile的本质就是由一系列顺序编排的命令和参数组成的脚本，并利用它把我们需要的应用制成一个镜像文件</p></blockquote><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>1、对于开发人员：可以为开发团队提供完全一致的开发环境；<br>2、对于测试人员：可以直接用开发所制成的镜像或者通过Dockerfile文件构建一个新的镜像开始工作了；<br>3、对于运维人员：在部署时，可以实现应用的无缝移植。</p><h2 id="dockerignore"><a href="#dockerignore" class="headerlink" title=".dockerignore"></a>.dockerignore</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.git</span><br><span class="line">node_modules</span><br><span class="line">npm-debug.log</span><br><span class="line"># 上面代码表示，这三个路径要排除，不要打包进入 image 文件。如果没有路径要排除，这个文件可以不新建。</span><br></pre></td></tr></table></figure><h2 id="创建指令"><a href="#创建指令" class="headerlink" title="创建指令"></a>创建指令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">docker build [OPTIONS] PATH | URL | -</span><br><span class="line"></span><br><span class="line">--build-arg&#x3D;[] :设置镜像创建时的变量；</span><br><span class="line">--cpu-shares :设置 cpu 使用权重；</span><br><span class="line">--cpu-period :限制 CPU CFS周期；</span><br><span class="line">--cpu-quota :限制 CPU CFS配额；</span><br><span class="line">--cpuset-cpus :指定使用的CPU id；</span><br><span class="line">--cpuset-mems :指定使用的内存 id；</span><br><span class="line">--disable-content-trust :忽略校验，默认开启；</span><br><span class="line">-f :指定要使用的Dockerfile路径；</span><br><span class="line">--force-rm :设置镜像过程中删除中间容器；</span><br><span class="line">--isolation :使用容器隔离技术；</span><br><span class="line">--label&#x3D;[] :设置镜像使用的元数据；</span><br><span class="line">-m :设置内存最大值；</span><br><span class="line">--memory-swap :设置Swap的最大值为内存+swap，&quot;-1&quot;表示不限swap；</span><br><span class="line">--no-cache :创建镜像的过程不使用缓存；</span><br><span class="line">--pull :尝试去更新镜像的新版本；</span><br><span class="line">--quiet, -q :安静模式，成功后只输出镜像 ID；</span><br><span class="line">--rm :设置镜像成功后删除中间容器；</span><br><span class="line">--shm-size :设置&#x2F;dev&#x2F;shm的大小，默认值是64M；</span><br><span class="line">--ulimit :Ulimit配置。</span><br><span class="line">--tag, -t: 镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。</span><br><span class="line">--network: 默认 default。在构建期间设置RUN指令的网络模式</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">举例：</span><br><span class="line">1. 使用当前目录的 Dockerfile 创建镜像，标签为 runoob&#x2F;ubuntu:v1</span><br><span class="line">docker build -t runoob&#x2F;ubuntu:v1 .</span><br><span class="line"></span><br><span class="line">2. 使用URL github.com&#x2F;creack&#x2F;docker-firefox 的 Dockerfile 创建镜像。</span><br><span class="line">docker build github.com&#x2F;creack&#x2F;docker-firefox</span><br><span class="line"></span><br><span class="line">3. 也可以通过 -f Dockerfile 文件的位置：</span><br><span class="line">docker build -f &#x2F;path&#x2F;to&#x2F;a&#x2F;Dockerfile .</span><br></pre></td></tr></table></figure><h2 id="命令详解"><a href="#命令详解" class="headerlink" title="命令详解"></a>命令详解</h2><h3 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">指定哪种镜像作为新镜像的基础镜像，如：</span><br><span class="line">FROM ubuntu:14.04</span><br></pre></td></tr></table></figure><h3 id="MAINTAINER"><a href="#MAINTAINER" class="headerlink" title="MAINTAINER"></a>MAINTAINER</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">指明该镜像的作者和其电子邮件，如：</span><br><span class="line">MAINTAINER vector4wang &quot;xxxxxxx@qq.com&quot;</span><br></pre></td></tr></table></figure><h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">设置环境变量 (可以写多条)</span><br><span class="line">ENV key value</span><br></pre></td></tr></table></figure><h3 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在新镜像内部执行的命令，比如安装一些软件、配置一些基础环境，可使用\来换行，如：</span><br><span class="line">RUN echo &#39;hello docker!&#39; \</span><br><span class="line">    &gt; &#x2F;usr&#x2F;local&#x2F;file.txt</span><br><span class="line"></span><br><span class="line">也可以使用exec格式RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]的命令，如：</span><br><span class="line">RUN [&quot;apt-get&quot;,&quot;install&quot;,&quot;-y&quot;,&quot;nginx&quot;]</span><br></pre></td></tr></table></figure><h3 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">将主机的文件复制到镜像内，如果目的位置不存在，Docker会自动创建所有需要的目录结构：</span><br><span class="line">COPY source_dir&#x2F;file dest_dir&#x2F;file</span><br><span class="line">注意：</span><br><span class="line">1. 需要复制的目录一定要放在Dockerfile文件的同级目录下</span><br><span class="line">2. 因为构建环境将会上传到Docker守护进程，而复制是在Docker守护进程中进行的。任何位于构建环境之外的东西都是不可用的。COPY指令的目的的位置则必须是容器内部的一个绝对路径。</span><br><span class="line">3. 如果有压缩文件并不能解压</span><br></pre></td></tr></table></figure><h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">将主机的文件复制到镜像中，跟COPY一样，限制条件和使用方式都一样，如：</span><br><span class="line">ADD source_dir&#x2F;file dest_dir&#x2F;file</span><br><span class="line">ADD会对压缩文件（tar, gzip, bzip2, etc）做提取和解压操作。</span><br></pre></td></tr></table></figure><h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">暴露镜像的端口供主机做映射，启动镜像时，使用-P参数来讲镜像端口与宿主机的随机端口做映射。可指定多个：</span><br><span class="line">EXPOSE 8080</span><br><span class="line">EXPOSE 8081</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在构建镜像时，指定镜像的工作目录，之后的命令都是基于此工作目录，如果不存在，则会创建目录。如：</span><br><span class="line">WORKDIR &#x2F;usr&#x2F;local</span><br><span class="line">WORKDIR webservice</span><br><span class="line">RUN echo &#39;hello docker&#39; &gt; text.txt</span><br><span class="line">...</span><br><span class="line">最终会在&#x2F;usr&#x2F;local&#x2F;webservice&#x2F;目录下生成text.txt文件</span><br></pre></td></tr></table></figure><h3 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">当一个包含ONBUILD命令的镜像被用作其他镜像的基础镜像时，</span><br><span class="line">(比如用户的镜像需要从某为准备好的位置添加源代码，或者用户需要执行特定于构建镜像的环境的构建脚本)，该命令就会执行。</span><br><span class="line"></span><br><span class="line">如创建镜像image-A：</span><br><span class="line">FROM ubuntu</span><br><span class="line">...</span><br><span class="line">ONBUILD ADD . &#x2F;var&#x2F;www</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">然后创建镜像image-B，指定image-A为基础镜像，如：</span><br><span class="line">FROM image-A</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">然后在构建image-B的时候，日志上显示如下:</span><br><span class="line">Step 0 : FROM image-A</span><br><span class="line"># Execting 1 build triggers</span><br><span class="line">Step onbuild-0 : ADD . &#x2F;var&#x2F;www</span><br></pre></td></tr></table></figure><h3 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">指定该镜像以什么样的用户去执行，如：</span><br><span class="line">USER mongo</span><br></pre></td></tr></table></figure><h3 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">用来向基于镜像创建的容器添加卷。比如你可以将mongodb镜像中存储数据的data文件指定为主机的某个文件。(容器内部建议不要存储任何数据)</span><br><span class="line">如：</span><br><span class="line">VOLUME &#x2F;data&#x2F;db &#x2F;data&#x2F;configdb</span><br><span class="line">注意:VOLUME 主机目录 容器目录</span><br></pre></td></tr></table></figure><p>注意：一般直接 VOLUME 容器目录<br>因为挂载会出现问题<br>然后docker启动容器的时候再加上 -v 参数以映射，详见docker.md</p><h3 id="CMD-与-ENTRYPOINT"><a href="#CMD-与-ENTRYPOINT" class="headerlink" title="CMD 与 ENTRYPOINT"></a>CMD 与 ENTRYPOINT</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">CMD与ENTRYPOINT作用与用法一样：</span><br><span class="line">都是在容器启动时需要执行的命令，如：</span><br><span class="line">CMD &#x2F;bin&#x2F;bash</span><br><span class="line">ENTRYPOINT &#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">同样可以使用exec语法，如：</span><br><span class="line">CMD [&quot;&#x2F;bin&#x2F;bash&quot;]</span><br><span class="line">当有多个CMD的时候，只有最后一个生效。</span><br><span class="line"></span><br><span class="line">但两者拥有很大的区别：</span><br><span class="line">1. CMD的命令会被 docker run 的命令覆盖而ENTRYPOINT不会</span><br><span class="line">&gt; 如使用CMD [&quot;&#x2F;bin&#x2F;bash&quot;]或ENTRYPOINT [&quot;&#x2F;bin&#x2F;bash&quot;]后，再使用docker run -ti image启动容器，如同使用：</span><br><span class="line">docker run -ti image &#x2F;bin&#x2F;bash</span><br><span class="line">&#x2F;bin&#x2F;bash：容器启动以后，内部第一个执行的命令。这里是启动 Bash，保证用户可以使用 Shell。</span><br><span class="line"></span><br><span class="line">但是如果启动镜像的命令为docker run -ti image &#x2F;bin&#x2F;ps，使用CMD后面的命令就会被覆盖转而执行bin&#x2F;ps命令，而ENTRYPOINT的则不会，而是会把 docker run 后面的命令当做ENTRYPOINT&lt;font color&#x3D;&quot;FF0000&quot;&gt;执行命令的参数&lt;&#x2F;font&gt;。</span><br><span class="line"></span><br><span class="line">以下例子比较容易理解</span><br><span class="line">Dockerfile中</span><br><span class="line">ENTRYPOINT [&quot;&#x2F;user&#x2F;sbin&#x2F;nginx&quot;]</span><br><span class="line"></span><br><span class="line">然后通过启动build之后的容器</span><br><span class="line">docker run -ti image -g &quot;daemon off&quot;</span><br><span class="line"></span><br><span class="line">此时-g &quot;daemon off&quot;会被当成参数传递给ENTRYPOINT，最终的命令变成了</span><br><span class="line">&#x2F;user&#x2F;sbin&#x2F;nginx -g &quot;daemon off&quot;</span><br><span class="line"></span><br><span class="line">CMD和ENTRYPOINT都存在时，CMD的指令变成了ENTRYPOINT的参数，并且此CMD提供的参数会被 docker run 后面的命令覆盖，如：</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">ENTRYPOINT [&quot;echo&quot;,&quot;hello&quot;,&quot;i am&quot;]</span><br><span class="line">CMD [&quot;docker&quot;]</span><br><span class="line">之后启动构建之后的容器</span><br><span class="line"></span><br><span class="line">使用docker run -ti image</span><br><span class="line">输出“hello i am docker”</span><br><span class="line"></span><br><span class="line">使用docker run -ti image world</span><br><span class="line">输出“hello i am world”</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Basic Component </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>How To Use Docker</title>
      <link href="/2019/08/11/How-To-Use-Docker/"/>
      <url>/2019/08/11/How-To-Use-Docker/</url>
      
        <content type="html"><![CDATA[<h6 id="help"><a href="#help" class="headerlink" title="help"></a>help</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 比如：</span><br><span class="line">docker run --help</span><br></pre></td></tr></table></figure><h6 id="login"><a href="#login" class="headerlink" title="login"></a>login</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># docker后台登陆</span><br><span class="line"># 注意，账号不是邮箱地址</span><br><span class="line">docker login</span><br></pre></td></tr></table></figure><h6 id="search"><a href="#search" class="headerlink" title="search"></a>search</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#  查看仓库里有些什么镜像</span><br><span class="line">docker search jenkins</span><br><span class="line"></span><br><span class="line"># 默认从docker hub搜寻，镜像名称前面会默认加上 docker.io&#x2F;</span><br><span class="line"># 当然也可以找其他常见的，如 mysql, tomcat, nginx 等等。</span><br><span class="line"></span><br><span class="line"># NAME：镜像的仓库名</span><br><span class="line"># DESCRIPTION：镜像描述</span><br><span class="line"># STARS：用户评价，即用户欢迎程度</span><br><span class="line"># OFFICIAL：是否官方</span><br></pre></td></tr></table></figure><h6 id="pull"><a href="#pull" class="headerlink" title="pull"></a>pull</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 拉取镜像到本地，如果不加版本默认会下载latest版本</span><br><span class="line">docker pull 镜像名:版本</span><br></pre></td></tr></table></figure><h6 id="push"><a href="#push" class="headerlink" title="push"></a>push</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 推送镜像到hub</span><br><span class="line">docker push 镜像名:版本</span><br></pre></td></tr></table></figure><h6 id="run-与-参数"><a href="#run-与-参数" class="headerlink" title="run 与 参数"></a>run 与 参数</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 创建容器</span><br><span class="line">docker run -dit --rm --privileged&#x3D;true\ </span><br><span class="line">-p21:21 -p9010:9010 -p8080:8080 -p30000-30010:30000-30010\</span><br><span class="line">--name how2jtmall how2j&#x2F;tmall:latest &#x2F;usr&#x2F;sbin&#x2F;init</span><br><span class="line"></span><br><span class="line"># 1. docker run 表示运行一个镜像</span><br><span class="line"># 2. -dit 是 -d -i -t 的缩写。 -d ，表示 detach，即在后台运行。 -i 表示提供交互接口，这样才可以通过 docker 和 跑起来的操作系统交互。-t 表示提供一个 tty (伪终端)，与 -i 配合就可以通过 ssh 工具连接到这个容器里面去了</span><br><span class="line"># 3. --rm 表示在容器终止运行后自动删除容器文件，或者如果容器已经存在了，自动删除容器</span><br><span class="line"># 4. --privileged 启动容器的时候，把权限带进去。这样才可以在容器里进行完整的操作</span><br><span class="line"># 5. -p21:21 第一个21，表示在CentOS上开放21端口。第二个21表示在容器里开放21端口。 这样当访问CentOS 的21端口的时候，就会间接地访问到容器里了。</span><br><span class="line"># 6. -p9010:9010 和 21一个道理</span><br><span class="line"># 7. -p8080:8080 和 21 一个道理，tomcat端口</span><br><span class="line"># 8. -p30000-30010 和21也是一个道理，这个是ftp用来传输数据的</span><br><span class="line"># 9. --name how2jtmall 给容器取了个名字，叫做 how2jtmall，方便后续管理</span><br><span class="line"># 10. how2j&#x2F;tmall:latest how2j&#x2F;tmall就是镜像的名称， latest是版本号，即最新版本</span><br><span class="line"># 11. &#x2F;usr&#x2F;sbin&#x2F;init: 表示启动后运行的程序，即通过这个命令做初始化</span><br><span class="line"># 12. -v 表示目录映射关系（前者是宿主机目录，后者是映射到宿主机上的目录），可以使用多个－v做多个目录或文件映射。</span><br><span class="line"># 13. -e 表示添加容器的环境变量</span><br></pre></td></tr></table></figure><h6 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 进入容器，进去之后，就可以像操作一个普通 linux 那样操作了</span><br><span class="line">docker exec -it how2jtmall &#x2F;bin&#x2F;bash</span><br><span class="line"># 输入 exit 退出容器</span><br></pre></td></tr></table></figure><h6 id="images"><a href="#images" class="headerlink" title="images"></a>images</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 查看本地有些什么镜像</span><br><span class="line">docker images</span><br><span class="line"># REPOSITORY：镜像名称</span><br><span class="line"># TAG：镜像标签</span><br><span class="line"># IMAGE ID：镜像ID</span><br><span class="line"># CREATED：镜像的创建日期（不是获取该镜像的日期）</span><br><span class="line"># SIZE：镜像大小</span><br></pre></td></tr></table></figure><h6 id="rmi"><a href="#rmi" class="headerlink" title="rmi"></a>rmi</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 删除本地镜像</span><br><span class="line">docker rmi docker.io&#x2F;tomcat:8.0</span><br><span class="line"># 有容器的情况下需要先删除容器</span><br><span class="line"># 如果需要一次性删除全部镜像</span><br><span class="line">docker rmi $(docker images -q)</span><br></pre></td></tr></table></figure><h6 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 对容器做了修改后，把改动后的容器，再次转换为镜像。</span><br><span class="line">docker commit 容器名 保存的镜像名</span><br></pre></td></tr></table></figure><h6 id="生命周期管理"><a href="#生命周期管理" class="headerlink" title="生命周期管理"></a>生命周期管理</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">暂停：pause</span><br><span class="line">恢复：unpause</span><br><span class="line">停止：stop</span><br><span class="line">开始：start</span><br></pre></td></tr></table></figure><h6 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker ps     查看正在运行的容器</span><br><span class="line">docker ps –a  查看所有的容器</span><br><span class="line">docker ps -a --filter status&#x3D;dead --filter status&#x3D;exited --last 1 # 找出最近运行失败的Docker容器</span><br></pre></td></tr></table></figure><h6 id="inspect"><a href="#inspect" class="headerlink" title="inspect"></a>inspect</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 检查容器具体内容</span><br><span class="line">docker inspect 容器名或id</span><br><span class="line"></span><br><span class="line"># 该命令获取两个主要响应：镜像级别的详细信息和容器级别的详细信息。</span><br><span class="line"># 1. 容器ID以及创建的时间戳</span><br><span class="line"># 2. 当前状态（在尝试识别容器是否已停止以及为何停止时很有用）</span><br><span class="line"># 3. Docker镜像信息、文件系统绑定、卷信息以及挂载</span><br><span class="line"># 4. 环境变量，例如传递给容器的命令行参数</span><br><span class="line"># 5. 网络配置：IPv4和IPv6的IP地址以及网关和辅助地址</span><br></pre></td></tr></table></figure><h6 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 删除容器</span><br><span class="line">docker rm 容器名&#x2F;id</span><br><span class="line"># 删除所有容器</span><br><span class="line">docker rm -f $(docker ps -a -q)</span><br></pre></td></tr></table></figure><h6 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 通过tag可以对镜像进行标记</span><br><span class="line">docker tag [imageName] [username]&#x2F;[repository]:[tag]</span><br><span class="line">docker tag docker.io&#x2F;tomcat:8.0 docker.io&#x2F;mytomcat:8.0</span><br><span class="line"># 然后docker images，会发现上面两个镜像都拥有同样的imageid</span><br></pre></td></tr></table></figure><h6 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 拷贝文件</span><br><span class="line">docker cp 需要拷贝的文件或目录容器名称:容器目录-&gt;把宿主机的文件拷贝到容器里</span><br><span class="line">docker cp 容器名称:容器目录需要拷贝的文件或目录-&gt;从容器中拷贝文件到宿主机</span><br></pre></td></tr></table></figure><h6 id="save-amp-load"><a href="#save-amp-load" class="headerlink" title="save &amp; load"></a>save &amp; load</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 备份：备份的作用在于保留一个版本的镜像。</span><br><span class="line">docker save –o 打包的后的文件名.tar 镜像名</span><br><span class="line"># 恢复：假如我们对修改运行一段时间后的容器不满意，想要回到最初的状态，这时我们就可以删除现在的容器和镜像，然后恢复备份的镜像，直接run。</span><br><span class="line">docker rm 你要删除的镜像名或者id</span><br><span class="line">docker load –i 你的备份镜像tar包</span><br></pre></td></tr></table></figure><h6 id="logs"><a href="#logs" class="headerlink" title="logs"></a>logs</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查看容器运行日志</span><br><span class="line">docker logs 容器id</span><br></pre></td></tr></table></figure><h6 id="history"><a href="#history" class="headerlink" title="history"></a>history</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查看镜像build历史</span><br><span class="line">docker history 镜像id</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Basic Component </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker Introduction</title>
      <link href="/2019/08/10/Docker-Introduction/"/>
      <url>/2019/08/10/Docker-Introduction/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://docs.docker.com/" target="_blank" rel="noopener">Docker文档</a> | <a href="https://hub.docker.com/" target="_blank" rel="noopener">DockerHub</a></p></blockquote><h2 id="Docker-原理"><a href="#Docker-原理" class="headerlink" title="Docker 原理"></a>Docker 原理</h2><blockquote><p>所谓的镜像，就是持久化后的，安装了各种工具，软件和服务的一个Linux 操作系统。<br>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。</p></blockquote><h3 id="Docker-特点"><a href="#Docker-特点" class="headerlink" title="Docker 特点"></a>Docker 特点</h3><ol><li>文件系统隔离：每个不同的容器都存在不同的独立文件系统中</li><li>资源隔离：每个容器都有自己独立的ip，网络和虚拟接口</li><li>日志记录：Docker将会收集和记录每个进程容器的标准流（stdout/stderr/stdin），用于实时检索和批量检索</li></ol><h3 id="三类主要用途"><a href="#三类主要用途" class="headerlink" title="三类主要用途"></a>三类主要用途</h3><p>（1）提供一次性的环境。比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。<br>（2）提供弹性的云服务。因为 Docker 容器可以随开随关，很适合动态扩容和缩容。<br>（3）组建微服务架构。通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。</p><h3 id="Docker-术语"><a href="#Docker-术语" class="headerlink" title="Docker 术语"></a>Docker 术语</h3><p>仓库： 别人做好的现成的镜像，都放在仓库里<br>镜像： 自己要用哪个镜像，就先拉到本地来。镜像就相当于还没激活的容器。</p><blockquote><p>Docker 把应用程序及其依赖，打包在 image 文件里面。只有通过这个文件，才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。<br>image 是二进制文件。实际开发中，一个 image 文件往往通过继承另一个 image 文件，加上一些个性化设置而生成。</p></blockquote><p>容器： 容器就是跑起来的镜像，就是一个完整的工作环境</p><blockquote><p>image 文件生成的容器实例，本身也是一个文件，称为容器文件。也就是说，一旦容器生成，就会同时存在两个文件： image 文件和容器文件。而且关闭容器并不会删除容器文件，只是容器停止运行而已。</p></blockquote><h2 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h2><h3 id="Centos-yum-安装"><a href="#Centos-yum-安装" class="headerlink" title="Centos yum 安装"></a>Centos yum 安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 1. 移除旧版本docker</span><br><span class="line">yum remove docker \</span><br><span class="line">    docker-client \</span><br><span class="line">    docker-client-latest \</span><br><span class="line">    docker-common \</span><br><span class="line">    docker-latest \</span><br><span class="line">    docker-latest-logrotate \</span><br><span class="line">    docker-logrotate \</span><br><span class="line">    docker-selinux \</span><br><span class="line">    docker-engine-selinux \</span><br><span class="line">    docker-engine</span><br><span class="line"></span><br><span class="line"># 2. 更新yum</span><br><span class="line">yum -y update</span><br><span class="line"></span><br><span class="line"># 3. 安装常用工具</span><br><span class="line">yum install iproute ftp bind-utils net-tools wget yum-utils device-mapper-persistent-data lvm2 -y</span><br><span class="line"></span><br><span class="line"># 4. 安装Docker</span><br><span class="line">yum install docker -y</span><br><span class="line"></span><br><span class="line"># 5. 查看是否安装成功</span><br><span class="line">docker -v</span><br><span class="line">docker info</span><br></pre></td></tr></table></figure><h3 id="启停Docker"><a href="#启停Docker" class="headerlink" title="启停Docker"></a>启停Docker</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker.service</span><br><span class="line">systemctl status docker.service</span><br><span class="line">systemctl stop docker.service</span><br><span class="line">systemctl restart docker.service</span><br></pre></td></tr></table></figure><h3 id="虚拟机里安装Docker注意事项"><a href="#虚拟机里安装Docker注意事项" class="headerlink" title="虚拟机里安装Docker注意事项"></a>虚拟机里安装Docker注意事项</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">运行</span><br><span class="line">nslookup www.baidu.com</span><br><span class="line">若显示局域网地址，则代表需要进行之后步骤</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">把它改为公用的域名服务器地址</span><br><span class="line">vi &#x2F;etc&#x2F;resolv.conf</span><br><span class="line"></span><br><span class="line"># Generated by NetworkManager</span><br><span class="line">search www.tendawifi.com</span><br><span class="line">nameserver 119.29.29.29</span><br><span class="line">nameserver 182.254.116.116</span><br></pre></td></tr></table></figure><h3 id="配置镜像加速器"><a href="#配置镜像加速器" class="headerlink" title="配置镜像加速器"></a>配置镜像加速器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p &#x2F;etc&#x2F;docker</span><br><span class="line">tee &#x2F;etc&#x2F;docker&#x2F;daemon.json &lt;&lt;-&#39;EOF&#39;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;hvmf8r55.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br><span class="line">查看 daemon.json 是否已经生效了</span><br><span class="line">tail &#x2F;etc&#x2F;docker&#x2F;daemon.json</span><br></pre></td></tr></table></figure><h3 id="网络恢复"><a href="#网络恢复" class="headerlink" title="网络恢复"></a>网络恢复</h3><p>虚拟机一旦重启，或者关机过，那么就会出现可以访问 Linux，但是无法访问里面的 Docker的情况。可以在 CentOS里做如下事情：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;sysctl.conf</span><br><span class="line">或者</span><br><span class="line">vi &#x2F;usr&#x2F;lib&#x2F;sysctl.d&#x2F;00-system.conf</span><br><span class="line">添加如下代码：</span><br><span class="line">net.ipv4.ip_forward&#x3D;1</span><br><span class="line">重启network服务</span><br><span class="line">systemctl restart network</span><br><span class="line">查看是否修改成功</span><br><span class="line">sysctl net.ipv4.ip_forward</span><br><span class="line">如果返回为“net.ipv4.ip_forward &#x3D; 1”则表示成功了</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Basic Component </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Open System Interconnection Introduction</title>
      <link href="/2019/05/19/Open-System-Interconnection-Introduction/"/>
      <url>/2019/05/19/Open-System-Interconnection-Introduction/</url>
      
        <content type="html"><![CDATA[<h2 id="OSI-网络体系结构与-TCP-IP-协议模型"><a href="#OSI-网络体系结构与-TCP-IP-协议模型" class="headerlink" title="OSI 网络体系结构与 TCP/IP 协议模型"></a>OSI 网络体系结构与 TCP/IP 协议模型</h2><blockquote><p>OSI 是一个理论上的网络通信模型，而 TCP/IP 则是实际上的网络通信标准。但是，它们的初衷是一样的，都是为了使得两台计算机能够像两个知心朋友那样能够互相准确理解对方的意思并做出优雅的回应。<br>分层划分的结构，既能规定不同层完成的功能，又能实现层与层之间的改动而不相互影响。<br>起初网络分层是标准的七层，也就是 OSI 七层模型。之后又诞生了 TCP/IP 五层模型。</p></blockquote><p><img src="%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B_1.png" alt=""><br><img src="%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%988.png" alt=""></p><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p>参考模型的最低层，也是OSI模型的第一层，实现了相邻计算机节点之间比特流的透明传送，并尽可能地屏蔽掉具体传输介质和物理设备的差异，使其上层(数据链路层)不必关心网络的具体传输介质。</p><h3 id="数据链路层-data-link-layer"><a href="#数据链路层-data-link-layer" class="headerlink" title="数据链路层 data link layer"></a>数据链路层 data link layer</h3><p>接收来自物理层的位流形式的数据，并封装成帧，传送到上一层；同样，也将来自上层的数据帧，拆装为位流形式的数据转发到物理层。这一层在物理层提供的比特流的基础上，通过差错控制、流量控制方法，使有差错的物理线路变为无差错的数据链路，即提供可靠的通过物理介质传输数据的方法。</p><h4 id="以太网协议"><a href="#以太网协议" class="headerlink" title="以太网协议"></a>以太网协议</h4><blockquote><p>以太网规定，每组的电信号就是一个数据包，每个数据包我们可以称为“帧”。每帧的组成是由标头(Head)和数据(Data)组成。</p></blockquote><h5 id="标头"><a href="#标头" class="headerlink" title="标头"></a>标头</h5><p>用于供接收端判断该帧是否是发送给自己的。<br>数据包的标头中通常会存放一些有关数据包的说明、发送者是谁、接受者又是谁等相关识别信息。<br>标头的长度固定为 18 字节，也就是说，一些标头识别信息的大小不能超过 18 字节。</p><h5 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h5><p>是整个数据包的具体内容，比如文件、字符串之类的。<br>数据部分的长度最小至少为 46 个字节，最长 1500 字节。我们可能会想到，如果小于 46 字节没啥问题可以存放开，那么大于 1500 字节怎么处理呢？很简单，我们就分成两个包处理（分割），两个包存放不下就分割成三个包。</p><h4 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h4><p>广播的作用就是用来查找接收端的 MAC 地址，从而进行下一步的数据传输。注意，广播只是一种发送数据的形式，而计算机想要知道另一台计算机的 MAC 地址是通过 ARP 协议解决的。<br>稍微屡一下，我们想要发送数据，首先要知道对方的唯一标识（MAC 地址），要想知道对方的 MAC 地址，需要使用 ARP 协议，假设我们通过 ARP 协议拿到了接收方的 MAC 地址。<br>我们开始发送数据，将发送方的 MAC 地址和接收方的 MAC 地址封装在数据包中，然后发送端向同一子网络中（同一局域网）中的所有计算机发送该数据包，所有的计算机接收到该包之后，就对数据包的头部进行提取，提取出里边封装好的接收端 MAC 地址和自己的 MAC 地址作比对，如果相同，就说明该数据包是给自己发送的，否则，就会丢弃该数据包，这个过程就是广播的过程。<br>如果不在同一局域网中我们怎么处理？我们平常使用无线网都知道每个无线局域网都会有一个路由器，我们先通过以上的方法将数据发送到路由器，然后路由器转发数据到其他局域网中的计算机。</p><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>将网络地址翻译成对应的物理地址，并通过路由选择算法为分组通过通信子网选择最适当的路径。<br><img src="%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%989.png" alt=""></p><h4 id="IP协议与子网掩码"><a href="#IP协议与子网掩码" class="headerlink" title="IP协议与子网掩码"></a>IP协议与子网掩码</h4><blockquote><p>网络层中最重要的一个协议就是 IP 协议，我们一般发送端给服务端发送数据同时要知道两个地址才能准确送达到对方，分别为 IP 地址和 MAC 地址。</p></blockquote><p>IP 的数据包是直接放入到以太网数据包的“数据”部分的，这样做有一个好处就是“上层的变动完全涉及不到下层的结构”。然后数据包就变成这个样子了。<br><img src="%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B_2.png" alt=""></p><p>IP 数据包也分为标头(Head)和数据(Data)两部分。</p><ol><li>标头<br>IP 数据包的标头是 20 ~ 60 字节，主要包括版本、IP 地址等信息。</li><li>数据<br>数据的最大长度为 65515 字节。整个 IP 数据包的最大总长度为 65535 字节。主要存放 IP 数据包的具体内容。</li></ol><p>问题来了，以太网的数据部分最长为 1500 字节，你把一个长度为 65535 字节的 IP 数据包放到以太网的数据包汇总，不会被撑破吗？你在逗我么？确实是呀，那我们就分割数据包吧，分割成几个以太网数据包分开发送。</p><p>将 IP 地址抽象成一种逻辑上的地址，也就是说 MAC 地址是物理上的地址，就是定死了。而IP 地址是动态分配的，不是固定死的。<br>我们就是通过 IP 地址来判断两个计算机设备是否在同一子网络中的，具体利用子网掩码。<br>IP 地址是由 32 个二进制位组成的，也就是四个十进制（如：255.255.255.000）。<br>子网掩码也是由 32 个二进制位组成的，但是只能用 0 或 1 来表示，如11111111.11111111.11111111.00000000。</p><p>有 1 的部分表示网络部分，有 0 表示主机部分，两台计算机的 IP 地址分别和子网掩码进行一种运算（AND 运算），如果结果相同，两台计算机就在同一局域网中，否则就不在同一局域网中。</p><h4 id="ARP-协议"><a href="#ARP-协议" class="headerlink" title="ARP 协议"></a>ARP 协议</h4><blockquote><p>前提：对方的 IP 地址是已知的，通过 DNS 解析得到。</p></blockquote><p>ARP 协议发出一个数据包，包含在以太网的数据包中（其中包含对方的 IP 地址，对方的 MAC 地址栏是 FF:FF:FF:FF:FF:FF）。子网络中的每台主机都会收到这个包，然后从中取出 IP 地址与自身对比，如果两者相同，都做出回复，向对方报告自己的 MAC 地址，否则就丢弃这个包。</p><h3 id="传输层-transport-layer"><a href="#传输层-transport-layer" class="headerlink" title="传输层 transport layer"></a>传输层 transport layer</h3><p>传输层的主要功能就是为了能够实现“端口到端口”的通信。计算机上运行的不同程序都会分配不同的端口，所以才能使得数据能够正确的传送给不同的应用程序。<br>在源端与目的端之间提供可靠的透明数据传输，使上层服务用户不必关系通信子网的实现细节。在协议栈中，传输层位于网络层之上，传输层协议为不同主机上运行的进程提供逻辑通信，而网络层协议为不同主机提供逻辑通信，如下图所示。<br><img src="%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%9810.png" alt=""><br>实际上，网络层可以看作是传输层的一部分，其为传输层提供服务。但对于终端系统而言，网络层对它们而言是透明的，它们只知道传输层的存在，也就是说，在逻辑上它们认为是传输层为它们提供了端对端的通信，这也是分层思想的妙处。</p><h4 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h4><p>加入端口号也需要一套规则，那就是 UDP 协议，但是 UDP 协议有个缺点，一旦进行通信，就不知道对方是否接收到数据了，我们再定义一套规则，让其可以和对方进行确认，那么 TCP 出现了。</p><p>UDP 协议也分为标头(Head)和数据(Data)两部分。</p><ol><li>标头<br>标头的长度为 8 字节。主要存放了发送和接收端口号。</li><li>数据<br>数据部分和标头部分的总长度不超过 65535 字节，正好放进一个IP数据包。</li></ol><p>前边也讲过，数据包之间是包含关系的，所以 UDP 的数据包是放到 IP 数据包的“数据”部分的，IP 数据包又放在以太网数据包的“数据”部分的。</p><p><img src="%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B_3.png" alt=""></p><h4 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="TCP 协议"></a>TCP 协议</h4><p>我们通常说 TCP 三次握手和四次挥手，这就是传输层中完成的。<br>TCP 的数据包和 UDP 相同嵌入在 IP 协议的“数据”部分，TCP 并没有长度限制，但是为了保证传输效率，肯定要进行限制的，TCP 的数据包的长度一般不会超过 IP 数据包的长度了，保证单个的 TCP 数据包不再进行分割。</p><h3 id="会话层-Session-Layer"><a href="#会话层-Session-Layer" class="headerlink" title="会话层 Session Layer"></a>会话层 Session Layer</h3><p>会话层是OSI模型的第五层，是用户应用程序和网络之间的接口，负责在网络中的两节点之间建立、维持和终止通信。</p><h3 id="表示层-Presentation-Layer"><a href="#表示层-Presentation-Layer" class="headerlink" title="表示层 Presentation Layer"></a>表示层 Presentation Layer</h3><blockquote><p>数据的编码，压缩和解压缩，数据的加密和解密</p></blockquote><p>表示层是OSI模型的第六层，它对来自应用层的命令和数据进行解释，以确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。</p><h3 id="应用层-Application-layer"><a href="#应用层-Application-layer" class="headerlink" title="应用层 Application layer"></a>应用层 Application layer</h3><p>为用户的应用进程提供网络通信服务<br>应用层是最高一层，直接面向用户，它的数据包会放在 TCP 的数据包的“数据”部分，那么整个五层的数据包就会变成一下这样。</p><p><img src="%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B_4.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Internet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OSI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ReadingNote——MMML</title>
      <link href="/2019/02/05/ReadingNote%E2%80%94%E2%80%94MMML/"/>
      <url>/2019/02/05/ReadingNote%E2%80%94%E2%80%94MMML/</url>
      
        <content type="html"><![CDATA[<h2 id="ReadingNote——Multimodal-Machine-Learning-A-Survey-and-Taxonomy"><a href="#ReadingNote——Multimodal-Machine-Learning-A-Survey-and-Taxonomy" class="headerlink" title="ReadingNote——Multimodal Machine Learning : A Survey and Taxonomy"></a>ReadingNote——Multimodal Machine Learning : A Survey and Taxonomy</h2><blockquote><p>Multimodal machine learning aims to build models that can process and relate information from multiple modalities.<br>多模态机器学习旨在：建立能够处理和关联来自多个模态的信息的模型。</p></blockquote><p>Three main modalities: natural languages; visual signals; vocal signals</p><h3 id="Challenges"><a href="#Challenges" class="headerlink" title="Challenges"></a>Challenges</h3><ol><li>Represatation（表征）<blockquote><p>学习怎样以一种利用多模态的互补性和冗余性的方式，表示和汇总多模态数据。多模态数据具有异构性。</p></blockquote></li><li>Translation（翻译）<blockquote><p>怎样将数据从一种模态转换（映射）为另一种模态。除了数据的异构性，模态之间的关系往往是开放或主观的。eg：描述一张图像的正确方法有很多，但是没有一种完美的translation。</p></blockquote></li><li>Alignment（对齐）<blockquote><p>从两种或两种以上的不同模态中，确定（子）要素之间的直接关系。eg：将菜谱中的步骤与显示正在制作的菜肴的视频对齐。为了应对这一挑战，我们需要衡量不同模态之间的相似性，并且处理可能的长期依赖性和模糊性。</p></blockquote></li><li>Fusion（融合）<blockquote><p>融合两个或多个模态的信息来进行预测。eg：对于视听语音识别，将嘴唇运动的视觉描述与语音信号融合来预测说的单词。来自不同模态的信息可能具有不同的预测能力和噪声拓扑，其中至少一种模态可能会有缺失数据。</p></blockquote></li><li>Co-learning（联合学习）<blockquote><p>在模态、模态地表示和模态的预测模型之间传递知识。这一点可以通过co-learning, conceptual grounding和one-shot learning的算法来证明。co-learning探索了怎样利用从一个模态学习的知识，来帮助在不同模态上训练的计算模型。当其中一种模态的资源有限时（如标注数据），这一挑战尤其重要。</p></blockquote></li></ol><h3 id="Summary-of-applicatons-and-the-core-technical-challenges-to-be-addressed"><a href="#Summary-of-applicatons-and-the-core-technical-challenges-to-be-addressed" class="headerlink" title="Summary of applicatons and the core technical challenges to be addressed"></a>Summary of applicatons and the core technical challenges to be addressed</h3><p><img src="1.PNG" alt=""></p><h3 id="Representation"><a href="#Representation" class="headerlink" title="Representation"></a>Representation</h3><p>we use the term feature and representation interchangeably, with each referring to a vector or tensor representation of an entity, be it an image, audio sample, individual word, or a sentence.<br><strong>A multimodal representation is a representation of data using information from multiple such entities.</strong><br>以一种计算模型能采用工作的形式表示数据一直是machine learning的一个挑战。<br>我们可以互换使用“特征”和“表示”，每个都是一个实体的向量或张量表示，它可以是一张图像，音频样本，单个单词或一个句子。multimodal representation是使用来自多个这样的实体的信息来表示数据的一种表示。<br><strong>表征是一个非常基础的任务，好的表征能极大的提高模型的表现。<br>利用多模态表示学习到的特征可以用来做信息检索，也可以用于的分类/回归任务。下面列举几个经典的应用。</strong></p><h4 id="Difficulties"><a href="#Difficulties" class="headerlink" title="Difficulties"></a>Difficulties</h4><ol><li>数据的异构性，如文字是符号性的，图片是一个RGB矩阵，视频是时序的RGB矩阵，声音的采样结果是一个一位数组。</li><li>不同模态产生的噪声的级别不同。</li><li>数据的缺失问题。</li></ol><h4 id="Good-Properties"><a href="#Good-Properties" class="headerlink" title="Good Properties"></a>Good Properties</h4><p>以一种比较有意义的方式表示数据的能力，对于多模态问题至关重要，并且是任意模型的骨干。</p><ul><li>smoothness（平滑）</li><li>temporal and spatial coherence（时间与空间的一致性）</li><li>sparsity（稀疏性）</li><li>natural clustering（自然聚类）</li><li>similarity in the representation space should reflect the similarity of the corresponding concepts（表示空间的相似性应该反映相应概念的相似性）</li><li>the representation should be easy to obtain even in the absence of some modalities（即使在某些模态数据缺失的情况下，也应该很容易获得representation）</li><li>it should be possible to all-in missing modalities given the observed ones（在给定已有的模态的情况下，应该可以确定缺失的模态）</li></ul><h4 id="两种-unimodal-representation"><a href="#两种-unimodal-representation" class="headerlink" title="两种 unimodal representation"></a>两种 unimodal representation</h4><p>在自然语言处理中，文本特征最初依赖于计算文档中单词出现的次数，但现在多用“利用单词上下文的数据驱动的单词嵌入”（unimodal representation）。<br>虽然unimodal representation方面有大量的工作，但直到近期，大多数multimodal representation只是将unimodal ones简单连接在一起，不过这一点正在改变。</p><ul><li>Joint representations<blockquote><p>将unimodal signals组合到同一个表示空间中，代表方法有神经网络的方法、图模型方法与序列模型方法。<br>主要（但不是唯一）用于：在train和inference步骤中都存在多模态数据的任务。<br>最简单的例子就是：单个模态特征的串联（也称为早期融合）。</p></blockquote></li><li>Coordinated representations<blockquote><p>分别处理unimodal signals，但要对它们增加一定的相似性约束，使它们变成我们想要的协同空间（coordinated space）<br>协调方法特征仍在原空间，但是通过相似度或者结构特征协调。</p></blockquote></li></ul><ol><li>Joint representations将多模态数据映射到公共空间中，更适合于：在推理（inference）过程中，所有模态都存在。广泛应用于：AVSR，情感和多模态手势识别。</li><li>Coordinated representations将每个模态分别映射到分开的但是协同的空间中，更适合于：在测试时只有一种模态，应用于：multimodal retrieval and representation, grounding, zero shot learning。</li><li>另外，joint representations用于两种以上模态的情形。coordinated representation大多限制到2种。</li></ol><p><img src="2.png" alt=""></p><h4 id="Representation-Taxonomy"><a href="#Representation-Taxonomy" class="headerlink" title="Representation Taxonomy"></a>Representation Taxonomy</h4><p><img src="3.png" alt=""></p><h5 id="1-neural-networks"><a href="#1-neural-networks" class="headerlink" title="(1) neural networks"></a>(1) neural networks</h5><p>一般来说，神经网络由连续的内积，后跟非线性激活函数组成。为了用神经网络来表示数据，首先要对其进行训练，使之能够执行特定的任务（eg：识别图像中的对象）。由于深度神经网络的多层性，假设每个连续层以更抽象的方式表示数据，因此通常使用最后一层或倒数第二层作为数据表示形式。</p><p>为了利用神经网络构造multimodal representation，每个模态从几个单独的神经层开始，然后是一个隐层，将模态映射到一个联合空间中。然后，the joint multimodal representation被送到多个隐藏层中，或直接用来预测。这样的模型可以通过端到端的学习来表示数据并执行特定任务。所以在使用神经网络时，multimodal representation学习和multimodal fusion之间由很密切的联系。</p><p>由于神经网络需要大量标记的训练数据，因此通常使用来自不同，但是相关的领域的无监督数据（eg：自动编码器模型）或监督数据，对此类表示进行训练。</p><p>基于neural network的joint representations的主要优点是：当标记的数据不足以进行监督利用未标记的数据进行学习时，能够利用未标记的数据进行预训练。通常也被用于对现有的特定任务的结果表示进行微调，因为利用无监督数据构建的表示是通用的，并且不一定需要它是最好的。</p><p>其中一个缺点是：不能很自然地处理丢失地数据，尽管有很多方法缓解这个问题。</p><h5 id="2-probabilistic-graphical-models"><a href="#2-probabilistic-graphical-models" class="headerlink" title="(2) probabilistic graphical models"></a>(2) probabilistic graphical models</h5><p>概率图模型，可以用潜在的随机变量来构造表示。</p><p>DBMs（深度玻尔兹曼机）不需要监督数据来进行训练。由于是图模型，数据的表示是概率的，但是可以将其转换为确定的神经网络，但是这将失去模型的生成方面。</p><p>在单模态数据进行非线性转换后，整合数据，对模型是非常有利的。</p><p>使用多模态DBMs学习multimodal representations的一个很大的优点是：生成性。这一特性使得处理丢失数据的方法更简单，即使丢失了整个模态，模型也能自然的处理。还可以在第二种模态存在的情况下，生成第一种模态的样本，或者从representation中生成两种模态。与自动编码器类似，the representation可以使用未标记的数据进行无监督训练。</p><p>DBMs的主要缺点是：训练难度大——计算成本高；需要使用近似变分训练方法（approximate variational training methods）。</p><h5 id="3-sequential-representation"><a href="#3-sequential-representation" class="headerlink" title="(3) sequential representation"></a>(3) sequential representation</h5><p>我们通常需要表示不同长度的序列，eg: sentences, videos, audio streams。RNNs及其变体LSTM在不同任务的序列建模方面取得了成功。到目前为止，RNN主要用于表示单模态的单词、音频或图像序列，在语言领域取得很大的成功。与传统的神经网络相似，RNN的隐藏态可以看作是数据的一种表示，也就是说，RNN在时间步t处的隐藏态，可以看作是该时间步之前序列的总结</p><h5 id="4-similarity-models"><a href="#4-similarity-models" class="headerlink" title="(4) similarity models"></a>(4) similarity models</h5><p>相似性模型最小化了协同空间中模态之间的距离。eg: 使单词”dog”与dog的图像之间的距离小于单词”dog”和car的图像之间的距离。</p><p>近年来，由于神经网络的学习表示的能力，所以神经网络已经成为一种常用的构造coordinated representations的方法。优势就在于神经网络可以以端到端的方式一起学习coordinated representations。这种coordinated representation的一个例子：DeViSE——一种深层视觉语义嵌入。</p><p>cross-model retrieval和video description任务，通常用：&lt;主语，动词，宾语&gt;，即&lt;subject, verb, object&gt;组合的语言模型和深层视频模型，来在video和sentence之间构造coordinated space。</p><h5 id="5-structured-coordinated-space"><a href="#5-structured-coordinated-space" class="headerlink" title="(5) structured coordinated space"></a>(5) structured coordinated space</h5><p>上面的模型增强了representations之间的相似性，但structured coordinated space模型超越了这一点，并且增强了模态表示之间额外的约束。增强的结构的类型通常是基于应用的，hashing, cross-modal retrieval, image captioning的约束是不同的。</p><p>structured coordinated spaces通常用于跨模态哈希——将高维数据压缩成紧凑的二进制代码，相似的对象有相似的二进制代码。hashing在结果多模态空间上增强了一定的约束：1）它必须是一个N维Hamming空间——一个具有可控位数的二进制表示。2）不同模态的相同对象必须有相似的hash code。3）空间必须保持相似性。</p><p>structured coordinated representation的另一个例子，来自图像和语言的顺序嵌入。</p><p>structured coordinated space的一个特殊情况：基于典型相关分析（canonical correlation analysis, CCA）,CCA计算线性投影，使两个变量（文中是指模态）之间的相关性最大化，并且增强新空间的正交性。CCA模型已经广泛用于cross-modal retrieval和audiovisual signal analysis。CCA的延伸尝试构造相关最大化非线性映射。</p><p>（还有KCCA，DCCA，略）</p><p>CCA，KCCA，DCCA都是无监督的，仅优化representations之间的相关性，因此捕捉的多是模态间共享的东西。深度典型相关的自动编码器还包括基于自动编码器的数据重建项。这鼓励了representation捕捉模态的特有信息。语义相关最大化方法也支持语义相关性，同时保留相关性最大化和结果空间的正交性，这也促进了CCA和cross-modal hashing技术的结合。</p><h4 id="经典应用"><a href="#经典应用" class="headerlink" title="经典应用"></a>经典应用</h4><ol><li>在来自 NIPS 2012 的 《Multimodal learning with deep boltzmann machines》一文中提出将 deep boltzmann machines（DBM） 结构扩充到多模态领域，通过 Multimodal DBM，可以学习到多模态的联合概率分布。</li><li>协同表示学习一个比较经典且有趣的应用是来自于《Unifying Visual-Semantic Embeddings with Multimodal Neural Language Models 》这篇文章。利用协同学习到的特征向量之间满足加减算数运算这一特性，可以搜索出与给定图片满足“指定的转换语义”的图片。例如：<br>狗的图片特征向量 - 狗的文本特征向量 + 猫的文本特征向量 = 猫的图片特征向量 -&gt; 在特征向量空间，根据最近邻距离，检索得到猫的图片</li></ol><h3 id="Translation"><a href="#Translation" class="headerlink" title="Translation"></a>Translation</h3><p>实际上也可以理解为映射（mapping）。MML很大一部分研究专注于将一种模态数据翻译（映射）为另一种模态数据。</p><h4 id="Technique-Classfication"><a href="#Technique-Classfication" class="headerlink" title="Technique Classfication"></a>Technique Classfication</h4><ul><li>example-based<blockquote><p>模型在模态之间translating时使用了一个dictionary。<br>从特征字典中找出最佳翻译。基于样本的方法分为基于检索式的和合并的方法。</p></blockquote></li><li>generative<blockquote><p>构造一个model，可以生成translation。<br>通过样本，训练一个翻译模型，并使用翻译模型完成对特征的转换。生成式的方法有基于语法的、encoder-decoder模型和连续模型。</p></blockquote></li></ul><p>简单的理解：测试阶段，example-based是需要字典的，而生成式是不需要字典的，它通过数据学习到两个模态潜在的映射关系。<br>可以说，构造generative模型更具挑战性，因为它要求能够生成信号或符号序列（eg, sentences）。这对于任何模态——visual, acoustic(听觉)，verbal(语言)来说都是困难的，尤其是需要生成时间上和结构上一致的序列时。这使得很多早期的multimodal translation系统依赖于example-based translation。</p><p><img src="4.png" alt=""></p><h4 id="Difficulties-1"><a href="#Difficulties-1" class="headerlink" title="Difficulties"></a>Difficulties</h4><ol><li>open-ended，即未知结束位，例如实时翻译中，在还未得到句尾的情况下，必须实时的对句子进行翻译.</li><li>另一个是subjective，即主观评判性，是指很多模态转换问题的效果没有一个比较客观的评判标准，也就是说目标函数的确定是非常主观的。例如，在图片描述中，形成怎样的一段话才算是对图片好的诠释？也许一千个人心中有一千个哈姆雷特吧。非常难于评估，因为这类任务没有标准答案，答案通常非常开放和主观。这其实也是机器翻译面临的问题。</li></ol><p>为了解决评估困难，提出了VQA（Visual question-answering）任务。然而它也有问题，例如特定问题的歧义性，回答和问题偏置(ambiguity of certain questions and answers and question bias)。</p><h4 id="Translation-Taxonomy"><a href="#Translation-Taxonomy" class="headerlink" title="Translation Taxonomy"></a>Translation Taxonomy</h4><p><img src="5.png" alt=""></p><h4 id="example-based"><a href="#example-based" class="headerlink" title="example-based"></a>example-based</h4><h5 id="retrieval-based模型"><a href="#retrieval-based模型" class="headerlink" title="retrieval-based模型"></a>retrieval-based模型</h5><blockquote><p>直接使用retrieved translation,并没有对其进行修改。</p></blockquote><p>retrieval-based模型可以说是multimodal translation中最简单的形式，它依靠找到dictionary中最近的样本，并将其作为translate的结果，检索可以在单模态空间或中间语义空间（intermediate semantic space）中进行。</p><p>给出一个要translate的单模态实例，单模态检索要在源空间的dictionary中找到最接近的实例。</p><p>这种单模态检索方法的优点：它只需要我们正在检索的单个模态的representation.（The advantage of such unimodal retrieval approches is that they only require the representation of a single modality through which we are performing retrieval.）然而，它通常需要额外的多模态后续处理步骤，比如对retrieved translation进行重新排序，这表明这种方法的一个主要问题：单模态空间的相似性并不总意味着时良好的选择。</p><p>另一种方法是在retrieval过程中，使用中间语义空间来进行相似性比较。</p><p>语义空间中的检索方法往往比单模态检索方法更好，因为它们在一个更具意义的空间检索示例，该空间反映了2中模态，并且通常会对检索进行优化。此外，它也可以进行双向translation，这在单模态方法中并不容易。然而，这需要人为地去构造或学习这样一种语义空间，并且需要有大型训练dictionary（成对样本数据集）。</p><h5 id="combination-based模型"><a href="#combination-based模型" class="headerlink" title="combination-based模型"></a>combination-based模型</h5><blockquote><p>依赖于更复杂的规则，基于大量检索实例来创建translation。</p></blockquote><p>使retrieval-based方法更进一步，它不仅仅是从dictionary中检索示例，还会用一种更有意义的方法把这些示例结合起来，来构造更好的translation。基于组合的媒体描述方法是基于：图像的句子描述共享一个可以被利用的公共的、简单的结构。最常见的组合规则是手动的或基于启发式的。</p><h5 id="example-based方法存在的问题"><a href="#example-based方法存在的问题" class="headerlink" title="example-based方法存在的问题"></a>example-based方法存在的问题</h5><ol><li>模型是整个字典，这就会使模型很大，推理起来很慢（不过，hashing之类的方法可以缓解）。</li><li>除非任务很简单，或者字典很大，否则，期望与源例相关的、完整的、准确的translation总是存在于字典中是不现实的。（combination模型能构造更复杂的结构，所以能部分解决上述问题，然而它也只能在一个方向上进行translate，不过，semantic space retrieval-based模型可以在两个方向上进行translate.）</li></ol><h4 id="generative"><a href="#generative" class="headerlink" title="generative"></a>generative</h4><h5 id="grammar-based"><a href="#grammar-based" class="headerlink" title="grammar-based"></a>grammar-based</h5><blockquote><p>通常通过使用语法来限制目标域，以简化任务，eg：基于&lt;subject, object, verb&gt;模板来生成受限制的句子。</p></blockquote><p>基于语法的模型，根据预定义的语法，来生成特定的模态。首先，从源模态中检测高级概念，比如图像中的对象、视频中的动作。然后，将这些检测到的高级概念，与基于预定义的语法的生成程序，结合到一起，以生成目标模态。</p><p>grammar-based方法的优点是：因为它们使用预定义的模板和限定的语法，所以很可能生成在语法上（对于language）或逻辑上正确的目标实例。缺点：限制了它们，只能生成公式化的而不是创造性的translation。</p><p>此外，grammar-based方法依赖于更复杂的pipline来进行概念检测，每个概念都需要一个单独的model和一个单独的训练集。</p><h5 id="encoder-decoder"><a href="#encoder-decoder" class="headerlink" title="encoder-decoder"></a>encoder-decoder</h5><blockquote><p>首先将源模态编码成潜在表示，然后送到解码器中，生成目标模态。</p></blockquote><p>基于端到端训练的神经网络的编码器-解码器模型是目前最流行的multimodal translation技术之一。这种模型背后的主要思想：首先，将源模态编码为向量表示，然后，用解码器生成目标模态，所有这些都是在单过程pipline进行的。</p><p>使用RNN生成translation面临的问题：模型必须从图像、句子或视频的单个向量representation中生成描述。这在生成长序列时，尤其困难，因为模型可能会忘记初始输入。通过在解码过程中的每一步，包含进编码信息，可以部分解决这个问题。还提出了注意力模型，使生成期间，解码器能更好的聚焦于图像、句子或视频的某些部分。</p><p>最近，在使用生成对抗网络生成图像方面取得了很大的进展，该网络已被用作RNN的替代方案，用于“从文本生成图像”。</p><h5 id="continuous-generation"><a href="#continuous-generation" class="headerlink" title="continuous generation"></a>continuous generation</h5><blockquote><p>基于源模态输入流，连续生成目标模态；最适合在时间序列之间translate. eg：文本到语音（text-to-speech）。</p></blockquote><p>用于序列translation,以在线的方式，在每个时间步都生成输出。当从一个序列translate到另一个序列时（eg：text to speech, speech to text, video to text），这些模型很有用。</p><p>针对这类模型提出的不同技术： graphical modals, continuous encoder-decoder approaches，以及其他回归或分类技术。</p><p>这列模型需要解决的额外的困难：模态间时间一致性的需求。</p><p>早期，许多工作使用图模型来在连续信号之间进行multimodal translation，然而这些方法正在被基于神经网络编码器-解码器的技术所取代。</p><h4 id="经典应用-1"><a href="#经典应用-1" class="headerlink" title="经典应用"></a>经典应用</h4><ol><li>机器翻译（Machine Translation）：将输入的语言A（即时）翻译为另一种语言B。类似的还有唇读（Lip Reading）和语音翻译 （Speech Translation），分别将唇部视觉和语音信息转换为文本信息。</li><li>图片描述（Image captioning) 或者视频描述（Video captioning)： 对给定的图片/视频形成一段文字描述，以表达图片/视频的内容。</li><li>语音合成（Speech Synthesis）：根据输入的文本信息，自动合成一段语音信号。</li></ol><h3 id="Alignment"><a href="#Alignment" class="headerlink" title="Alignment"></a>Alignment</h3><p>从两个甚至多个模态中寻找事物子成份之间的关系和联系。对齐可以是空间维度的，比如图片语义分割，给定一张图片和图片的描述，找到图中的某个区域以及这个区域在描述中对应的表述。也可以是时间维度的，比如给定一个美食制作视频和对应的菜谱，实现菜谱中的步骤描述与视频分段的对应。</p><p>对齐分为两类：<strong>显式对齐和隐式对齐</strong>。显式对齐即应用的主要任务就是对齐，而隐式对齐是指应用在完成主要任务时需要用到对齐的技术。</p><h4 id="技术方法分类"><a href="#技术方法分类" class="headerlink" title="技术方法分类"></a>技术方法分类</h4><ol><li>显示对齐：Unsupervised；(Weakly)Supervised</li><li>隐式对齐：Graphical models；Neural networks（attention机制）</li></ol><h4 id="Difficulties-2"><a href="#Difficulties-2" class="headerlink" title="Difficulties"></a>Difficulties</h4><ol><li>很少有显式对齐标注的数据集</li><li>不同模态之间相似度的计算难以建模</li><li>存在多个可能的对齐方案，此外不是一个模态的所有元素在另一个模态中都存在对应</li></ol><h4 id="Alignment-Taxonomy"><a href="#Alignment-Taxonomy" class="headerlink" title="Alignment Taxonomy"></a>Alignment Taxonomy</h4><p><img src="6.png" alt=""></p><h3 id="Fusion"><a href="#Fusion" class="headerlink" title="Fusion"></a>Fusion</h3><p>多模态融合指从多个模态信息中整合信息来完成分类或回归任务。“multimodal fusion is the concept of integrating information from multiple modalities with the goal of predicting an outcome measure: a class (e.g., happy vs. sad) through classi?cation, or a continuous value (e.g., positivity of sentiment) through regression.”即是负责联合多个模态的信息，进行目标预测（分类或者回归）</p><p>融合还有更宽泛的定义，而综述中定义的融合，是指任务在最后预测并以预测输出值为目的时才进行多模态融合。在深度神经网络方法下，融合和表征两个任务是很难区分的。但在图模型以及基于核的方法中比较好区分。</p><p>多模态特征融合是指将从不同模态的特征集成在一起，共同完成一个任务，如分类。</p><h4 id="Significances"><a href="#Significances" class="headerlink" title="Significances"></a>Significances</h4><ol><li>在观察同一个现象时引入多个模态，可能带来更robust的预测</li><li>接触多个模态的信息，可能让我们捕捉到互补的信息（complementary information），尤其是这些信息在单模态下并不“可见”时。</li><li>一个多模态系统在缺失某一个模态时依旧能工作</li></ol><p>多模态融合有两大类：<strong>无模型model-agnostic</strong>；<strong>基于模型model-based</strong></p><blockquote><p><strong>model-agnostic</strong>：不直接依赖于某个特定的机器学习算法</p></blockquote><ul><li><strong>early fusion</strong> 也称为feature-based，是基于特征的。通常是在提取各模态特征后就进行融合，一般只是简单地连接他们的表征，即joint representation。并使用融合后的数据进行模型训练，相比之后两种在训练上更为简单。</li><li><strong>late fusion</strong> 也称为decision-based，是基于决策的。该方法在各个模态做出决策后才进行融合，得出最终的决策。常见的机制有平均（averaging）、投票（voting schemes）等等。这种方法中，各模态可以使用不同的模型来训练，带来更多的便利性。</li><li><strong>hybrid fusion</strong> 一种尝试结合early fusion和late fusion优势的方法。</li></ul><blockquote><p><strong>model-based</strong>：显式得在构造中完成融合</p></blockquote><ul><li><strong>Multiple Kernel Learning</strong> 多核学习</li><li><strong>Graphical models</strong> 图模型</li><li><strong>Neural Networks</strong> 神经网络</li><li>神经网络在近期成为解决融合问题非常流行的方案，然而图模型以及多核学习依旧被使用，尤其是在有限的训练数据和模型可解释性非常重要的情况下。</li></ul><h4 id="Difficulties-3"><a href="#Difficulties-3" class="headerlink" title="Difficulties"></a>Difficulties</h4><p>多模态融合研究的难点主要包括如何判断每个模态的置信水平、如何判断模态间的相关性、如何对多模态的特征信息进行降维以及如何对非同步采集的多模态数据进行配准等。</p><ol><li>信号可能并不是时序对齐的（temporally aligned）。很可能是密集的连续信号和稀疏的事件（比如一大段视频只对应一个词，然后整个视频只对应稀少的几个词）。</li><li>it is difficult to build models that exploit supplementary and not only complementary information</li><li>每一个模态在不同的时间点可能表现出不同的形式和不同等级的噪声</li></ol><h4 id="Fusion-Taxonomy"><a href="#Fusion-Taxonomy" class="headerlink" title="Fusion Taxonomy"></a>Fusion Taxonomy</h4><p><img src="7.png" alt=""></p><h4 id="经典应用-2"><a href="#经典应用-2" class="headerlink" title="经典应用"></a>经典应用</h4><ol><li>视觉-音频识别（Visual-Audio Recognition）： 综合源自同一个实例的视频信息和音频信息，进行识别工作。</li><li>多模态情感分析（Multimodal sentiment analysis）： 综合利用多个模态的数据（例如下图中的文字、面部表情、声音），通过互补，消除歧义和不确定性，得到更加准确的情感类型判断结果。</li><li>手机身份认证（Mobile Identity Authentication）： 综合利用手机的多传感器信息，认证手机使用者是否是注册用户。</li></ol><h3 id="Co-Learning"><a href="#Co-Learning" class="headerlink" title="Co-Learning"></a>Co-Learning</h3><ul><li>联合学习的目的是通过利用资源丰富（比如数据量大）的模态的知识来辅助资源稀缺（比如较小数据）的模态建立模型。比如迁移学习（Transfer Learning）就是属于这个范畴，绝大多数迈入深度学习的初学者尝试做的一项工作就是将 ImageNet 数据集上学习到的权重，在自己的目标数据集上进行微调。</li><li>联合学习 is task independent and could be used to create better fusion, translation, and alignment models.</li><li>联合学习中，辅助模态（helper modality）通常只参与模型的训练过程，并不参与模型的测试使用过程。即使用时，模型输入并不需要辅助模态的数据。</li></ul><h4 id="联合学习的分类是基于训练资源（数据）形式划分的"><a href="#联合学习的分类是基于训练资源（数据）形式划分的" class="headerlink" title="联合学习的分类是基于训练资源（数据）形式划分的"></a>联合学习的分类是基于训练资源（数据）形式划分的</h4><p><img src="9.png" alt=""><br><strong>parallel</strong> modalities are from the same dataset and there is a direct correspondence between instances;<br><strong>non-parallel</strong> modalities are from different datasets and do not have overlapping instances, but overlap in general categories or concepts;<br><strong>hybrid</strong> the instances or concepts are bridged by a third modality or a dataset.</p><h4 id="Co-Learning-Taxonomy"><a href="#Co-Learning-Taxonomy" class="headerlink" title="Co-Learning Taxonomy"></a>Co-Learning Taxonomy</h4><p><img src="8.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Paper Reading </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Deep Learning </tag>
            
            <tag> Machine Learning </tag>
            
            <tag> Multimodal </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
